import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { isValidHostname as __isValidHostname, } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, map, parseEpochTimestamp as __parseEpochTimestamp, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, take, withBaseException, } from "@smithy/smithy-client";
import { LakeFormationServiceException as __BaseException } from "../models/LakeFormationServiceException";
import { AccessDeniedException, AlreadyExistsException, ConcurrentModificationException, EntityNotFoundException, ExpiredException, GlueEncryptionException, InternalServiceException, InvalidInputException, OperationTimeoutException, PermissionTypeMismatchException, ResourceNotReadyException, ResourceNumberLimitExceededException, StatisticsNotReadyYetException, ThrottledException, TransactionCanceledException, TransactionCommitInProgressException, TransactionCommittedException, WorkUnitsNotReadyYetException, } from "../models/models_0";
export const se_AddLFTagsToResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/AddLFTagsToResource");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        LFTags: (_) => _json(_),
        Resource: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AssumeDecoratedRoleWithSAMLCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/AssumeDecoratedRoleWithSAML");
    let body;
    body = JSON.stringify(take(input, {
        DurationSeconds: [],
        PrincipalArn: [],
        RoleArn: [],
        SAMLAssertion: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_BatchGrantPermissionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/BatchGrantPermissions");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        Entries: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_BatchRevokePermissionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/BatchRevokePermissions");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        Entries: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CancelTransactionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CancelTransaction");
    let body;
    body = JSON.stringify(take(input, {
        TransactionId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CommitTransactionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CommitTransaction");
    let body;
    body = JSON.stringify(take(input, {
        TransactionId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDataCellsFilterCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateDataCellsFilter");
    let body;
    body = JSON.stringify(take(input, {
        TableData: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateLakeFormationIdentityCenterConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateLakeFormationIdentityCenterConfiguration");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        ExternalFiltering: (_) => _json(_),
        InstanceArn: [],
        ShareRecipients: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateLakeFormationOptInCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateLakeFormationOptIn");
    let body;
    body = JSON.stringify(take(input, {
        Principal: (_) => _json(_),
        Resource: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateLFTagCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateLFTag");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        TagKey: [],
        TagValues: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteDataCellsFilterCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteDataCellsFilter");
    let body;
    body = JSON.stringify(take(input, {
        DatabaseName: [],
        Name: [],
        TableCatalogId: [],
        TableName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteLakeFormationIdentityCenterConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteLakeFormationIdentityCenterConfiguration");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteLakeFormationOptInCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteLakeFormationOptIn");
    let body;
    body = JSON.stringify(take(input, {
        Principal: (_) => _json(_),
        Resource: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteLFTagCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteLFTag");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        TagKey: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteObjectsOnCancelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteObjectsOnCancel");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        DatabaseName: [],
        Objects: (_) => _json(_),
        TableName: [],
        TransactionId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeregisterResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeregisterResource");
    let body;
    body = JSON.stringify(take(input, {
        ResourceArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeLakeFormationIdentityCenterConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DescribeLakeFormationIdentityCenterConfiguration");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DescribeResource");
    let body;
    body = JSON.stringify(take(input, {
        ResourceArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeTransactionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DescribeTransaction");
    let body;
    body = JSON.stringify(take(input, {
        TransactionId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ExtendTransactionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ExtendTransaction");
    let body;
    body = JSON.stringify(take(input, {
        TransactionId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetDataCellsFilterCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetDataCellsFilter");
    let body;
    body = JSON.stringify(take(input, {
        DatabaseName: [],
        Name: [],
        TableCatalogId: [],
        TableName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetDataLakeSettingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetDataLakeSettings");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetEffectivePermissionsForPathCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetEffectivePermissionsForPath");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        MaxResults: [],
        NextToken: [],
        ResourceArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetLFTagCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetLFTag");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        TagKey: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetQueryStateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetQueryState");
    let body;
    body = JSON.stringify(take(input, {
        QueryId: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "query-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetQueryStatisticsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetQueryStatistics");
    let body;
    body = JSON.stringify(take(input, {
        QueryId: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "query-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetResourceLFTagsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetResourceLFTags");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        Resource: (_) => _json(_),
        ShowAssignedLFTags: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetTableObjectsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetTableObjects");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        DatabaseName: [],
        MaxResults: [],
        NextToken: [],
        PartitionPredicate: [],
        QueryAsOfTime: (_) => Math.round(_.getTime() / 1000),
        TableName: [],
        TransactionId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetTemporaryGluePartitionCredentialsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetTemporaryGluePartitionCredentials");
    let body;
    body = JSON.stringify(take(input, {
        AuditContext: (_) => _json(_),
        DurationSeconds: [],
        Partition: (_) => _json(_),
        Permissions: (_) => _json(_),
        SupportedPermissionTypes: (_) => _json(_),
        TableArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetTemporaryGlueTableCredentialsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetTemporaryGlueTableCredentials");
    let body;
    body = JSON.stringify(take(input, {
        AuditContext: (_) => _json(_),
        DurationSeconds: [],
        Permissions: (_) => _json(_),
        QuerySessionContext: (_) => se_QuerySessionContext(_, context),
        S3Path: [],
        SupportedPermissionTypes: (_) => _json(_),
        TableArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetWorkUnitResultsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetWorkUnitResults");
    let body;
    body = JSON.stringify(take(input, {
        QueryId: [],
        WorkUnitId: [],
        WorkUnitToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetWorkUnitsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetWorkUnits");
    let body;
    body = JSON.stringify(take(input, {
        NextToken: [],
        PageSize: [],
        QueryId: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "query-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GrantPermissionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GrantPermissions");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        Permissions: (_) => _json(_),
        PermissionsWithGrantOption: (_) => _json(_),
        Principal: (_) => _json(_),
        Resource: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListDataCellsFilterCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListDataCellsFilter");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        Table: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListLakeFormationOptInsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListLakeFormationOptIns");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        Principal: (_) => _json(_),
        Resource: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListLFTagsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListLFTags");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        MaxResults: [],
        NextToken: [],
        ResourceShareType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListPermissionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListPermissions");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        IncludeRelated: [],
        MaxResults: [],
        NextToken: [],
        Principal: (_) => _json(_),
        Resource: (_) => _json(_),
        ResourceType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListResourcesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListResources");
    let body;
    body = JSON.stringify(take(input, {
        FilterConditionList: (_) => _json(_),
        MaxResults: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTableStorageOptimizersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListTableStorageOptimizers");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        DatabaseName: [],
        MaxResults: [],
        NextToken: [],
        StorageOptimizerType: [],
        TableName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTransactionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListTransactions");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        MaxResults: [],
        NextToken: [],
        StatusFilter: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PutDataLakeSettingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/PutDataLakeSettings");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        DataLakeSettings: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RegisterResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/RegisterResource");
    let body;
    body = JSON.stringify(take(input, {
        HybridAccessEnabled: [],
        ResourceArn: [],
        RoleArn: [],
        UseServiceLinkedRole: [],
        WithFederation: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RemoveLFTagsFromResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/RemoveLFTagsFromResource");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        LFTags: (_) => _json(_),
        Resource: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RevokePermissionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/RevokePermissions");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        Permissions: (_) => _json(_),
        PermissionsWithGrantOption: (_) => _json(_),
        Principal: (_) => _json(_),
        Resource: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_SearchDatabasesByLFTagsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/SearchDatabasesByLFTags");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        Expression: (_) => _json(_),
        MaxResults: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_SearchTablesByLFTagsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/SearchTablesByLFTags");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        Expression: (_) => _json(_),
        MaxResults: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartQueryPlanningCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/StartQueryPlanning");
    let body;
    body = JSON.stringify(take(input, {
        QueryPlanningContext: (_) => se_QueryPlanningContext(_, context),
        QueryString: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "query-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartTransactionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/StartTransaction");
    let body;
    body = JSON.stringify(take(input, {
        TransactionType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateDataCellsFilterCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateDataCellsFilter");
    let body;
    body = JSON.stringify(take(input, {
        TableData: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateLakeFormationIdentityCenterConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateLakeFormationIdentityCenterConfiguration");
    let body;
    body = JSON.stringify(take(input, {
        ApplicationStatus: [],
        CatalogId: [],
        ExternalFiltering: (_) => _json(_),
        ShareRecipients: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateLFTagCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateLFTag");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        TagKey: [],
        TagValuesToAdd: (_) => _json(_),
        TagValuesToDelete: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateResource");
    let body;
    body = JSON.stringify(take(input, {
        HybridAccessEnabled: [],
        ResourceArn: [],
        RoleArn: [],
        WithFederation: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateTableObjectsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateTableObjects");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        DatabaseName: [],
        TableName: [],
        TransactionId: [],
        WriteOperations: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateTableStorageOptimizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateTableStorageOptimizer");
    let body;
    body = JSON.stringify(take(input, {
        CatalogId: [],
        DatabaseName: [],
        StorageOptimizerConfig: (_) => _json(_),
        TableName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const de_AddLFTagsToResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Failures: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AssumeDecoratedRoleWithSAMLCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AccessKeyId: __expectString,
        Expiration: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        SecretAccessKey: __expectString,
        SessionToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchGrantPermissionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Failures: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchRevokePermissionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Failures: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CancelTransactionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CommitTransactionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        TransactionStatus: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDataCellsFilterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CreateLakeFormationIdentityCenterConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApplicationArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateLakeFormationOptInCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CreateLFTagCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDataCellsFilterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteLakeFormationIdentityCenterConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteLakeFormationOptInCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteLFTagCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteObjectsOnCancelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeregisterResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DescribeLakeFormationIdentityCenterConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApplicationArn: __expectString,
        CatalogId: __expectString,
        ExternalFiltering: _json,
        InstanceArn: __expectString,
        ResourceShare: __expectString,
        ShareRecipients: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ResourceInfo: (_) => de_ResourceInfo(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeTransactionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        TransactionDescription: (_) => de_TransactionDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ExtendTransactionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_GetDataCellsFilterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DataCellsFilter: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDataLakeSettingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DataLakeSettings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetEffectivePermissionsForPathCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        Permissions: (_) => de_PrincipalResourcePermissionsList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetLFTagCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CatalogId: __expectString,
        TagKey: __expectString,
        TagValues: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetQueryStateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Error: __expectString,
        State: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetQueryStatisticsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ExecutionStatistics: _json,
        PlanningStatistics: _json,
        QuerySubmissionTime: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetResourceLFTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        LFTagOnDatabase: _json,
        LFTagsOnColumns: _json,
        LFTagsOnTable: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetTableObjectsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        Objects: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetTemporaryGluePartitionCredentialsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AccessKeyId: __expectString,
        Expiration: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        SecretAccessKey: __expectString,
        SessionToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetTemporaryGlueTableCredentialsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AccessKeyId: __expectString,
        Expiration: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        SecretAccessKey: __expectString,
        SessionToken: __expectString,
        VendedS3Path: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetWorkUnitResultsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.ResultStream = data;
    return contents;
};
export const de_GetWorkUnitsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        QueryId: __expectString,
        WorkUnitRanges: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GrantPermissionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_ListDataCellsFilterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DataCellsFilters: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListLakeFormationOptInsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        LakeFormationOptInsInfoList: (_) => de_LakeFormationOptInsInfoList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListLFTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        LFTags: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPermissionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        PrincipalResourcePermissions: (_) => de_PrincipalResourcePermissionsList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListResourcesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        ResourceInfoList: (_) => de_ResourceInfoList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTableStorageOptimizersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        StorageOptimizerList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTransactionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        Transactions: (_) => de_TransactionDescriptionList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutDataLakeSettingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_RegisterResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_RemoveLFTagsFromResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Failures: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RevokePermissionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_SearchDatabasesByLFTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DatabaseList: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_SearchTablesByLFTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        TableList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartQueryPlanningCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        QueryId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartTransactionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        TransactionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateDataCellsFilterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateLakeFormationIdentityCenterConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateLFTagCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateTableObjectsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateTableStorageOptimizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Result: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lakeformation#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.lakeformation#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.lakeformation#EntityNotFoundException":
            throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.lakeformation#InternalServiceException":
            throw await de_InternalServiceExceptionRes(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.lakeformation#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.lakeformation#OperationTimeoutException":
            throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
        case "TransactionCommitInProgressException":
        case "com.amazonaws.lakeformation#TransactionCommitInProgressException":
            throw await de_TransactionCommitInProgressExceptionRes(parsedOutput, context);
        case "TransactionCommittedException":
        case "com.amazonaws.lakeformation#TransactionCommittedException":
            throw await de_TransactionCommittedExceptionRes(parsedOutput, context);
        case "TransactionCanceledException":
        case "com.amazonaws.lakeformation#TransactionCanceledException":
            throw await de_TransactionCanceledExceptionRes(parsedOutput, context);
        case "AlreadyExistsException":
        case "com.amazonaws.lakeformation#AlreadyExistsException":
            throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.lakeformation#ResourceNumberLimitExceededException":
            throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotReadyException":
        case "com.amazonaws.lakeformation#ResourceNotReadyException":
            throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
        case "ExpiredException":
        case "com.amazonaws.lakeformation#ExpiredException":
            throw await de_ExpiredExceptionRes(parsedOutput, context);
        case "StatisticsNotReadyYetException":
        case "com.amazonaws.lakeformation#StatisticsNotReadyYetException":
            throw await de_StatisticsNotReadyYetExceptionRes(parsedOutput, context);
        case "ThrottledException":
        case "com.amazonaws.lakeformation#ThrottledException":
            throw await de_ThrottledExceptionRes(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.lakeformation#GlueEncryptionException":
            throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
        case "PermissionTypeMismatchException":
        case "com.amazonaws.lakeformation#PermissionTypeMismatchException":
            throw await de_PermissionTypeMismatchExceptionRes(parsedOutput, context);
        case "WorkUnitsNotReadyYetException":
        case "com.amazonaws.lakeformation#WorkUnitsNotReadyYetException":
            throw await de_WorkUnitsNotReadyYetExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_AlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConcurrentModificationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_EntityNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new EntityNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ExpiredExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ExpiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_GlueEncryptionExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new GlueEncryptionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServiceExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServiceException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidInputExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidInputException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_OperationTimeoutExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new OperationTimeoutException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_PermissionTypeMismatchExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new PermissionTypeMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotReadyExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotReadyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNumberLimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNumberLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_StatisticsNotReadyYetExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new StatisticsNotReadyYetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottledExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TransactionCanceledExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TransactionCanceledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TransactionCommitInProgressExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TransactionCommitInProgressException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TransactionCommittedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TransactionCommittedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_WorkUnitsNotReadyYetExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new WorkUnitsNotReadyYetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_QueryPlanningContext = (input, context) => {
    return take(input, {
        CatalogId: [],
        DatabaseName: [],
        QueryAsOfTime: (_) => Math.round(_.getTime() / 1000),
        QueryParameters: _json,
        TransactionId: [],
    });
};
const se_QuerySessionContext = (input, context) => {
    return take(input, {
        AdditionalContext: _json,
        ClusterId: [],
        QueryAuthorizationId: [],
        QueryId: [],
        QueryStartTime: (_) => Math.round(_.getTime() / 1000),
    });
};
const de_LakeFormationOptInsInfo = (output, context) => {
    return take(output, {
        LastModified: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        LastUpdatedBy: __expectString,
        Principal: _json,
        Resource: _json,
    });
};
const de_LakeFormationOptInsInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LakeFormationOptInsInfo(entry, context);
    });
    return retVal;
};
const de_PrincipalResourcePermissions = (output, context) => {
    return take(output, {
        AdditionalDetails: _json,
        LastUpdated: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        LastUpdatedBy: __expectString,
        Permissions: _json,
        PermissionsWithGrantOption: _json,
        Principal: _json,
        Resource: _json,
    });
};
const de_PrincipalResourcePermissionsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PrincipalResourcePermissions(entry, context);
    });
    return retVal;
};
const de_ResourceInfo = (output, context) => {
    return take(output, {
        HybridAccessEnabled: __expectBoolean,
        LastModified: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ResourceArn: __expectString,
        RoleArn: __expectString,
        WithFederation: __expectBoolean,
    });
};
const de_ResourceInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResourceInfo(entry, context);
    });
    return retVal;
};
const de_TransactionDescription = (output, context) => {
    return take(output, {
        TransactionEndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        TransactionId: __expectString,
        TransactionStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        TransactionStatus: __expectString,
    });
};
const de_TransactionDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransactionDescription(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
