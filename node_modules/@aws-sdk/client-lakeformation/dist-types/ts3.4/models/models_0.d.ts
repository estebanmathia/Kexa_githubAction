import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { StreamingBlobTypes } from "@smithy/types";
import { LakeFormationServiceException as __BaseException } from "./LakeFormationServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export interface LFTagPair {
  CatalogId?: string;
  TagKey: string | undefined;
  TagValues: string[] | undefined;
}
export interface CatalogResource {}
export interface DatabaseResource {
  CatalogId?: string;
  Name: string | undefined;
}
export interface DataCellsFilterResource {
  TableCatalogId?: string;
  DatabaseName?: string;
  TableName?: string;
  Name?: string;
}
export interface DataLocationResource {
  CatalogId?: string;
  ResourceArn: string | undefined;
}
export interface LFTagKeyResource {
  CatalogId?: string;
  TagKey: string | undefined;
  TagValues: string[] | undefined;
}
export interface LFTag {
  TagKey: string | undefined;
  TagValues: string[] | undefined;
}
export declare const ResourceType: {
  readonly DATABASE: "DATABASE";
  readonly TABLE: "TABLE";
};
export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType];
export interface LFTagPolicyResource {
  CatalogId?: string;
  ResourceType: ResourceType | undefined;
  Expression: LFTag[] | undefined;
}
export interface TableWildcard {}
export interface TableResource {
  CatalogId?: string;
  DatabaseName: string | undefined;
  Name?: string;
  TableWildcard?: TableWildcard;
}
export interface ColumnWildcard {
  ExcludedColumnNames?: string[];
}
export interface TableWithColumnsResource {
  CatalogId?: string;
  DatabaseName: string | undefined;
  Name: string | undefined;
  ColumnNames?: string[];
  ColumnWildcard?: ColumnWildcard;
}
export interface Resource {
  Catalog?: CatalogResource;
  Database?: DatabaseResource;
  Table?: TableResource;
  TableWithColumns?: TableWithColumnsResource;
  DataLocation?: DataLocationResource;
  DataCellsFilter?: DataCellsFilterResource;
  LFTag?: LFTagKeyResource;
  LFTagPolicy?: LFTagPolicyResource;
}
export interface AddLFTagsToResourceRequest {
  CatalogId?: string;
  Resource: Resource | undefined;
  LFTags: LFTagPair[] | undefined;
}
export interface ErrorDetail {
  ErrorCode?: string;
  ErrorMessage?: string;
}
export interface LFTagError {
  LFTag?: LFTagPair;
  Error?: ErrorDetail;
}
export interface AddLFTagsToResourceResponse {
  Failures?: LFTagError[];
}
export declare class ConcurrentModificationException extends __BaseException {
  readonly name: "ConcurrentModificationException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      ConcurrentModificationException,
      __BaseException
    >
  );
}
export declare class EntityNotFoundException extends __BaseException {
  readonly name: "EntityNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<EntityNotFoundException, __BaseException>
  );
}
export declare class InternalServiceException extends __BaseException {
  readonly name: "InternalServiceException";
  readonly $fault: "server";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InternalServiceException, __BaseException>
  );
}
export declare class InvalidInputException extends __BaseException {
  readonly name: "InvalidInputException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidInputException, __BaseException>
  );
}
export declare class OperationTimeoutException extends __BaseException {
  readonly name: "OperationTimeoutException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<OperationTimeoutException, __BaseException>
  );
}
export interface AddObjectInput {
  Uri: string | undefined;
  ETag: string | undefined;
  Size: number | undefined;
  PartitionValues?: string[];
}
export interface AllRowsWildcard {}
export declare class AlreadyExistsException extends __BaseException {
  readonly name: "AlreadyExistsException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<AlreadyExistsException, __BaseException>
  );
}
export declare const ApplicationStatus: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type ApplicationStatus =
  (typeof ApplicationStatus)[keyof typeof ApplicationStatus];
export interface AssumeDecoratedRoleWithSAMLRequest {
  SAMLAssertion: string | undefined;
  RoleArn: string | undefined;
  PrincipalArn: string | undefined;
  DurationSeconds?: number;
}
export interface AssumeDecoratedRoleWithSAMLResponse {
  AccessKeyId?: string;
  SecretAccessKey?: string;
  SessionToken?: string;
  Expiration?: Date;
}
export interface AuditContext {
  AdditionalAuditContext?: string;
}
export declare const Permission: {
  readonly ALL: "ALL";
  readonly ALTER: "ALTER";
  readonly ASSOCIATE: "ASSOCIATE";
  readonly CREATE_DATABASE: "CREATE_DATABASE";
  readonly CREATE_LF_TAG: "CREATE_LF_TAG";
  readonly CREATE_TABLE: "CREATE_TABLE";
  readonly DATA_LOCATION_ACCESS: "DATA_LOCATION_ACCESS";
  readonly DELETE: "DELETE";
  readonly DESCRIBE: "DESCRIBE";
  readonly DROP: "DROP";
  readonly GRANT_WITH_LF_TAG_EXPRESSION: "GRANT_WITH_LF_TAG_EXPRESSION";
  readonly INSERT: "INSERT";
  readonly SELECT: "SELECT";
};
export type Permission = (typeof Permission)[keyof typeof Permission];
export interface DataLakePrincipal {
  DataLakePrincipalIdentifier?: string;
}
export interface BatchPermissionsRequestEntry {
  Id: string | undefined;
  Principal?: DataLakePrincipal;
  Resource?: Resource;
  Permissions?: Permission[];
  PermissionsWithGrantOption?: Permission[];
}
export interface BatchGrantPermissionsRequest {
  CatalogId?: string;
  Entries: BatchPermissionsRequestEntry[] | undefined;
}
export interface BatchPermissionsFailureEntry {
  RequestEntry?: BatchPermissionsRequestEntry;
  Error?: ErrorDetail;
}
export interface BatchGrantPermissionsResponse {
  Failures?: BatchPermissionsFailureEntry[];
}
export interface BatchRevokePermissionsRequest {
  CatalogId?: string;
  Entries: BatchPermissionsRequestEntry[] | undefined;
}
export interface BatchRevokePermissionsResponse {
  Failures?: BatchPermissionsFailureEntry[];
}
export interface CancelTransactionRequest {
  TransactionId: string | undefined;
}
export interface CancelTransactionResponse {}
export declare class TransactionCommitInProgressException extends __BaseException {
  readonly name: "TransactionCommitInProgressException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      TransactionCommitInProgressException,
      __BaseException
    >
  );
}
export declare class TransactionCommittedException extends __BaseException {
  readonly name: "TransactionCommittedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TransactionCommittedException, __BaseException>
  );
}
export interface CommitTransactionRequest {
  TransactionId: string | undefined;
}
export declare const TransactionStatus: {
  readonly ABORTED: "ABORTED";
  readonly ACTIVE: "ACTIVE";
  readonly COMMITTED: "COMMITTED";
  readonly COMMIT_IN_PROGRESS: "COMMIT_IN_PROGRESS";
};
export type TransactionStatus =
  (typeof TransactionStatus)[keyof typeof TransactionStatus];
export interface CommitTransactionResponse {
  TransactionStatus?: TransactionStatus;
}
export declare class TransactionCanceledException extends __BaseException {
  readonly name: "TransactionCanceledException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TransactionCanceledException, __BaseException>
  );
}
export interface RowFilter {
  FilterExpression?: string;
  AllRowsWildcard?: AllRowsWildcard;
}
export interface DataCellsFilter {
  TableCatalogId: string | undefined;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  Name: string | undefined;
  RowFilter?: RowFilter;
  ColumnNames?: string[];
  ColumnWildcard?: ColumnWildcard;
  VersionId?: string;
}
export interface CreateDataCellsFilterRequest {
  TableData: DataCellsFilter | undefined;
}
export interface CreateDataCellsFilterResponse {}
export declare class ResourceNumberLimitExceededException extends __BaseException {
  readonly name: "ResourceNumberLimitExceededException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      ResourceNumberLimitExceededException,
      __BaseException
    >
  );
}
export declare const EnableStatus: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type EnableStatus = (typeof EnableStatus)[keyof typeof EnableStatus];
export interface ExternalFilteringConfiguration {
  Status: EnableStatus | undefined;
  AuthorizedTargets: string[] | undefined;
}
export interface CreateLakeFormationIdentityCenterConfigurationRequest {
  CatalogId?: string;
  InstanceArn?: string;
  ExternalFiltering?: ExternalFilteringConfiguration;
  ShareRecipients?: DataLakePrincipal[];
}
export interface CreateLakeFormationIdentityCenterConfigurationResponse {
  ApplicationArn?: string;
}
export interface CreateLakeFormationOptInRequest {
  Principal: DataLakePrincipal | undefined;
  Resource: Resource | undefined;
}
export interface CreateLakeFormationOptInResponse {}
export interface CreateLFTagRequest {
  CatalogId?: string;
  TagKey: string | undefined;
  TagValues: string[] | undefined;
}
export interface CreateLFTagResponse {}
export interface DeleteDataCellsFilterRequest {
  TableCatalogId?: string;
  DatabaseName?: string;
  TableName?: string;
  Name?: string;
}
export interface DeleteDataCellsFilterResponse {}
export interface DeleteLakeFormationIdentityCenterConfigurationRequest {
  CatalogId?: string;
}
export interface DeleteLakeFormationIdentityCenterConfigurationResponse {}
export interface DeleteLakeFormationOptInRequest {
  Principal: DataLakePrincipal | undefined;
  Resource: Resource | undefined;
}
export interface DeleteLakeFormationOptInResponse {}
export interface DeleteLFTagRequest {
  CatalogId?: string;
  TagKey: string | undefined;
}
export interface DeleteLFTagResponse {}
export interface VirtualObject {
  Uri: string | undefined;
  ETag?: string;
}
export interface DeleteObjectsOnCancelRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  TransactionId: string | undefined;
  Objects: VirtualObject[] | undefined;
}
export interface DeleteObjectsOnCancelResponse {}
export declare class ResourceNotReadyException extends __BaseException {
  readonly name: "ResourceNotReadyException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceNotReadyException, __BaseException>
  );
}
export interface DeregisterResourceRequest {
  ResourceArn: string | undefined;
}
export interface DeregisterResourceResponse {}
export interface DescribeLakeFormationIdentityCenterConfigurationRequest {
  CatalogId?: string;
}
export interface DescribeLakeFormationIdentityCenterConfigurationResponse {
  CatalogId?: string;
  InstanceArn?: string;
  ApplicationArn?: string;
  ExternalFiltering?: ExternalFilteringConfiguration;
  ShareRecipients?: DataLakePrincipal[];
  ResourceShare?: string;
}
export interface DescribeResourceRequest {
  ResourceArn: string | undefined;
}
export interface ResourceInfo {
  ResourceArn?: string;
  RoleArn?: string;
  LastModified?: Date;
  WithFederation?: boolean;
  HybridAccessEnabled?: boolean;
}
export interface DescribeResourceResponse {
  ResourceInfo?: ResourceInfo;
}
export interface DescribeTransactionRequest {
  TransactionId: string | undefined;
}
export interface TransactionDescription {
  TransactionId?: string;
  TransactionStatus?: TransactionStatus;
  TransactionStartTime?: Date;
  TransactionEndTime?: Date;
}
export interface DescribeTransactionResponse {
  TransactionDescription?: TransactionDescription;
}
export interface ExtendTransactionRequest {
  TransactionId?: string;
}
export interface ExtendTransactionResponse {}
export interface GetDataCellsFilterRequest {
  TableCatalogId: string | undefined;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  Name: string | undefined;
}
export interface GetDataCellsFilterResponse {
  DataCellsFilter?: DataCellsFilter;
}
export interface GetDataLakeSettingsRequest {
  CatalogId?: string;
}
export interface PrincipalPermissions {
  Principal?: DataLakePrincipal;
  Permissions?: Permission[];
}
export interface DataLakeSettings {
  DataLakeAdmins?: DataLakePrincipal[];
  ReadOnlyAdmins?: DataLakePrincipal[];
  CreateDatabaseDefaultPermissions?: PrincipalPermissions[];
  CreateTableDefaultPermissions?: PrincipalPermissions[];
  Parameters?: Record<string, string>;
  TrustedResourceOwners?: string[];
  AllowExternalDataFiltering?: boolean;
  AllowFullTableExternalDataAccess?: boolean;
  ExternalDataFilteringAllowList?: DataLakePrincipal[];
  AuthorizedSessionTagValueList?: string[];
}
export interface GetDataLakeSettingsResponse {
  DataLakeSettings?: DataLakeSettings;
}
export interface GetEffectivePermissionsForPathRequest {
  CatalogId?: string;
  ResourceArn: string | undefined;
  NextToken?: string;
  MaxResults?: number;
}
export interface DetailsMap {
  ResourceShare?: string[];
}
export interface PrincipalResourcePermissions {
  Principal?: DataLakePrincipal;
  Resource?: Resource;
  Permissions?: Permission[];
  PermissionsWithGrantOption?: Permission[];
  AdditionalDetails?: DetailsMap;
  LastUpdated?: Date;
  LastUpdatedBy?: string;
}
export interface GetEffectivePermissionsForPathResponse {
  Permissions?: PrincipalResourcePermissions[];
  NextToken?: string;
}
export interface GetLFTagRequest {
  CatalogId?: string;
  TagKey: string | undefined;
}
export interface GetLFTagResponse {
  CatalogId?: string;
  TagKey?: string;
  TagValues?: string[];
}
export interface GetQueryStateRequest {
  QueryId: string | undefined;
}
export declare const QueryStateString: {
  readonly ERROR: "ERROR";
  readonly EXPIRED: "EXPIRED";
  readonly FINISHED: "FINISHED";
  readonly PENDING: "PENDING";
  readonly WORKUNITS_AVAILABLE: "WORKUNITS_AVAILABLE";
};
export type QueryStateString =
  (typeof QueryStateString)[keyof typeof QueryStateString];
export interface GetQueryStateResponse {
  Error?: string;
  State: QueryStateString | undefined;
}
export declare class ExpiredException extends __BaseException {
  readonly name: "ExpiredException";
  readonly $fault: "client";
  Message?: string;
  constructor(opts: __ExceptionOptionType<ExpiredException, __BaseException>);
}
export interface GetQueryStatisticsRequest {
  QueryId: string | undefined;
}
export interface ExecutionStatistics {
  AverageExecutionTimeMillis?: number;
  DataScannedBytes?: number;
  WorkUnitsExecutedCount?: number;
}
export interface PlanningStatistics {
  EstimatedDataToScanBytes?: number;
  PlanningTimeMillis?: number;
  QueueTimeMillis?: number;
  WorkUnitsGeneratedCount?: number;
}
export interface GetQueryStatisticsResponse {
  ExecutionStatistics?: ExecutionStatistics;
  PlanningStatistics?: PlanningStatistics;
  QuerySubmissionTime?: Date;
}
export declare class StatisticsNotReadyYetException extends __BaseException {
  readonly name: "StatisticsNotReadyYetException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<StatisticsNotReadyYetException, __BaseException>
  );
}
export declare class ThrottledException extends __BaseException {
  readonly name: "ThrottledException";
  readonly $fault: "client";
  $retryable: {
    throttling: boolean;
  };
  Message?: string;
  constructor(opts: __ExceptionOptionType<ThrottledException, __BaseException>);
}
export interface GetResourceLFTagsRequest {
  CatalogId?: string;
  Resource: Resource | undefined;
  ShowAssignedLFTags?: boolean;
}
export interface ColumnLFTag {
  Name?: string;
  LFTags?: LFTagPair[];
}
export interface GetResourceLFTagsResponse {
  LFTagOnDatabase?: LFTagPair[];
  LFTagsOnTable?: LFTagPair[];
  LFTagsOnColumns?: ColumnLFTag[];
}
export declare class GlueEncryptionException extends __BaseException {
  readonly name: "GlueEncryptionException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<GlueEncryptionException, __BaseException>
  );
}
export interface GetTableObjectsRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  TransactionId?: string;
  QueryAsOfTime?: Date;
  PartitionPredicate?: string;
  MaxResults?: number;
  NextToken?: string;
}
export interface TableObject {
  Uri?: string;
  ETag?: string;
  Size?: number;
}
export interface PartitionObjects {
  PartitionValues?: string[];
  Objects?: TableObject[];
}
export interface GetTableObjectsResponse {
  Objects?: PartitionObjects[];
  NextToken?: string;
}
export interface PartitionValueList {
  Values: string[] | undefined;
}
export declare const PermissionType: {
  readonly CELL_FILTER_PERMISSION: "CELL_FILTER_PERMISSION";
  readonly COLUMN_PERMISSION: "COLUMN_PERMISSION";
  readonly NESTED_CELL_PERMISSION: "NESTED_CELL_PERMISSION";
  readonly NESTED_PERMISSION: "NESTED_PERMISSION";
};
export type PermissionType =
  (typeof PermissionType)[keyof typeof PermissionType];
export interface GetTemporaryGluePartitionCredentialsRequest {
  TableArn: string | undefined;
  Partition: PartitionValueList | undefined;
  Permissions?: Permission[];
  DurationSeconds?: number;
  AuditContext?: AuditContext;
  SupportedPermissionTypes?: PermissionType[];
}
export interface GetTemporaryGluePartitionCredentialsResponse {
  AccessKeyId?: string;
  SecretAccessKey?: string;
  SessionToken?: string;
  Expiration?: Date;
}
export declare class PermissionTypeMismatchException extends __BaseException {
  readonly name: "PermissionTypeMismatchException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      PermissionTypeMismatchException,
      __BaseException
    >
  );
}
export interface QuerySessionContext {
  QueryId?: string;
  QueryStartTime?: Date;
  ClusterId?: string;
  QueryAuthorizationId?: string;
  AdditionalContext?: Record<string, string>;
}
export interface GetTemporaryGlueTableCredentialsRequest {
  TableArn: string | undefined;
  Permissions?: Permission[];
  DurationSeconds?: number;
  AuditContext?: AuditContext;
  SupportedPermissionTypes?: PermissionType[];
  S3Path?: string;
  QuerySessionContext?: QuerySessionContext;
}
export interface GetTemporaryGlueTableCredentialsResponse {
  AccessKeyId?: string;
  SecretAccessKey?: string;
  SessionToken?: string;
  Expiration?: Date;
  VendedS3Path?: string[];
}
export interface GetWorkUnitResultsRequest {
  QueryId: string | undefined;
  WorkUnitId: number | undefined;
  WorkUnitToken: string | undefined;
}
export interface GetWorkUnitResultsResponse {
  ResultStream?: StreamingBlobTypes;
}
export interface GetWorkUnitsRequest {
  NextToken?: string;
  PageSize?: number;
  QueryId: string | undefined;
}
export interface WorkUnitRange {
  WorkUnitIdMax: number | undefined;
  WorkUnitIdMin: number | undefined;
  WorkUnitToken: string | undefined;
}
export interface GetWorkUnitsResponse {
  NextToken?: string;
  QueryId: string | undefined;
  WorkUnitRanges: WorkUnitRange[] | undefined;
}
export declare class WorkUnitsNotReadyYetException extends __BaseException {
  readonly name: "WorkUnitsNotReadyYetException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<WorkUnitsNotReadyYetException, __BaseException>
  );
}
export interface GrantPermissionsRequest {
  CatalogId?: string;
  Principal: DataLakePrincipal | undefined;
  Resource: Resource | undefined;
  Permissions: Permission[] | undefined;
  PermissionsWithGrantOption?: Permission[];
}
export interface GrantPermissionsResponse {}
export interface ListDataCellsFilterRequest {
  Table?: TableResource;
  NextToken?: string;
  MaxResults?: number;
}
export interface ListDataCellsFilterResponse {
  DataCellsFilters?: DataCellsFilter[];
  NextToken?: string;
}
export interface ListLakeFormationOptInsRequest {
  Principal?: DataLakePrincipal;
  Resource?: Resource;
  MaxResults?: number;
  NextToken?: string;
}
export interface LakeFormationOptInsInfo {
  Resource?: Resource;
  Principal?: DataLakePrincipal;
  LastModified?: Date;
  LastUpdatedBy?: string;
}
export interface ListLakeFormationOptInsResponse {
  LakeFormationOptInsInfoList?: LakeFormationOptInsInfo[];
  NextToken?: string;
}
export declare const ResourceShareType: {
  readonly ALL: "ALL";
  readonly FOREIGN: "FOREIGN";
};
export type ResourceShareType =
  (typeof ResourceShareType)[keyof typeof ResourceShareType];
export interface ListLFTagsRequest {
  CatalogId?: string;
  ResourceShareType?: ResourceShareType;
  MaxResults?: number;
  NextToken?: string;
}
export interface ListLFTagsResponse {
  LFTags?: LFTagPair[];
  NextToken?: string;
}
export declare const DataLakeResourceType: {
  readonly CATALOG: "CATALOG";
  readonly DATABASE: "DATABASE";
  readonly DATA_LOCATION: "DATA_LOCATION";
  readonly LF_TAG: "LF_TAG";
  readonly LF_TAG_POLICY: "LF_TAG_POLICY";
  readonly LF_TAG_POLICY_DATABASE: "LF_TAG_POLICY_DATABASE";
  readonly LF_TAG_POLICY_TABLE: "LF_TAG_POLICY_TABLE";
  readonly TABLE: "TABLE";
};
export type DataLakeResourceType =
  (typeof DataLakeResourceType)[keyof typeof DataLakeResourceType];
export interface ListPermissionsRequest {
  CatalogId?: string;
  Principal?: DataLakePrincipal;
  ResourceType?: DataLakeResourceType;
  Resource?: Resource;
  NextToken?: string;
  MaxResults?: number;
  IncludeRelated?: string;
}
export interface ListPermissionsResponse {
  PrincipalResourcePermissions?: PrincipalResourcePermissions[];
  NextToken?: string;
}
export declare const ComparisonOperator: {
  readonly BEGINS_WITH: "BEGINS_WITH";
  readonly BETWEEN: "BETWEEN";
  readonly CONTAINS: "CONTAINS";
  readonly EQ: "EQ";
  readonly GE: "GE";
  readonly GT: "GT";
  readonly IN: "IN";
  readonly LE: "LE";
  readonly LT: "LT";
  readonly NE: "NE";
  readonly NOT_CONTAINS: "NOT_CONTAINS";
};
export type ComparisonOperator =
  (typeof ComparisonOperator)[keyof typeof ComparisonOperator];
export declare const FieldNameString: {
  readonly LAST_MODIFIED: "LAST_MODIFIED";
  readonly RESOURCE_ARN: "RESOURCE_ARN";
  readonly ROLE_ARN: "ROLE_ARN";
};
export type FieldNameString =
  (typeof FieldNameString)[keyof typeof FieldNameString];
export interface FilterCondition {
  Field?: FieldNameString;
  ComparisonOperator?: ComparisonOperator;
  StringValueList?: string[];
}
export interface ListResourcesRequest {
  FilterConditionList?: FilterCondition[];
  MaxResults?: number;
  NextToken?: string;
}
export interface ListResourcesResponse {
  ResourceInfoList?: ResourceInfo[];
  NextToken?: string;
}
export declare const OptimizerType: {
  readonly COMPACTION: "COMPACTION";
  readonly GARBAGE_COLLECTION: "GARBAGE_COLLECTION";
  readonly GENERIC: "ALL";
};
export type OptimizerType = (typeof OptimizerType)[keyof typeof OptimizerType];
export interface ListTableStorageOptimizersRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  StorageOptimizerType?: OptimizerType;
  MaxResults?: number;
  NextToken?: string;
}
export interface StorageOptimizer {
  StorageOptimizerType?: OptimizerType;
  Config?: Record<string, string>;
  ErrorMessage?: string;
  Warnings?: string;
  LastRunDetails?: string;
}
export interface ListTableStorageOptimizersResponse {
  StorageOptimizerList?: StorageOptimizer[];
  NextToken?: string;
}
export declare const TransactionStatusFilter: {
  readonly ABORTED: "ABORTED";
  readonly ACTIVE: "ACTIVE";
  readonly ALL: "ALL";
  readonly COMMITTED: "COMMITTED";
  readonly COMPLETED: "COMPLETED";
};
export type TransactionStatusFilter =
  (typeof TransactionStatusFilter)[keyof typeof TransactionStatusFilter];
export interface ListTransactionsRequest {
  CatalogId?: string;
  StatusFilter?: TransactionStatusFilter;
  MaxResults?: number;
  NextToken?: string;
}
export interface ListTransactionsResponse {
  Transactions?: TransactionDescription[];
  NextToken?: string;
}
export interface PutDataLakeSettingsRequest {
  CatalogId?: string;
  DataLakeSettings: DataLakeSettings | undefined;
}
export interface PutDataLakeSettingsResponse {}
export interface RegisterResourceRequest {
  ResourceArn: string | undefined;
  UseServiceLinkedRole?: boolean;
  RoleArn?: string;
  WithFederation?: boolean;
  HybridAccessEnabled?: boolean;
}
export interface RegisterResourceResponse {}
export interface RemoveLFTagsFromResourceRequest {
  CatalogId?: string;
  Resource: Resource | undefined;
  LFTags: LFTagPair[] | undefined;
}
export interface RemoveLFTagsFromResourceResponse {
  Failures?: LFTagError[];
}
export interface RevokePermissionsRequest {
  CatalogId?: string;
  Principal: DataLakePrincipal | undefined;
  Resource: Resource | undefined;
  Permissions: Permission[] | undefined;
  PermissionsWithGrantOption?: Permission[];
}
export interface RevokePermissionsResponse {}
export interface SearchDatabasesByLFTagsRequest {
  NextToken?: string;
  MaxResults?: number;
  CatalogId?: string;
  Expression: LFTag[] | undefined;
}
export interface TaggedDatabase {
  Database?: DatabaseResource;
  LFTags?: LFTagPair[];
}
export interface SearchDatabasesByLFTagsResponse {
  NextToken?: string;
  DatabaseList?: TaggedDatabase[];
}
export interface SearchTablesByLFTagsRequest {
  NextToken?: string;
  MaxResults?: number;
  CatalogId?: string;
  Expression: LFTag[] | undefined;
}
export interface TaggedTable {
  Table?: TableResource;
  LFTagOnDatabase?: LFTagPair[];
  LFTagsOnTable?: LFTagPair[];
  LFTagsOnColumns?: ColumnLFTag[];
}
export interface SearchTablesByLFTagsResponse {
  NextToken?: string;
  TableList?: TaggedTable[];
}
export interface QueryPlanningContext {
  CatalogId?: string;
  DatabaseName: string | undefined;
  QueryAsOfTime?: Date;
  QueryParameters?: Record<string, string>;
  TransactionId?: string;
}
export interface StartQueryPlanningRequest {
  QueryPlanningContext: QueryPlanningContext | undefined;
  QueryString: string | undefined;
}
export interface StartQueryPlanningResponse {
  QueryId: string | undefined;
}
export declare const TransactionType: {
  readonly READ_AND_WRITE: "READ_AND_WRITE";
  readonly READ_ONLY: "READ_ONLY";
};
export type TransactionType =
  (typeof TransactionType)[keyof typeof TransactionType];
export interface StartTransactionRequest {
  TransactionType?: TransactionType;
}
export interface StartTransactionResponse {
  TransactionId?: string;
}
export interface UpdateDataCellsFilterRequest {
  TableData: DataCellsFilter | undefined;
}
export interface UpdateDataCellsFilterResponse {}
export interface UpdateLakeFormationIdentityCenterConfigurationRequest {
  CatalogId?: string;
  ShareRecipients?: DataLakePrincipal[];
  ApplicationStatus?: ApplicationStatus;
  ExternalFiltering?: ExternalFilteringConfiguration;
}
export interface UpdateLakeFormationIdentityCenterConfigurationResponse {}
export interface UpdateLFTagRequest {
  CatalogId?: string;
  TagKey: string | undefined;
  TagValuesToDelete?: string[];
  TagValuesToAdd?: string[];
}
export interface UpdateLFTagResponse {}
export interface UpdateResourceRequest {
  RoleArn: string | undefined;
  ResourceArn: string | undefined;
  WithFederation?: boolean;
  HybridAccessEnabled?: boolean;
}
export interface UpdateResourceResponse {}
export interface DeleteObjectInput {
  Uri: string | undefined;
  ETag?: string;
  PartitionValues?: string[];
}
export interface WriteOperation {
  AddObject?: AddObjectInput;
  DeleteObject?: DeleteObjectInput;
}
export interface UpdateTableObjectsRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  TransactionId?: string;
  WriteOperations: WriteOperation[] | undefined;
}
export interface UpdateTableObjectsResponse {}
export interface UpdateTableStorageOptimizerRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  StorageOptimizerConfig:
    | Partial<Record<OptimizerType, Record<string, string>>>
    | undefined;
}
export interface UpdateTableStorageOptimizerResponse {
  Result?: string;
}
export declare const GetWorkUnitResultsRequestFilterSensitiveLog: (
  obj: GetWorkUnitResultsRequest
) => any;
export declare const GetWorkUnitResultsResponseFilterSensitiveLog: (
  obj: GetWorkUnitResultsResponse
) => any;
export declare const StartQueryPlanningRequestFilterSensitiveLog: (
  obj: StartQueryPlanningRequest
) => any;
