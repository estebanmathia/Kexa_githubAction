import { SENSITIVE_STRING } from "@smithy/smithy-client";
import { TransferServiceException as __BaseException } from "./TransferServiceException";
export class AccessDeniedException extends __BaseException {
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
        this.Message = opts.Message;
    }
}
export const AgreementStatusType = {
    ACTIVE: "ACTIVE",
    INACTIVE: "INACTIVE",
};
export const CompressionEnum = {
    DISABLED: "DISABLED",
    ZLIB: "ZLIB",
};
export const EncryptionAlg = {
    AES128_CBC: "AES128_CBC",
    AES192_CBC: "AES192_CBC",
    AES256_CBC: "AES256_CBC",
    DES_EDE3_CBC: "DES_EDE3_CBC",
    NONE: "NONE",
};
export const MdnResponse = {
    NONE: "NONE",
    SYNC: "SYNC",
};
export const MdnSigningAlg = {
    DEFAULT: "DEFAULT",
    NONE: "NONE",
    SHA1: "SHA1",
    SHA256: "SHA256",
    SHA384: "SHA384",
    SHA512: "SHA512",
};
export const SigningAlg = {
    NONE: "NONE",
    SHA1: "SHA1",
    SHA256: "SHA256",
    SHA384: "SHA384",
    SHA512: "SHA512",
};
export const As2Transport = {
    HTTP: "HTTP",
};
export const CertificateStatusType = {
    ACTIVE: "ACTIVE",
    INACTIVE: "INACTIVE",
    PENDING_ROTATION: "PENDING_ROTATION",
};
export const CertificateType = {
    CERTIFICATE: "CERTIFICATE",
    CERTIFICATE_WITH_PRIVATE_KEY: "CERTIFICATE_WITH_PRIVATE_KEY",
};
export const CertificateUsageType = {
    ENCRYPTION: "ENCRYPTION",
    SIGNING: "SIGNING",
    TLS: "TLS",
};
export class ConflictException extends __BaseException {
    constructor(opts) {
        super({
            name: "ConflictException",
            $fault: "client",
            ...opts,
        });
        this.name = "ConflictException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ConflictException.prototype);
        this.Message = opts.Message;
    }
}
export const OverwriteExisting = {
    FALSE: "FALSE",
    TRUE: "TRUE",
};
export const MapType = {
    DIRECTORY: "DIRECTORY",
    FILE: "FILE",
};
export const HomeDirectoryType = {
    LOGICAL: "LOGICAL",
    PATH: "PATH",
};
export class InternalServiceError extends __BaseException {
    constructor(opts) {
        super({
            name: "InternalServiceError",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalServiceError";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalServiceError.prototype);
        this.Message = opts.Message;
    }
}
export class InvalidRequestException extends __BaseException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
        this.Message = opts.Message;
    }
}
export class ResourceExistsException extends __BaseException {
    constructor(opts) {
        super({
            name: "ResourceExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceExistsException.prototype);
        this.Message = opts.Message;
        this.Resource = opts.Resource;
        this.ResourceType = opts.ResourceType;
    }
}
export class ResourceNotFoundException extends __BaseException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
        this.Message = opts.Message;
        this.Resource = opts.Resource;
        this.ResourceType = opts.ResourceType;
    }
}
export class ServiceUnavailableException extends __BaseException {
    constructor(opts) {
        super({
            name: "ServiceUnavailableException",
            $fault: "server",
            ...opts,
        });
        this.name = "ServiceUnavailableException";
        this.$fault = "server";
        Object.setPrototypeOf(this, ServiceUnavailableException.prototype);
        this.Message = opts.Message;
    }
}
export class ThrottlingException extends __BaseException {
    constructor(opts) {
        super({
            name: "ThrottlingException",
            $fault: "client",
            ...opts,
        });
        this.name = "ThrottlingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ThrottlingException.prototype);
        this.RetryAfterSeconds = opts.RetryAfterSeconds;
    }
}
export const ProfileType = {
    LOCAL: "LOCAL",
    PARTNER: "PARTNER",
};
export const Domain = {
    EFS: "EFS",
    S3: "S3",
};
export const EndpointType = {
    PUBLIC: "PUBLIC",
    VPC: "VPC",
    VPC_ENDPOINT: "VPC_ENDPOINT",
};
export const SftpAuthenticationMethods = {
    PASSWORD: "PASSWORD",
    PUBLIC_KEY: "PUBLIC_KEY",
    PUBLIC_KEY_AND_PASSWORD: "PUBLIC_KEY_AND_PASSWORD",
    PUBLIC_KEY_OR_PASSWORD: "PUBLIC_KEY_OR_PASSWORD",
};
export const IdentityProviderType = {
    API_GATEWAY: "API_GATEWAY",
    AWS_DIRECTORY_SERVICE: "AWS_DIRECTORY_SERVICE",
    AWS_LAMBDA: "AWS_LAMBDA",
    SERVICE_MANAGED: "SERVICE_MANAGED",
};
export const SetStatOption = {
    DEFAULT: "DEFAULT",
    ENABLE_NO_OP: "ENABLE_NO_OP",
};
export const TlsSessionResumptionMode = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
    ENFORCED: "ENFORCED",
};
export const Protocol = {
    AS2: "AS2",
    FTP: "FTP",
    FTPS: "FTPS",
    SFTP: "SFTP",
};
export const DirectoryListingOptimization = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
export const EncryptionType = {
    PGP: "PGP",
};
export const WorkflowStepType = {
    COPY: "COPY",
    CUSTOM: "CUSTOM",
    DECRYPT: "DECRYPT",
    DELETE: "DELETE",
    TAG: "TAG",
};
export const CustomStepStatus = {
    FAILURE: "FAILURE",
    SUCCESS: "SUCCESS",
};
export const ExecutionErrorType = {
    ALREADY_EXISTS: "ALREADY_EXISTS",
    BAD_REQUEST: "BAD_REQUEST",
    CUSTOM_STEP_FAILED: "CUSTOM_STEP_FAILED",
    INTERNAL_SERVER_ERROR: "INTERNAL_SERVER_ERROR",
    NOT_FOUND: "NOT_FOUND",
    PERMISSION_DENIED: "PERMISSION_DENIED",
    THROTTLED: "THROTTLED",
    TIMEOUT: "TIMEOUT",
};
export const ExecutionStatus = {
    COMPLETED: "COMPLETED",
    EXCEPTION: "EXCEPTION",
    HANDLING_EXCEPTION: "HANDLING_EXCEPTION",
    IN_PROGRESS: "IN_PROGRESS",
};
export const SecurityPolicyProtocol = {
    FTPS: "FTPS",
    SFTP: "SFTP",
};
export const SecurityPolicyResourceType = {
    CONNECTOR: "CONNECTOR",
    SERVER: "SERVER",
};
export const State = {
    OFFLINE: "OFFLINE",
    ONLINE: "ONLINE",
    STARTING: "STARTING",
    START_FAILED: "START_FAILED",
    STOPPING: "STOPPING",
    STOP_FAILED: "STOP_FAILED",
};
export class InvalidNextTokenException extends __BaseException {
    constructor(opts) {
        super({
            name: "InvalidNextTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidNextTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidNextTokenException.prototype);
        this.Message = opts.Message;
    }
}
export const CreateServerRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.HostKey && { HostKey: SENSITIVE_STRING }),
});
export const DescribedCertificateFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Certificate && { Certificate: SENSITIVE_STRING }),
    ...(obj.CertificateChain && { CertificateChain: SENSITIVE_STRING }),
});
export const DescribeCertificateResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Certificate && { Certificate: DescribedCertificateFilterSensitiveLog(obj.Certificate) }),
});
export const ImportCertificateRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Certificate && { Certificate: SENSITIVE_STRING }),
    ...(obj.CertificateChain && { CertificateChain: SENSITIVE_STRING }),
    ...(obj.PrivateKey && { PrivateKey: SENSITIVE_STRING }),
});
export const ImportHostKeyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.HostKeyBody && { HostKeyBody: SENSITIVE_STRING }),
});
export const TestIdentityProviderRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.UserPassword && { UserPassword: SENSITIVE_STRING }),
});
export const UpdateServerRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.HostKey && { HostKey: SENSITIVE_STRING }),
});
