import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { HttpRequest as __HttpRequest, isValidHostname as __isValidHostname, } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectString as __expectString, limitedParseDouble as __limitedParseDouble, parseEpochTimestamp as __parseEpochTimestamp, take, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { DataSyncServiceException as __BaseException } from "../models/DataSyncServiceException";
import { InternalException, InvalidRequestException, } from "../models/models_0";
export const se_AddStorageSystemCommand = async (input, context) => {
    const headers = sharedHeaders("AddStorageSystem");
    let body;
    body = JSON.stringify(se_AddStorageSystemRequest(input, context));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_CancelTaskExecutionCommand = async (input, context) => {
    const headers = sharedHeaders("CancelTaskExecution");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAgentCommand = async (input, context) => {
    const headers = sharedHeaders("CreateAgent");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationAzureBlobCommand = async (input, context) => {
    const headers = sharedHeaders("CreateLocationAzureBlob");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationEfsCommand = async (input, context) => {
    const headers = sharedHeaders("CreateLocationEfs");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationFsxLustreCommand = async (input, context) => {
    const headers = sharedHeaders("CreateLocationFsxLustre");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationFsxOntapCommand = async (input, context) => {
    const headers = sharedHeaders("CreateLocationFsxOntap");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationFsxOpenZfsCommand = async (input, context) => {
    const headers = sharedHeaders("CreateLocationFsxOpenZfs");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationFsxWindowsCommand = async (input, context) => {
    const headers = sharedHeaders("CreateLocationFsxWindows");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationHdfsCommand = async (input, context) => {
    const headers = sharedHeaders("CreateLocationHdfs");
    let body;
    body = JSON.stringify(se_CreateLocationHdfsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationNfsCommand = async (input, context) => {
    const headers = sharedHeaders("CreateLocationNfs");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationObjectStorageCommand = async (input, context) => {
    const headers = sharedHeaders("CreateLocationObjectStorage");
    let body;
    body = JSON.stringify(se_CreateLocationObjectStorageRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationS3Command = async (input, context) => {
    const headers = sharedHeaders("CreateLocationS3");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocationSmbCommand = async (input, context) => {
    const headers = sharedHeaders("CreateLocationSmb");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTaskCommand = async (input, context) => {
    const headers = sharedHeaders("CreateTask");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAgentCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteAgent");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLocationCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteLocation");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTaskCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteTask");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAgentCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeAgent");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDiscoveryJobCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeDiscoveryJob");
    let body;
    body = JSON.stringify(_json(input));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_DescribeLocationAzureBlobCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationAzureBlob");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocationEfsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationEfs");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocationFsxLustreCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationFsxLustre");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocationFsxOntapCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationFsxOntap");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocationFsxOpenZfsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationFsxOpenZfs");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocationFsxWindowsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationFsxWindows");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocationHdfsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationHdfs");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocationNfsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationNfs");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocationObjectStorageCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationObjectStorage");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocationS3Command = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationS3");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocationSmbCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeLocationSmb");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeStorageSystemCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeStorageSystem");
    let body;
    body = JSON.stringify(_json(input));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_DescribeStorageSystemResourceMetricsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeStorageSystemResourceMetrics");
    let body;
    body = JSON.stringify(se_DescribeStorageSystemResourceMetricsRequest(input, context));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_DescribeStorageSystemResourcesCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeStorageSystemResources");
    let body;
    body = JSON.stringify(_json(input));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_DescribeTaskCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeTask");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTaskExecutionCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeTaskExecution");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GenerateRecommendationsCommand = async (input, context) => {
    const headers = sharedHeaders("GenerateRecommendations");
    let body;
    body = JSON.stringify(_json(input));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_ListAgentsCommand = async (input, context) => {
    const headers = sharedHeaders("ListAgents");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListDiscoveryJobsCommand = async (input, context) => {
    const headers = sharedHeaders("ListDiscoveryJobs");
    let body;
    body = JSON.stringify(_json(input));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_ListLocationsCommand = async (input, context) => {
    const headers = sharedHeaders("ListLocations");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListStorageSystemsCommand = async (input, context) => {
    const headers = sharedHeaders("ListStorageSystems");
    let body;
    body = JSON.stringify(_json(input));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = sharedHeaders("ListTagsForResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTaskExecutionsCommand = async (input, context) => {
    const headers = sharedHeaders("ListTaskExecutions");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTasksCommand = async (input, context) => {
    const headers = sharedHeaders("ListTasks");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveStorageSystemCommand = async (input, context) => {
    const headers = sharedHeaders("RemoveStorageSystem");
    let body;
    body = JSON.stringify(_json(input));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_StartDiscoveryJobCommand = async (input, context) => {
    const headers = sharedHeaders("StartDiscoveryJob");
    let body;
    body = JSON.stringify(se_StartDiscoveryJobRequest(input, context));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_StartTaskExecutionCommand = async (input, context) => {
    const headers = sharedHeaders("StartTaskExecution");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StopDiscoveryJobCommand = async (input, context) => {
    const headers = sharedHeaders("StopDiscoveryJob");
    let body;
    body = JSON.stringify(_json(input));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_TagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateAgentCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateAgent");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateDiscoveryJobCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateDiscoveryJob");
    let body;
    body = JSON.stringify(_json(input));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_UpdateLocationAzureBlobCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateLocationAzureBlob");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateLocationHdfsCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateLocationHdfs");
    let body;
    body = JSON.stringify(se_UpdateLocationHdfsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateLocationNfsCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateLocationNfs");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateLocationObjectStorageCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateLocationObjectStorage");
    let body;
    body = JSON.stringify(se_UpdateLocationObjectStorageRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateLocationSmbCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateLocationSmb");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateStorageSystemCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateStorageSystem");
    let body;
    body = JSON.stringify(_json(input));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "discovery-" + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return buildHttpRpcRequest(context, headers, "/", resolvedHostname, body);
};
export const se_UpdateTaskCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateTask");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateTaskExecutionCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateTaskExecution");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AddStorageSystemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelTaskExecutionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateAgentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationAzureBlobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationEfsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationFsxLustreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationFsxOntapCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationFsxOpenZfsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationFsxWindowsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationHdfsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationNfsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationObjectStorageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationS3Command = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocationSmbCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteAgentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLocationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAgentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAgentResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDiscoveryJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDiscoveryJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationAzureBlobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationAzureBlobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationEfsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationEfsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationFsxLustreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationFsxLustreResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationFsxOntapCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationFsxOntapResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationFsxOpenZfsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationFsxOpenZfsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationFsxWindowsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationFsxWindowsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationHdfsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationHdfsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationNfsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationNfsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationObjectStorageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationObjectStorageResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationS3Command = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationS3Response(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocationSmbCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocationSmbResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeStorageSystemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeStorageSystemResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeStorageSystemResourceMetricsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeStorageSystemResourceMetricsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeStorageSystemResourcesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeStorageSystemResourcesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTaskResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTaskExecutionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTaskExecutionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GenerateRecommendationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListAgentsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListDiscoveryJobsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListLocationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListStorageSystemsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListTaskExecutionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RemoveStorageSystemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StartDiscoveryJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StartTaskExecutionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StopDiscoveryJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateAgentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateDiscoveryJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateLocationAzureBlobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateLocationHdfsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateLocationNfsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateLocationObjectStorageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateLocationSmbCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateStorageSystemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateTaskExecutionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.datasync#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.datasync#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_InternalExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InternalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AddStorageSystemRequest = (input, context) => {
    return take(input, {
        AgentArns: _json,
        ClientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        CloudWatchLogGroupArn: [],
        Credentials: _json,
        Name: [],
        ServerConfiguration: _json,
        SystemType: [],
        Tags: _json,
    });
};
const se_CreateLocationHdfsRequest = (input, context) => {
    return take(input, {
        AgentArns: _json,
        AuthenticationType: [],
        BlockSize: [],
        KerberosKeytab: context.base64Encoder,
        KerberosKrb5Conf: context.base64Encoder,
        KerberosPrincipal: [],
        KmsKeyProviderUri: [],
        NameNodes: _json,
        QopConfiguration: _json,
        ReplicationFactor: [],
        SimpleUser: [],
        Subdirectory: [],
        Tags: _json,
    });
};
const se_CreateLocationObjectStorageRequest = (input, context) => {
    return take(input, {
        AccessKey: [],
        AgentArns: _json,
        BucketName: [],
        SecretKey: [],
        ServerCertificate: context.base64Encoder,
        ServerHostname: [],
        ServerPort: [],
        ServerProtocol: [],
        Subdirectory: [],
        Tags: _json,
    });
};
const se_DescribeStorageSystemResourceMetricsRequest = (input, context) => {
    return take(input, {
        DiscoveryJobArn: [],
        EndTime: (_) => Math.round(_.getTime() / 1000),
        MaxResults: [],
        NextToken: [],
        ResourceId: [],
        ResourceType: [],
        StartTime: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_StartDiscoveryJobRequest = (input, context) => {
    return take(input, {
        ClientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        CollectionDurationMinutes: [],
        StorageSystemArn: [],
        Tags: _json,
    });
};
const se_UpdateLocationHdfsRequest = (input, context) => {
    return take(input, {
        AgentArns: _json,
        AuthenticationType: [],
        BlockSize: [],
        KerberosKeytab: context.base64Encoder,
        KerberosKrb5Conf: context.base64Encoder,
        KerberosPrincipal: [],
        KmsKeyProviderUri: [],
        LocationArn: [],
        NameNodes: _json,
        QopConfiguration: _json,
        ReplicationFactor: [],
        SimpleUser: [],
        Subdirectory: [],
    });
};
const se_UpdateLocationObjectStorageRequest = (input, context) => {
    return take(input, {
        AccessKey: [],
        AgentArns: _json,
        LocationArn: [],
        SecretKey: [],
        ServerCertificate: context.base64Encoder,
        ServerPort: [],
        ServerProtocol: [],
        Subdirectory: [],
    });
};
const de_DescribeAgentResponse = (output, context) => {
    return take(output, {
        AgentArn: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        EndpointType: __expectString,
        LastConnectionTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Name: __expectString,
        Platform: _json,
        PrivateLinkConfig: _json,
        Status: __expectString,
    });
};
const de_DescribeDiscoveryJobResponse = (output, context) => {
    return take(output, {
        CollectionDurationMinutes: __expectInt32,
        DiscoveryJobArn: __expectString,
        JobEndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        JobStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Status: __expectString,
        StorageSystemArn: __expectString,
    });
};
const de_DescribeLocationAzureBlobResponse = (output, context) => {
    return take(output, {
        AccessTier: __expectString,
        AgentArns: _json,
        AuthenticationType: __expectString,
        BlobType: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        LocationArn: __expectString,
        LocationUri: __expectString,
    });
};
const de_DescribeLocationEfsResponse = (output, context) => {
    return take(output, {
        AccessPointArn: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Ec2Config: _json,
        FileSystemAccessRoleArn: __expectString,
        InTransitEncryption: __expectString,
        LocationArn: __expectString,
        LocationUri: __expectString,
    });
};
const de_DescribeLocationFsxLustreResponse = (output, context) => {
    return take(output, {
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        LocationArn: __expectString,
        LocationUri: __expectString,
        SecurityGroupArns: _json,
    });
};
const de_DescribeLocationFsxOntapResponse = (output, context) => {
    return take(output, {
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        FsxFilesystemArn: __expectString,
        LocationArn: __expectString,
        LocationUri: __expectString,
        Protocol: _json,
        SecurityGroupArns: _json,
        StorageVirtualMachineArn: __expectString,
    });
};
const de_DescribeLocationFsxOpenZfsResponse = (output, context) => {
    return take(output, {
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        LocationArn: __expectString,
        LocationUri: __expectString,
        Protocol: _json,
        SecurityGroupArns: _json,
    });
};
const de_DescribeLocationFsxWindowsResponse = (output, context) => {
    return take(output, {
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Domain: __expectString,
        LocationArn: __expectString,
        LocationUri: __expectString,
        SecurityGroupArns: _json,
        User: __expectString,
    });
};
const de_DescribeLocationHdfsResponse = (output, context) => {
    return take(output, {
        AgentArns: _json,
        AuthenticationType: __expectString,
        BlockSize: __expectInt32,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        KerberosPrincipal: __expectString,
        KmsKeyProviderUri: __expectString,
        LocationArn: __expectString,
        LocationUri: __expectString,
        NameNodes: _json,
        QopConfiguration: _json,
        ReplicationFactor: __expectInt32,
        SimpleUser: __expectString,
    });
};
const de_DescribeLocationNfsResponse = (output, context) => {
    return take(output, {
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        LocationArn: __expectString,
        LocationUri: __expectString,
        MountOptions: _json,
        OnPremConfig: _json,
    });
};
const de_DescribeLocationObjectStorageResponse = (output, context) => {
    return take(output, {
        AccessKey: __expectString,
        AgentArns: _json,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        LocationArn: __expectString,
        LocationUri: __expectString,
        ServerCertificate: context.base64Decoder,
        ServerPort: __expectInt32,
        ServerProtocol: __expectString,
    });
};
const de_DescribeLocationS3Response = (output, context) => {
    return take(output, {
        AgentArns: _json,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        LocationArn: __expectString,
        LocationUri: __expectString,
        S3Config: _json,
        S3StorageClass: __expectString,
    });
};
const de_DescribeLocationSmbResponse = (output, context) => {
    return take(output, {
        AgentArns: _json,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Domain: __expectString,
        LocationArn: __expectString,
        LocationUri: __expectString,
        MountOptions: _json,
        User: __expectString,
    });
};
const de_DescribeStorageSystemResourceMetricsResponse = (output, context) => {
    return take(output, {
        Metrics: (_) => de_Metrics(_, context),
        NextToken: __expectString,
    });
};
const de_DescribeStorageSystemResourcesResponse = (output, context) => {
    return take(output, {
        NextToken: __expectString,
        ResourceDetails: (_) => de_ResourceDetails(_, context),
    });
};
const de_DescribeStorageSystemResponse = (output, context) => {
    return take(output, {
        AgentArns: _json,
        CloudWatchLogGroupArn: __expectString,
        ConnectivityStatus: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ErrorMessage: __expectString,
        Name: __expectString,
        SecretsManagerArn: __expectString,
        ServerConfiguration: _json,
        StorageSystemArn: __expectString,
        SystemType: __expectString,
    });
};
const de_DescribeTaskExecutionResponse = (output, context) => {
    return take(output, {
        BytesCompressed: __expectLong,
        BytesTransferred: __expectLong,
        BytesWritten: __expectLong,
        EstimatedBytesToTransfer: __expectLong,
        EstimatedFilesToDelete: __expectLong,
        EstimatedFilesToTransfer: __expectLong,
        Excludes: _json,
        FilesDeleted: __expectLong,
        FilesSkipped: __expectLong,
        FilesTransferred: __expectLong,
        FilesVerified: __expectLong,
        Includes: _json,
        ManifestConfig: _json,
        Options: _json,
        ReportResult: _json,
        Result: _json,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Status: __expectString,
        TaskExecutionArn: __expectString,
        TaskReportConfig: _json,
    });
};
const de_DescribeTaskResponse = (output, context) => {
    return take(output, {
        CloudWatchLogGroupArn: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        CurrentTaskExecutionArn: __expectString,
        DestinationLocationArn: __expectString,
        DestinationNetworkInterfaceArns: _json,
        ErrorCode: __expectString,
        ErrorDetail: __expectString,
        Excludes: _json,
        Includes: _json,
        ManifestConfig: _json,
        Name: __expectString,
        Options: _json,
        Schedule: _json,
        ScheduleDetails: (_) => de_TaskScheduleDetails(_, context),
        SourceLocationArn: __expectString,
        SourceNetworkInterfaceArns: _json,
        Status: __expectString,
        TaskArn: __expectString,
        TaskReportConfig: _json,
    });
};
const de_IOPS = (output, context) => {
    return take(output, {
        Other: __limitedParseDouble,
        Read: __limitedParseDouble,
        Total: __limitedParseDouble,
        Write: __limitedParseDouble,
    });
};
const de_Latency = (output, context) => {
    return take(output, {
        Other: __limitedParseDouble,
        Read: __limitedParseDouble,
        Write: __limitedParseDouble,
    });
};
const de_MaxP95Performance = (output, context) => {
    return take(output, {
        IopsOther: __limitedParseDouble,
        IopsRead: __limitedParseDouble,
        IopsTotal: __limitedParseDouble,
        IopsWrite: __limitedParseDouble,
        LatencyOther: __limitedParseDouble,
        LatencyRead: __limitedParseDouble,
        LatencyWrite: __limitedParseDouble,
        ThroughputOther: __limitedParseDouble,
        ThroughputRead: __limitedParseDouble,
        ThroughputTotal: __limitedParseDouble,
        ThroughputWrite: __limitedParseDouble,
    });
};
const de_Metrics = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResourceMetrics(entry, context);
    });
    return retVal;
};
const de_NetAppONTAPCluster = (output, context) => {
    return take(output, {
        CifsShareCount: __expectLong,
        ClusterBlockStorageLogicalUsed: __expectLong,
        ClusterBlockStorageSize: __expectLong,
        ClusterBlockStorageUsed: __expectLong,
        ClusterCloudStorageUsed: __expectLong,
        ClusterName: __expectString,
        LunCount: __expectLong,
        MaxP95Performance: (_) => de_MaxP95Performance(_, context),
        NfsExportedVolumes: __expectLong,
        RecommendationStatus: __expectString,
        Recommendations: _json,
        ResourceId: __expectString,
    });
};
const de_NetAppONTAPClusters = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetAppONTAPCluster(entry, context);
    });
    return retVal;
};
const de_NetAppONTAPSVM = (output, context) => {
    return take(output, {
        CifsShareCount: __expectLong,
        ClusterUuid: __expectString,
        EnabledProtocols: _json,
        LunCount: __expectLong,
        MaxP95Performance: (_) => de_MaxP95Performance(_, context),
        NfsExportedVolumes: __expectLong,
        RecommendationStatus: __expectString,
        Recommendations: _json,
        ResourceId: __expectString,
        SvmName: __expectString,
        TotalCapacityProvisioned: __expectLong,
        TotalCapacityUsed: __expectLong,
        TotalLogicalCapacityUsed: __expectLong,
        TotalSnapshotCapacityUsed: __expectLong,
    });
};
const de_NetAppONTAPSVMs = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetAppONTAPSVM(entry, context);
    });
    return retVal;
};
const de_NetAppONTAPVolume = (output, context) => {
    return take(output, {
        CapacityProvisioned: __expectLong,
        CapacityUsed: __expectLong,
        CifsShareCount: __expectLong,
        LogicalCapacityUsed: __expectLong,
        LunCount: __expectLong,
        MaxP95Performance: (_) => de_MaxP95Performance(_, context),
        NfsExported: __expectBoolean,
        RecommendationStatus: __expectString,
        Recommendations: _json,
        ResourceId: __expectString,
        SecurityStyle: __expectString,
        SnapshotCapacityUsed: __expectLong,
        SvmName: __expectString,
        SvmUuid: __expectString,
        VolumeName: __expectString,
    });
};
const de_NetAppONTAPVolumes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetAppONTAPVolume(entry, context);
    });
    return retVal;
};
const de_P95Metrics = (output, context) => {
    return take(output, {
        IOPS: (_) => de_IOPS(_, context),
        Latency: (_) => de_Latency(_, context),
        Throughput: (_) => de_Throughput(_, context),
    });
};
const de_ResourceDetails = (output, context) => {
    return take(output, {
        NetAppONTAPClusters: (_) => de_NetAppONTAPClusters(_, context),
        NetAppONTAPSVMs: (_) => de_NetAppONTAPSVMs(_, context),
        NetAppONTAPVolumes: (_) => de_NetAppONTAPVolumes(_, context),
    });
};
const de_ResourceMetrics = (output, context) => {
    return take(output, {
        Capacity: _json,
        P95Metrics: (_) => de_P95Metrics(_, context),
        ResourceId: __expectString,
        ResourceType: __expectString,
        Timestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_TaskScheduleDetails = (output, context) => {
    return take(output, {
        DisabledBy: __expectString,
        DisabledReason: __expectString,
        StatusUpdateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_Throughput = (output, context) => {
    return take(output, {
        Other: __limitedParseDouble,
        Read: __limitedParseDouble,
        Total: __limitedParseDouble,
        Write: __limitedParseDouble,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `FmrsService.${operation}`,
    };
}
