import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { MediaLiveServiceException as __BaseException } from "./MediaLiveServiceException";
import {
  ArchiveGroupSettings,
  AudioDescription,
  BatchFailedResultModel,
  BatchSuccessfulResultModel,
  CaptionDescription,
  CaptionLanguageMapping,
  CdiInputSpecification,
  ChannelClass,
  ChannelEgressEndpoint,
  ChannelState,
  CloudWatchAlarmTemplateComparisonOperator,
  CloudWatchAlarmTemplateStatistic,
  CloudWatchAlarmTemplateTargetResourceType,
  CloudWatchAlarmTemplateTreatMissingData,
  CmafNielsenId3Behavior,
  ColorCorrection,
  EventBridgeRuleTemplateEventType,
  EventBridgeRuleTemplateTarget,
  Hdr10Settings,
  HlsAdMarkers,
  Input,
  InputAttachment,
  InputDestinationRequest,
  InputDeviceSettings,
  InputLocation,
  InputSecurityGroup,
  InputSourceRequest,
  InputSpecification,
  InputType,
  InputWhitelistRuleCidr,
  LogLevel,
  MaintenanceDay,
  MaintenanceStatus,
  MediaConnectFlowRequest,
  MediaResourceNeighbor,
  MultiplexOutputDestination,
  MultiplexProgramPipelineDetail,
  MultiplexState,
  OfferingDurationUnits,
  OfferingType,
  Output,
  OutputDestination,
  OutputLocationRef,
  ReservationResourceSpecification,
  S3CannedAcl,
  VpcOutputSettingsDescription,
} from "./models_0";
export declare const Scte35Type: {
  readonly NONE: "NONE";
  readonly SCTE_35_WITHOUT_SEGMENTATION: "SCTE_35_WITHOUT_SEGMENTATION";
};
export type Scte35Type = (typeof Scte35Type)[keyof typeof Scte35Type];
export declare const CmafIngestSegmentLengthUnits: {
  readonly MILLISECONDS: "MILLISECONDS";
  readonly SECONDS: "SECONDS";
};
export type CmafIngestSegmentLengthUnits =
  (typeof CmafIngestSegmentLengthUnits)[keyof typeof CmafIngestSegmentLengthUnits];
export interface CmafIngestGroupSettings {
  Destination: OutputLocationRef | undefined;
  NielsenId3Behavior?: CmafNielsenId3Behavior;
  Scte35Type?: Scte35Type;
  SegmentLength?: number;
  SegmentLengthUnits?: CmafIngestSegmentLengthUnits;
  SendDelayMs?: number;
}
export interface FrameCaptureS3Settings {
  CannedAcl?: S3CannedAcl;
}
export interface FrameCaptureCdnSettings {
  FrameCaptureS3Settings?: FrameCaptureS3Settings;
}
export interface FrameCaptureGroupSettings {
  Destination: OutputLocationRef | undefined;
  FrameCaptureCdnSettings?: FrameCaptureCdnSettings;
}
export declare const HlsCaptionLanguageSetting: {
  readonly INSERT: "INSERT";
  readonly NONE: "NONE";
  readonly OMIT: "OMIT";
};
export type HlsCaptionLanguageSetting =
  (typeof HlsCaptionLanguageSetting)[keyof typeof HlsCaptionLanguageSetting];
export declare const HlsClientCache: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type HlsClientCache =
  (typeof HlsClientCache)[keyof typeof HlsClientCache];
export declare const HlsCodecSpecification: {
  readonly RFC_4281: "RFC_4281";
  readonly RFC_6381: "RFC_6381";
};
export type HlsCodecSpecification =
  (typeof HlsCodecSpecification)[keyof typeof HlsCodecSpecification];
export declare const HlsDirectoryStructure: {
  readonly SINGLE_DIRECTORY: "SINGLE_DIRECTORY";
  readonly SUBDIRECTORY_PER_STREAM: "SUBDIRECTORY_PER_STREAM";
};
export type HlsDirectoryStructure =
  (typeof HlsDirectoryStructure)[keyof typeof HlsDirectoryStructure];
export declare const HlsDiscontinuityTags: {
  readonly INSERT: "INSERT";
  readonly NEVER_INSERT: "NEVER_INSERT";
};
export type HlsDiscontinuityTags =
  (typeof HlsDiscontinuityTags)[keyof typeof HlsDiscontinuityTags];
export declare const HlsEncryptionType: {
  readonly AES128: "AES128";
  readonly SAMPLE_AES: "SAMPLE_AES";
};
export type HlsEncryptionType =
  (typeof HlsEncryptionType)[keyof typeof HlsEncryptionType];
export declare const HlsAkamaiHttpTransferMode: {
  readonly CHUNKED: "CHUNKED";
  readonly NON_CHUNKED: "NON_CHUNKED";
};
export type HlsAkamaiHttpTransferMode =
  (typeof HlsAkamaiHttpTransferMode)[keyof typeof HlsAkamaiHttpTransferMode];
export interface HlsAkamaiSettings {
  ConnectionRetryInterval?: number;
  FilecacheDuration?: number;
  HttpTransferMode?: HlsAkamaiHttpTransferMode;
  NumRetries?: number;
  RestartDelay?: number;
  Salt?: string;
  Token?: string;
}
export interface HlsBasicPutSettings {
  ConnectionRetryInterval?: number;
  FilecacheDuration?: number;
  NumRetries?: number;
  RestartDelay?: number;
}
export declare const HlsMediaStoreStorageClass: {
  readonly TEMPORAL: "TEMPORAL";
};
export type HlsMediaStoreStorageClass =
  (typeof HlsMediaStoreStorageClass)[keyof typeof HlsMediaStoreStorageClass];
export interface HlsMediaStoreSettings {
  ConnectionRetryInterval?: number;
  FilecacheDuration?: number;
  MediaStoreStorageClass?: HlsMediaStoreStorageClass;
  NumRetries?: number;
  RestartDelay?: number;
}
export interface HlsS3Settings {
  CannedAcl?: S3CannedAcl;
}
export declare const HlsWebdavHttpTransferMode: {
  readonly CHUNKED: "CHUNKED";
  readonly NON_CHUNKED: "NON_CHUNKED";
};
export type HlsWebdavHttpTransferMode =
  (typeof HlsWebdavHttpTransferMode)[keyof typeof HlsWebdavHttpTransferMode];
export interface HlsWebdavSettings {
  ConnectionRetryInterval?: number;
  FilecacheDuration?: number;
  HttpTransferMode?: HlsWebdavHttpTransferMode;
  NumRetries?: number;
  RestartDelay?: number;
}
export interface HlsCdnSettings {
  HlsAkamaiSettings?: HlsAkamaiSettings;
  HlsBasicPutSettings?: HlsBasicPutSettings;
  HlsMediaStoreSettings?: HlsMediaStoreSettings;
  HlsS3Settings?: HlsS3Settings;
  HlsWebdavSettings?: HlsWebdavSettings;
}
export declare const HlsId3SegmentTaggingState: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type HlsId3SegmentTaggingState =
  (typeof HlsId3SegmentTaggingState)[keyof typeof HlsId3SegmentTaggingState];
export declare const IFrameOnlyPlaylistType: {
  readonly DISABLED: "DISABLED";
  readonly STANDARD: "STANDARD";
};
export type IFrameOnlyPlaylistType =
  (typeof IFrameOnlyPlaylistType)[keyof typeof IFrameOnlyPlaylistType];
export declare const HlsIncompleteSegmentBehavior: {
  readonly AUTO: "AUTO";
  readonly SUPPRESS: "SUPPRESS";
};
export type HlsIncompleteSegmentBehavior =
  (typeof HlsIncompleteSegmentBehavior)[keyof typeof HlsIncompleteSegmentBehavior];
export declare const InputLossActionForHlsOut: {
  readonly EMIT_OUTPUT: "EMIT_OUTPUT";
  readonly PAUSE_OUTPUT: "PAUSE_OUTPUT";
};
export type InputLossActionForHlsOut =
  (typeof InputLossActionForHlsOut)[keyof typeof InputLossActionForHlsOut];
export declare const HlsIvInManifest: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type HlsIvInManifest =
  (typeof HlsIvInManifest)[keyof typeof HlsIvInManifest];
export declare const HlsIvSource: {
  readonly EXPLICIT: "EXPLICIT";
  readonly FOLLOWS_SEGMENT_NUMBER: "FOLLOWS_SEGMENT_NUMBER";
};
export type HlsIvSource = (typeof HlsIvSource)[keyof typeof HlsIvSource];
export interface StaticKeySettings {
  KeyProviderServer?: InputLocation;
  StaticKeyValue: string | undefined;
}
export interface KeyProviderSettings {
  StaticKeySettings?: StaticKeySettings;
}
export declare const HlsManifestCompression: {
  readonly GZIP: "GZIP";
  readonly NONE: "NONE";
};
export type HlsManifestCompression =
  (typeof HlsManifestCompression)[keyof typeof HlsManifestCompression];
export declare const HlsManifestDurationFormat: {
  readonly FLOATING_POINT: "FLOATING_POINT";
  readonly INTEGER: "INTEGER";
};
export type HlsManifestDurationFormat =
  (typeof HlsManifestDurationFormat)[keyof typeof HlsManifestDurationFormat];
export declare const HlsMode: {
  readonly LIVE: "LIVE";
  readonly VOD: "VOD";
};
export type HlsMode = (typeof HlsMode)[keyof typeof HlsMode];
export declare const HlsOutputSelection: {
  readonly MANIFESTS_AND_SEGMENTS: "MANIFESTS_AND_SEGMENTS";
  readonly SEGMENTS_ONLY: "SEGMENTS_ONLY";
  readonly VARIANT_MANIFESTS_AND_SEGMENTS: "VARIANT_MANIFESTS_AND_SEGMENTS";
};
export type HlsOutputSelection =
  (typeof HlsOutputSelection)[keyof typeof HlsOutputSelection];
export declare const HlsProgramDateTime: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type HlsProgramDateTime =
  (typeof HlsProgramDateTime)[keyof typeof HlsProgramDateTime];
export declare const HlsProgramDateTimeClock: {
  readonly INITIALIZE_FROM_OUTPUT_TIMECODE: "INITIALIZE_FROM_OUTPUT_TIMECODE";
  readonly SYSTEM_CLOCK: "SYSTEM_CLOCK";
};
export type HlsProgramDateTimeClock =
  (typeof HlsProgramDateTimeClock)[keyof typeof HlsProgramDateTimeClock];
export declare const HlsRedundantManifest: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type HlsRedundantManifest =
  (typeof HlsRedundantManifest)[keyof typeof HlsRedundantManifest];
export declare const HlsSegmentationMode: {
  readonly USE_INPUT_SEGMENTATION: "USE_INPUT_SEGMENTATION";
  readonly USE_SEGMENT_DURATION: "USE_SEGMENT_DURATION";
};
export type HlsSegmentationMode =
  (typeof HlsSegmentationMode)[keyof typeof HlsSegmentationMode];
export declare const HlsStreamInfResolution: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type HlsStreamInfResolution =
  (typeof HlsStreamInfResolution)[keyof typeof HlsStreamInfResolution];
export declare const HlsTimedMetadataId3Frame: {
  readonly NONE: "NONE";
  readonly PRIV: "PRIV";
  readonly TDRL: "TDRL";
};
export type HlsTimedMetadataId3Frame =
  (typeof HlsTimedMetadataId3Frame)[keyof typeof HlsTimedMetadataId3Frame];
export declare const HlsTsFileMode: {
  readonly SEGMENTED_FILES: "SEGMENTED_FILES";
  readonly SINGLE_FILE: "SINGLE_FILE";
};
export type HlsTsFileMode = (typeof HlsTsFileMode)[keyof typeof HlsTsFileMode];
export interface HlsGroupSettings {
  AdMarkers?: HlsAdMarkers[];
  BaseUrlContent?: string;
  BaseUrlContent1?: string;
  BaseUrlManifest?: string;
  BaseUrlManifest1?: string;
  CaptionLanguageMappings?: CaptionLanguageMapping[];
  CaptionLanguageSetting?: HlsCaptionLanguageSetting;
  ClientCache?: HlsClientCache;
  CodecSpecification?: HlsCodecSpecification;
  ConstantIv?: string;
  Destination: OutputLocationRef | undefined;
  DirectoryStructure?: HlsDirectoryStructure;
  DiscontinuityTags?: HlsDiscontinuityTags;
  EncryptionType?: HlsEncryptionType;
  HlsCdnSettings?: HlsCdnSettings;
  HlsId3SegmentTagging?: HlsId3SegmentTaggingState;
  IFrameOnlyPlaylists?: IFrameOnlyPlaylistType;
  IncompleteSegmentBehavior?: HlsIncompleteSegmentBehavior;
  IndexNSegments?: number;
  InputLossAction?: InputLossActionForHlsOut;
  IvInManifest?: HlsIvInManifest;
  IvSource?: HlsIvSource;
  KeepSegments?: number;
  KeyFormat?: string;
  KeyFormatVersions?: string;
  KeyProviderSettings?: KeyProviderSettings;
  ManifestCompression?: HlsManifestCompression;
  ManifestDurationFormat?: HlsManifestDurationFormat;
  MinSegmentLength?: number;
  Mode?: HlsMode;
  OutputSelection?: HlsOutputSelection;
  ProgramDateTime?: HlsProgramDateTime;
  ProgramDateTimeClock?: HlsProgramDateTimeClock;
  ProgramDateTimePeriod?: number;
  RedundantManifest?: HlsRedundantManifest;
  SegmentLength?: number;
  SegmentationMode?: HlsSegmentationMode;
  SegmentsPerSubdirectory?: number;
  StreamInfResolution?: HlsStreamInfResolution;
  TimedMetadataId3Frame?: HlsTimedMetadataId3Frame;
  TimedMetadataId3Period?: number;
  TimestampDeltaMilliseconds?: number;
  TsFileMode?: HlsTsFileMode;
}
export interface MediaPackageGroupSettings {
  Destination: OutputLocationRef | undefined;
}
export declare const SmoothGroupAudioOnlyTimecodeControl: {
  readonly PASSTHROUGH: "PASSTHROUGH";
  readonly USE_CONFIGURED_CLOCK: "USE_CONFIGURED_CLOCK";
};
export type SmoothGroupAudioOnlyTimecodeControl =
  (typeof SmoothGroupAudioOnlyTimecodeControl)[keyof typeof SmoothGroupAudioOnlyTimecodeControl];
export declare const SmoothGroupCertificateMode: {
  readonly SELF_SIGNED: "SELF_SIGNED";
  readonly VERIFY_AUTHENTICITY: "VERIFY_AUTHENTICITY";
};
export type SmoothGroupCertificateMode =
  (typeof SmoothGroupCertificateMode)[keyof typeof SmoothGroupCertificateMode];
export declare const SmoothGroupEventIdMode: {
  readonly NO_EVENT_ID: "NO_EVENT_ID";
  readonly USE_CONFIGURED: "USE_CONFIGURED";
  readonly USE_TIMESTAMP: "USE_TIMESTAMP";
};
export type SmoothGroupEventIdMode =
  (typeof SmoothGroupEventIdMode)[keyof typeof SmoothGroupEventIdMode];
export declare const SmoothGroupEventStopBehavior: {
  readonly NONE: "NONE";
  readonly SEND_EOS: "SEND_EOS";
};
export type SmoothGroupEventStopBehavior =
  (typeof SmoothGroupEventStopBehavior)[keyof typeof SmoothGroupEventStopBehavior];
export declare const InputLossActionForMsSmoothOut: {
  readonly EMIT_OUTPUT: "EMIT_OUTPUT";
  readonly PAUSE_OUTPUT: "PAUSE_OUTPUT";
};
export type InputLossActionForMsSmoothOut =
  (typeof InputLossActionForMsSmoothOut)[keyof typeof InputLossActionForMsSmoothOut];
export declare const SmoothGroupSegmentationMode: {
  readonly USE_INPUT_SEGMENTATION: "USE_INPUT_SEGMENTATION";
  readonly USE_SEGMENT_DURATION: "USE_SEGMENT_DURATION";
};
export type SmoothGroupSegmentationMode =
  (typeof SmoothGroupSegmentationMode)[keyof typeof SmoothGroupSegmentationMode];
export declare const SmoothGroupSparseTrackType: {
  readonly NONE: "NONE";
  readonly SCTE_35: "SCTE_35";
  readonly SCTE_35_WITHOUT_SEGMENTATION: "SCTE_35_WITHOUT_SEGMENTATION";
};
export type SmoothGroupSparseTrackType =
  (typeof SmoothGroupSparseTrackType)[keyof typeof SmoothGroupSparseTrackType];
export declare const SmoothGroupStreamManifestBehavior: {
  readonly DO_NOT_SEND: "DO_NOT_SEND";
  readonly SEND: "SEND";
};
export type SmoothGroupStreamManifestBehavior =
  (typeof SmoothGroupStreamManifestBehavior)[keyof typeof SmoothGroupStreamManifestBehavior];
export declare const SmoothGroupTimestampOffsetMode: {
  readonly USE_CONFIGURED_OFFSET: "USE_CONFIGURED_OFFSET";
  readonly USE_EVENT_START_DATE: "USE_EVENT_START_DATE";
};
export type SmoothGroupTimestampOffsetMode =
  (typeof SmoothGroupTimestampOffsetMode)[keyof typeof SmoothGroupTimestampOffsetMode];
export interface MsSmoothGroupSettings {
  AcquisitionPointId?: string;
  AudioOnlyTimecodeControl?: SmoothGroupAudioOnlyTimecodeControl;
  CertificateMode?: SmoothGroupCertificateMode;
  ConnectionRetryInterval?: number;
  Destination: OutputLocationRef | undefined;
  EventId?: string;
  EventIdMode?: SmoothGroupEventIdMode;
  EventStopBehavior?: SmoothGroupEventStopBehavior;
  FilecacheDuration?: number;
  FragmentLength?: number;
  InputLossAction?: InputLossActionForMsSmoothOut;
  NumRetries?: number;
  RestartDelay?: number;
  SegmentationMode?: SmoothGroupSegmentationMode;
  SendDelayMs?: number;
  SparseTrackType?: SmoothGroupSparseTrackType;
  StreamManifestBehavior?: SmoothGroupStreamManifestBehavior;
  TimestampOffset?: string;
  TimestampOffsetMode?: SmoothGroupTimestampOffsetMode;
}
export interface MultiplexGroupSettings {}
export declare const RtmpAdMarkers: {
  readonly ON_CUE_POINT_SCTE35: "ON_CUE_POINT_SCTE35";
};
export type RtmpAdMarkers = (typeof RtmpAdMarkers)[keyof typeof RtmpAdMarkers];
export declare const AuthenticationScheme: {
  readonly AKAMAI: "AKAMAI";
  readonly COMMON: "COMMON";
};
export type AuthenticationScheme =
  (typeof AuthenticationScheme)[keyof typeof AuthenticationScheme];
export declare const RtmpCacheFullBehavior: {
  readonly DISCONNECT_IMMEDIATELY: "DISCONNECT_IMMEDIATELY";
  readonly WAIT_FOR_SERVER: "WAIT_FOR_SERVER";
};
export type RtmpCacheFullBehavior =
  (typeof RtmpCacheFullBehavior)[keyof typeof RtmpCacheFullBehavior];
export declare const RtmpCaptionData: {
  readonly ALL: "ALL";
  readonly FIELD1_608: "FIELD1_608";
  readonly FIELD1_AND_FIELD2_608: "FIELD1_AND_FIELD2_608";
};
export type RtmpCaptionData =
  (typeof RtmpCaptionData)[keyof typeof RtmpCaptionData];
export declare const IncludeFillerNalUnits: {
  readonly AUTO: "AUTO";
  readonly DROP: "DROP";
  readonly INCLUDE: "INCLUDE";
};
export type IncludeFillerNalUnits =
  (typeof IncludeFillerNalUnits)[keyof typeof IncludeFillerNalUnits];
export declare const InputLossActionForRtmpOut: {
  readonly EMIT_OUTPUT: "EMIT_OUTPUT";
  readonly PAUSE_OUTPUT: "PAUSE_OUTPUT";
};
export type InputLossActionForRtmpOut =
  (typeof InputLossActionForRtmpOut)[keyof typeof InputLossActionForRtmpOut];
export interface RtmpGroupSettings {
  AdMarkers?: RtmpAdMarkers[];
  AuthenticationScheme?: AuthenticationScheme;
  CacheFullBehavior?: RtmpCacheFullBehavior;
  CacheLength?: number;
  CaptionData?: RtmpCaptionData;
  InputLossAction?: InputLossActionForRtmpOut;
  RestartDelay?: number;
  IncludeFillerNalUnits?: IncludeFillerNalUnits;
}
export declare const InputLossActionForUdpOut: {
  readonly DROP_PROGRAM: "DROP_PROGRAM";
  readonly DROP_TS: "DROP_TS";
  readonly EMIT_PROGRAM: "EMIT_PROGRAM";
};
export type InputLossActionForUdpOut =
  (typeof InputLossActionForUdpOut)[keyof typeof InputLossActionForUdpOut];
export declare const UdpTimedMetadataId3Frame: {
  readonly NONE: "NONE";
  readonly PRIV: "PRIV";
  readonly TDRL: "TDRL";
};
export type UdpTimedMetadataId3Frame =
  (typeof UdpTimedMetadataId3Frame)[keyof typeof UdpTimedMetadataId3Frame];
export interface UdpGroupSettings {
  InputLossAction?: InputLossActionForUdpOut;
  TimedMetadataId3Frame?: UdpTimedMetadataId3Frame;
  TimedMetadataId3Period?: number;
}
export interface OutputGroupSettings {
  ArchiveGroupSettings?: ArchiveGroupSettings;
  FrameCaptureGroupSettings?: FrameCaptureGroupSettings;
  HlsGroupSettings?: HlsGroupSettings;
  MediaPackageGroupSettings?: MediaPackageGroupSettings;
  MsSmoothGroupSettings?: MsSmoothGroupSettings;
  MultiplexGroupSettings?: MultiplexGroupSettings;
  RtmpGroupSettings?: RtmpGroupSettings;
  UdpGroupSettings?: UdpGroupSettings;
  CmafIngestGroupSettings?: CmafIngestGroupSettings;
}
export interface OutputGroup {
  Name?: string;
  OutputGroupSettings: OutputGroupSettings | undefined;
  Outputs: Output[] | undefined;
}
export interface PipelineDetail {
  ActiveInputAttachmentName?: string;
  ActiveInputSwitchActionName?: string;
  ActiveMotionGraphicsActionName?: string;
  ActiveMotionGraphicsUri?: string;
  PipelineId?: string;
}
export declare const PipelineId: {
  readonly PIPELINE_0: "PIPELINE_0";
  readonly PIPELINE_1: "PIPELINE_1";
};
export type PipelineId = (typeof PipelineId)[keyof typeof PipelineId];
export interface PipelinePauseStateSettings {
  PipelineId: PipelineId | undefined;
}
export declare const ReservationAutomaticRenewal: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
  readonly UNAVAILABLE: "UNAVAILABLE";
};
export type ReservationAutomaticRenewal =
  (typeof ReservationAutomaticRenewal)[keyof typeof ReservationAutomaticRenewal];
export interface RenewalSettings {
  AutomaticRenewal?: ReservationAutomaticRenewal;
  RenewalCount?: number;
}
export declare const ReservationState: {
  readonly ACTIVE: "ACTIVE";
  readonly CANCELED: "CANCELED";
  readonly DELETED: "DELETED";
  readonly EXPIRED: "EXPIRED";
};
export type ReservationState =
  (typeof ReservationState)[keyof typeof ReservationState];
export interface Reservation {
  Arn?: string;
  Count?: number;
  CurrencyCode?: string;
  Duration?: number;
  DurationUnits?: OfferingDurationUnits;
  End?: string;
  FixedPrice?: number;
  Name?: string;
  OfferingDescription?: string;
  OfferingId?: string;
  OfferingType?: OfferingType;
  Region?: string;
  RenewalSettings?: RenewalSettings;
  ReservationId?: string;
  ResourceSpecification?: ReservationResourceSpecification;
  Start?: string;
  State?: ReservationState;
  Tags?: Record<string, string>;
  UsagePrice?: number;
}
export interface HlsId3SegmentTaggingScheduleActionSettings {
  Tag?: string;
  Id3?: string;
}
export interface HlsTimedMetadataScheduleActionSettings {
  Id3: string | undefined;
}
export declare const InputTimecodeSource: {
  readonly EMBEDDED: "EMBEDDED";
  readonly ZEROBASED: "ZEROBASED";
};
export type InputTimecodeSource =
  (typeof InputTimecodeSource)[keyof typeof InputTimecodeSource];
export interface StartTimecode {
  Timecode?: string;
}
export declare const LastFrameClippingBehavior: {
  readonly EXCLUDE_LAST_FRAME: "EXCLUDE_LAST_FRAME";
  readonly INCLUDE_LAST_FRAME: "INCLUDE_LAST_FRAME";
};
export type LastFrameClippingBehavior =
  (typeof LastFrameClippingBehavior)[keyof typeof LastFrameClippingBehavior];
export interface StopTimecode {
  LastFrameClippingBehavior?: LastFrameClippingBehavior;
  Timecode?: string;
}
export interface InputClippingSettings {
  InputTimecodeSource: InputTimecodeSource | undefined;
  StartTimecode?: StartTimecode;
  StopTimecode?: StopTimecode;
}
export interface InputPrepareScheduleActionSettings {
  InputAttachmentNameReference?: string;
  InputClippingSettings?: InputClippingSettings;
  UrlPath?: string[];
}
export interface InputSwitchScheduleActionSettings {
  InputAttachmentNameReference: string | undefined;
  InputClippingSettings?: InputClippingSettings;
  UrlPath?: string[];
}
export interface MotionGraphicsActivateScheduleActionSettings {
  Duration?: number;
  PasswordParam?: string;
  Url?: string;
  Username?: string;
}
export interface MotionGraphicsDeactivateScheduleActionSettings {}
export interface PauseStateScheduleActionSettings {
  Pipelines?: PipelinePauseStateSettings[];
}
export declare const Scte35InputMode: {
  readonly FIXED: "FIXED";
  readonly FOLLOW_ACTIVE: "FOLLOW_ACTIVE";
};
export type Scte35InputMode =
  (typeof Scte35InputMode)[keyof typeof Scte35InputMode];
export interface Scte35InputScheduleActionSettings {
  InputAttachmentNameReference?: string;
  Mode: Scte35InputMode | undefined;
}
export interface Scte35ReturnToNetworkScheduleActionSettings {
  SpliceEventId: number | undefined;
}
export interface Scte35SpliceInsertScheduleActionSettings {
  Duration?: number;
  SpliceEventId: number | undefined;
}
export declare const Scte35ArchiveAllowedFlag: {
  readonly ARCHIVE_ALLOWED: "ARCHIVE_ALLOWED";
  readonly ARCHIVE_NOT_ALLOWED: "ARCHIVE_NOT_ALLOWED";
};
export type Scte35ArchiveAllowedFlag =
  (typeof Scte35ArchiveAllowedFlag)[keyof typeof Scte35ArchiveAllowedFlag];
export declare const Scte35DeviceRestrictions: {
  readonly NONE: "NONE";
  readonly RESTRICT_GROUP0: "RESTRICT_GROUP0";
  readonly RESTRICT_GROUP1: "RESTRICT_GROUP1";
  readonly RESTRICT_GROUP2: "RESTRICT_GROUP2";
};
export type Scte35DeviceRestrictions =
  (typeof Scte35DeviceRestrictions)[keyof typeof Scte35DeviceRestrictions];
export declare const Scte35NoRegionalBlackoutFlag: {
  readonly NO_REGIONAL_BLACKOUT: "NO_REGIONAL_BLACKOUT";
  readonly REGIONAL_BLACKOUT: "REGIONAL_BLACKOUT";
};
export type Scte35NoRegionalBlackoutFlag =
  (typeof Scte35NoRegionalBlackoutFlag)[keyof typeof Scte35NoRegionalBlackoutFlag];
export declare const Scte35WebDeliveryAllowedFlag: {
  readonly WEB_DELIVERY_ALLOWED: "WEB_DELIVERY_ALLOWED";
  readonly WEB_DELIVERY_NOT_ALLOWED: "WEB_DELIVERY_NOT_ALLOWED";
};
export type Scte35WebDeliveryAllowedFlag =
  (typeof Scte35WebDeliveryAllowedFlag)[keyof typeof Scte35WebDeliveryAllowedFlag];
export interface Scte35DeliveryRestrictions {
  ArchiveAllowedFlag: Scte35ArchiveAllowedFlag | undefined;
  DeviceRestrictions: Scte35DeviceRestrictions | undefined;
  NoRegionalBlackoutFlag: Scte35NoRegionalBlackoutFlag | undefined;
  WebDeliveryAllowedFlag: Scte35WebDeliveryAllowedFlag | undefined;
}
export declare const Scte35SegmentationCancelIndicator: {
  readonly SEGMENTATION_EVENT_CANCELED: "SEGMENTATION_EVENT_CANCELED";
  readonly SEGMENTATION_EVENT_NOT_CANCELED: "SEGMENTATION_EVENT_NOT_CANCELED";
};
export type Scte35SegmentationCancelIndicator =
  (typeof Scte35SegmentationCancelIndicator)[keyof typeof Scte35SegmentationCancelIndicator];
export interface Scte35SegmentationDescriptor {
  DeliveryRestrictions?: Scte35DeliveryRestrictions;
  SegmentNum?: number;
  SegmentationCancelIndicator: Scte35SegmentationCancelIndicator | undefined;
  SegmentationDuration?: number;
  SegmentationEventId: number | undefined;
  SegmentationTypeId?: number;
  SegmentationUpid?: string;
  SegmentationUpidType?: number;
  SegmentsExpected?: number;
  SubSegmentNum?: number;
  SubSegmentsExpected?: number;
}
export interface Scte35DescriptorSettings {
  SegmentationDescriptorScte35DescriptorSettings:
    | Scte35SegmentationDescriptor
    | undefined;
}
export interface Scte35Descriptor {
  Scte35DescriptorSettings: Scte35DescriptorSettings | undefined;
}
export interface Scte35TimeSignalScheduleActionSettings {
  Scte35Descriptors: Scte35Descriptor[] | undefined;
}
export interface StaticImageActivateScheduleActionSettings {
  Duration?: number;
  FadeIn?: number;
  FadeOut?: number;
  Height?: number;
  Image: InputLocation | undefined;
  ImageX?: number;
  ImageY?: number;
  Layer?: number;
  Opacity?: number;
  Width?: number;
}
export interface StaticImageDeactivateScheduleActionSettings {
  FadeOut?: number;
  Layer?: number;
}
export interface StaticImageOutputActivateScheduleActionSettings {
  Duration?: number;
  FadeIn?: number;
  FadeOut?: number;
  Height?: number;
  Image: InputLocation | undefined;
  ImageX?: number;
  ImageY?: number;
  Layer?: number;
  Opacity?: number;
  OutputNames: string[] | undefined;
  Width?: number;
}
export interface StaticImageOutputDeactivateScheduleActionSettings {
  FadeOut?: number;
  Layer?: number;
  OutputNames: string[] | undefined;
}
export interface ScheduleActionSettings {
  HlsId3SegmentTaggingSettings?: HlsId3SegmentTaggingScheduleActionSettings;
  HlsTimedMetadataSettings?: HlsTimedMetadataScheduleActionSettings;
  InputPrepareSettings?: InputPrepareScheduleActionSettings;
  InputSwitchSettings?: InputSwitchScheduleActionSettings;
  MotionGraphicsImageActivateSettings?: MotionGraphicsActivateScheduleActionSettings;
  MotionGraphicsImageDeactivateSettings?: MotionGraphicsDeactivateScheduleActionSettings;
  PauseStateSettings?: PauseStateScheduleActionSettings;
  Scte35InputSettings?: Scte35InputScheduleActionSettings;
  Scte35ReturnToNetworkSettings?: Scte35ReturnToNetworkScheduleActionSettings;
  Scte35SpliceInsertSettings?: Scte35SpliceInsertScheduleActionSettings;
  Scte35TimeSignalSettings?: Scte35TimeSignalScheduleActionSettings;
  StaticImageActivateSettings?: StaticImageActivateScheduleActionSettings;
  StaticImageDeactivateSettings?: StaticImageDeactivateScheduleActionSettings;
  StaticImageOutputActivateSettings?: StaticImageOutputActivateScheduleActionSettings;
  StaticImageOutputDeactivateSettings?: StaticImageOutputDeactivateScheduleActionSettings;
}
export interface FixedModeScheduleActionStartSettings {
  Time: string | undefined;
}
export declare const FollowPoint: {
  readonly END: "END";
  readonly START: "START";
};
export type FollowPoint = (typeof FollowPoint)[keyof typeof FollowPoint];
export interface FollowModeScheduleActionStartSettings {
  FollowPoint: FollowPoint | undefined;
  ReferenceActionName: string | undefined;
}
export interface ImmediateModeScheduleActionStartSettings {}
export interface ScheduleActionStartSettings {
  FixedModeScheduleActionStartSettings?: FixedModeScheduleActionStartSettings;
  FollowModeScheduleActionStartSettings?: FollowModeScheduleActionStartSettings;
  ImmediateModeScheduleActionStartSettings?: ImmediateModeScheduleActionStartSettings;
}
export interface ScheduleAction {
  ActionName: string | undefined;
  ScheduleActionSettings: ScheduleActionSettings | undefined;
  ScheduleActionStartSettings: ScheduleActionStartSettings | undefined;
}
export declare const SignalMapMonitorDeploymentStatus: {
  readonly DELETE_COMPLETE: "DELETE_COMPLETE";
  readonly DELETE_FAILED: "DELETE_FAILED";
  readonly DELETE_IN_PROGRESS: "DELETE_IN_PROGRESS";
  readonly DEPLOYMENT_COMPLETE: "DEPLOYMENT_COMPLETE";
  readonly DEPLOYMENT_FAILED: "DEPLOYMENT_FAILED";
  readonly DEPLOYMENT_IN_PROGRESS: "DEPLOYMENT_IN_PROGRESS";
  readonly DRY_RUN_DEPLOYMENT_COMPLETE: "DRY_RUN_DEPLOYMENT_COMPLETE";
  readonly DRY_RUN_DEPLOYMENT_FAILED: "DRY_RUN_DEPLOYMENT_FAILED";
  readonly DRY_RUN_DEPLOYMENT_IN_PROGRESS: "DRY_RUN_DEPLOYMENT_IN_PROGRESS";
  readonly NOT_DEPLOYED: "NOT_DEPLOYED";
};
export type SignalMapMonitorDeploymentStatus =
  (typeof SignalMapMonitorDeploymentStatus)[keyof typeof SignalMapMonitorDeploymentStatus];
export declare const SignalMapStatus: {
  readonly CREATE_COMPLETE: "CREATE_COMPLETE";
  readonly CREATE_FAILED: "CREATE_FAILED";
  readonly CREATE_IN_PROGRESS: "CREATE_IN_PROGRESS";
  readonly NOT_READY: "NOT_READY";
  readonly READY: "READY";
  readonly UPDATE_COMPLETE: "UPDATE_COMPLETE";
  readonly UPDATE_FAILED: "UPDATE_FAILED";
  readonly UPDATE_IN_PROGRESS: "UPDATE_IN_PROGRESS";
  readonly UPDATE_REVERTED: "UPDATE_REVERTED";
};
export type SignalMapStatus =
  (typeof SignalMapStatus)[keyof typeof SignalMapStatus];
export interface SignalMapSummary {
  Arn: string | undefined;
  CreatedAt: Date | undefined;
  Description?: string;
  Id: string | undefined;
  ModifiedAt?: Date;
  MonitorDeploymentStatus: SignalMapMonitorDeploymentStatus | undefined;
  Name: string | undefined;
  Status: SignalMapStatus | undefined;
  Tags?: Record<string, string>;
}
export declare const ThumbnailType: {
  readonly CURRENT_ACTIVE: "CURRENT_ACTIVE";
  readonly UNSPECIFIED: "UNSPECIFIED";
};
export type ThumbnailType = (typeof ThumbnailType)[keyof typeof ThumbnailType];
export interface Thumbnail {
  Body?: string;
  ContentType?: string;
  ThumbnailType?: ThumbnailType;
  TimeStamp?: Date;
}
export interface ThumbnailDetail {
  PipelineId?: string;
  Thumbnails?: Thumbnail[];
}
export declare const InputDeviceTransferType: {
  readonly INCOMING: "INCOMING";
  readonly OUTGOING: "OUTGOING";
};
export type InputDeviceTransferType =
  (typeof InputDeviceTransferType)[keyof typeof InputDeviceTransferType];
export interface TransferringInputDeviceSummary {
  Id?: string;
  Message?: string;
  TargetCustomerId?: string;
  TransferType?: InputDeviceTransferType;
}
export interface ValidationError {
  ElementPath?: string;
  ErrorMessage?: string;
}
export declare const FrameCaptureIntervalUnit: {
  readonly MILLISECONDS: "MILLISECONDS";
  readonly SECONDS: "SECONDS";
};
export type FrameCaptureIntervalUnit =
  (typeof FrameCaptureIntervalUnit)[keyof typeof FrameCaptureIntervalUnit];
export declare const TimecodeBurninFontSize: {
  readonly EXTRA_SMALL_10: "EXTRA_SMALL_10";
  readonly LARGE_48: "LARGE_48";
  readonly MEDIUM_32: "MEDIUM_32";
  readonly SMALL_16: "SMALL_16";
};
export type TimecodeBurninFontSize =
  (typeof TimecodeBurninFontSize)[keyof typeof TimecodeBurninFontSize];
export declare const TimecodeBurninPosition: {
  readonly BOTTOM_CENTER: "BOTTOM_CENTER";
  readonly BOTTOM_LEFT: "BOTTOM_LEFT";
  readonly BOTTOM_RIGHT: "BOTTOM_RIGHT";
  readonly MIDDLE_CENTER: "MIDDLE_CENTER";
  readonly MIDDLE_LEFT: "MIDDLE_LEFT";
  readonly MIDDLE_RIGHT: "MIDDLE_RIGHT";
  readonly TOP_CENTER: "TOP_CENTER";
  readonly TOP_LEFT: "TOP_LEFT";
  readonly TOP_RIGHT: "TOP_RIGHT";
};
export type TimecodeBurninPosition =
  (typeof TimecodeBurninPosition)[keyof typeof TimecodeBurninPosition];
export interface TimecodeBurninSettings {
  FontSize: TimecodeBurninFontSize | undefined;
  Position: TimecodeBurninPosition | undefined;
  Prefix?: string;
}
export interface FrameCaptureSettings {
  CaptureInterval?: number;
  CaptureIntervalUnits?: FrameCaptureIntervalUnit;
  TimecodeBurninSettings?: TimecodeBurninSettings;
}
export declare const H264AdaptiveQuantization: {
  readonly AUTO: "AUTO";
  readonly HIGH: "HIGH";
  readonly HIGHER: "HIGHER";
  readonly LOW: "LOW";
  readonly MAX: "MAX";
  readonly MEDIUM: "MEDIUM";
  readonly OFF: "OFF";
};
export type H264AdaptiveQuantization =
  (typeof H264AdaptiveQuantization)[keyof typeof H264AdaptiveQuantization];
export declare const AfdSignaling: {
  readonly AUTO: "AUTO";
  readonly FIXED: "FIXED";
  readonly NONE: "NONE";
};
export type AfdSignaling = (typeof AfdSignaling)[keyof typeof AfdSignaling];
export declare const H264ColorMetadata: {
  readonly IGNORE: "IGNORE";
  readonly INSERT: "INSERT";
};
export type H264ColorMetadata =
  (typeof H264ColorMetadata)[keyof typeof H264ColorMetadata];
export interface ColorSpacePassthroughSettings {}
export interface Rec601Settings {}
export interface Rec709Settings {}
export interface H264ColorSpaceSettings {
  ColorSpacePassthroughSettings?: ColorSpacePassthroughSettings;
  Rec601Settings?: Rec601Settings;
  Rec709Settings?: Rec709Settings;
}
export declare const H264EntropyEncoding: {
  readonly CABAC: "CABAC";
  readonly CAVLC: "CAVLC";
};
export type H264EntropyEncoding =
  (typeof H264EntropyEncoding)[keyof typeof H264EntropyEncoding];
export declare const TemporalFilterPostFilterSharpening: {
  readonly AUTO: "AUTO";
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type TemporalFilterPostFilterSharpening =
  (typeof TemporalFilterPostFilterSharpening)[keyof typeof TemporalFilterPostFilterSharpening];
export declare const TemporalFilterStrength: {
  readonly AUTO: "AUTO";
  readonly STRENGTH_1: "STRENGTH_1";
  readonly STRENGTH_10: "STRENGTH_10";
  readonly STRENGTH_11: "STRENGTH_11";
  readonly STRENGTH_12: "STRENGTH_12";
  readonly STRENGTH_13: "STRENGTH_13";
  readonly STRENGTH_14: "STRENGTH_14";
  readonly STRENGTH_15: "STRENGTH_15";
  readonly STRENGTH_16: "STRENGTH_16";
  readonly STRENGTH_2: "STRENGTH_2";
  readonly STRENGTH_3: "STRENGTH_3";
  readonly STRENGTH_4: "STRENGTH_4";
  readonly STRENGTH_5: "STRENGTH_5";
  readonly STRENGTH_6: "STRENGTH_6";
  readonly STRENGTH_7: "STRENGTH_7";
  readonly STRENGTH_8: "STRENGTH_8";
  readonly STRENGTH_9: "STRENGTH_9";
};
export type TemporalFilterStrength =
  (typeof TemporalFilterStrength)[keyof typeof TemporalFilterStrength];
export interface TemporalFilterSettings {
  PostFilterSharpening?: TemporalFilterPostFilterSharpening;
  Strength?: TemporalFilterStrength;
}
export interface H264FilterSettings {
  TemporalFilterSettings?: TemporalFilterSettings;
}
export declare const FixedAfd: {
  readonly AFD_0000: "AFD_0000";
  readonly AFD_0010: "AFD_0010";
  readonly AFD_0011: "AFD_0011";
  readonly AFD_0100: "AFD_0100";
  readonly AFD_1000: "AFD_1000";
  readonly AFD_1001: "AFD_1001";
  readonly AFD_1010: "AFD_1010";
  readonly AFD_1011: "AFD_1011";
  readonly AFD_1101: "AFD_1101";
  readonly AFD_1110: "AFD_1110";
  readonly AFD_1111: "AFD_1111";
};
export type FixedAfd = (typeof FixedAfd)[keyof typeof FixedAfd];
export declare const H264FlickerAq: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type H264FlickerAq = (typeof H264FlickerAq)[keyof typeof H264FlickerAq];
export declare const H264ForceFieldPictures: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type H264ForceFieldPictures =
  (typeof H264ForceFieldPictures)[keyof typeof H264ForceFieldPictures];
export declare const H264FramerateControl: {
  readonly INITIALIZE_FROM_SOURCE: "INITIALIZE_FROM_SOURCE";
  readonly SPECIFIED: "SPECIFIED";
};
export type H264FramerateControl =
  (typeof H264FramerateControl)[keyof typeof H264FramerateControl];
export declare const H264GopBReference: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type H264GopBReference =
  (typeof H264GopBReference)[keyof typeof H264GopBReference];
export declare const H264GopSizeUnits: {
  readonly FRAMES: "FRAMES";
  readonly SECONDS: "SECONDS";
};
export type H264GopSizeUnits =
  (typeof H264GopSizeUnits)[keyof typeof H264GopSizeUnits];
export declare const H264Level: {
  readonly H264_LEVEL_1: "H264_LEVEL_1";
  readonly H264_LEVEL_1_1: "H264_LEVEL_1_1";
  readonly H264_LEVEL_1_2: "H264_LEVEL_1_2";
  readonly H264_LEVEL_1_3: "H264_LEVEL_1_3";
  readonly H264_LEVEL_2: "H264_LEVEL_2";
  readonly H264_LEVEL_2_1: "H264_LEVEL_2_1";
  readonly H264_LEVEL_2_2: "H264_LEVEL_2_2";
  readonly H264_LEVEL_3: "H264_LEVEL_3";
  readonly H264_LEVEL_3_1: "H264_LEVEL_3_1";
  readonly H264_LEVEL_3_2: "H264_LEVEL_3_2";
  readonly H264_LEVEL_4: "H264_LEVEL_4";
  readonly H264_LEVEL_4_1: "H264_LEVEL_4_1";
  readonly H264_LEVEL_4_2: "H264_LEVEL_4_2";
  readonly H264_LEVEL_5: "H264_LEVEL_5";
  readonly H264_LEVEL_5_1: "H264_LEVEL_5_1";
  readonly H264_LEVEL_5_2: "H264_LEVEL_5_2";
  readonly H264_LEVEL_AUTO: "H264_LEVEL_AUTO";
};
export type H264Level = (typeof H264Level)[keyof typeof H264Level];
export declare const H264LookAheadRateControl: {
  readonly HIGH: "HIGH";
  readonly LOW: "LOW";
  readonly MEDIUM: "MEDIUM";
};
export type H264LookAheadRateControl =
  (typeof H264LookAheadRateControl)[keyof typeof H264LookAheadRateControl];
export declare const H264ParControl: {
  readonly INITIALIZE_FROM_SOURCE: "INITIALIZE_FROM_SOURCE";
  readonly SPECIFIED: "SPECIFIED";
};
export type H264ParControl =
  (typeof H264ParControl)[keyof typeof H264ParControl];
export declare const H264Profile: {
  readonly BASELINE: "BASELINE";
  readonly HIGH: "HIGH";
  readonly HIGH_10BIT: "HIGH_10BIT";
  readonly HIGH_422: "HIGH_422";
  readonly HIGH_422_10BIT: "HIGH_422_10BIT";
  readonly MAIN: "MAIN";
};
export type H264Profile = (typeof H264Profile)[keyof typeof H264Profile];
export declare const H264QualityLevel: {
  readonly ENHANCED_QUALITY: "ENHANCED_QUALITY";
  readonly STANDARD_QUALITY: "STANDARD_QUALITY";
};
export type H264QualityLevel =
  (typeof H264QualityLevel)[keyof typeof H264QualityLevel];
export declare const H264RateControlMode: {
  readonly CBR: "CBR";
  readonly MULTIPLEX: "MULTIPLEX";
  readonly QVBR: "QVBR";
  readonly VBR: "VBR";
};
export type H264RateControlMode =
  (typeof H264RateControlMode)[keyof typeof H264RateControlMode];
export declare const H264ScanType: {
  readonly INTERLACED: "INTERLACED";
  readonly PROGRESSIVE: "PROGRESSIVE";
};
export type H264ScanType = (typeof H264ScanType)[keyof typeof H264ScanType];
export declare const H264SceneChangeDetect: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type H264SceneChangeDetect =
  (typeof H264SceneChangeDetect)[keyof typeof H264SceneChangeDetect];
export declare const H264SpatialAq: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type H264SpatialAq = (typeof H264SpatialAq)[keyof typeof H264SpatialAq];
export declare const H264SubGopLength: {
  readonly DYNAMIC: "DYNAMIC";
  readonly FIXED: "FIXED";
};
export type H264SubGopLength =
  (typeof H264SubGopLength)[keyof typeof H264SubGopLength];
export declare const H264Syntax: {
  readonly DEFAULT: "DEFAULT";
  readonly RP2027: "RP2027";
};
export type H264Syntax = (typeof H264Syntax)[keyof typeof H264Syntax];
export declare const H264TemporalAq: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type H264TemporalAq =
  (typeof H264TemporalAq)[keyof typeof H264TemporalAq];
export declare const H264TimecodeInsertionBehavior: {
  readonly DISABLED: "DISABLED";
  readonly PIC_TIMING_SEI: "PIC_TIMING_SEI";
};
export type H264TimecodeInsertionBehavior =
  (typeof H264TimecodeInsertionBehavior)[keyof typeof H264TimecodeInsertionBehavior];
export interface H264Settings {
  AdaptiveQuantization?: H264AdaptiveQuantization;
  AfdSignaling?: AfdSignaling;
  Bitrate?: number;
  BufFillPct?: number;
  BufSize?: number;
  ColorMetadata?: H264ColorMetadata;
  ColorSpaceSettings?: H264ColorSpaceSettings;
  EntropyEncoding?: H264EntropyEncoding;
  FilterSettings?: H264FilterSettings;
  FixedAfd?: FixedAfd;
  FlickerAq?: H264FlickerAq;
  ForceFieldPictures?: H264ForceFieldPictures;
  FramerateControl?: H264FramerateControl;
  FramerateDenominator?: number;
  FramerateNumerator?: number;
  GopBReference?: H264GopBReference;
  GopClosedCadence?: number;
  GopNumBFrames?: number;
  GopSize?: number;
  GopSizeUnits?: H264GopSizeUnits;
  Level?: H264Level;
  LookAheadRateControl?: H264LookAheadRateControl;
  MaxBitrate?: number;
  MinIInterval?: number;
  NumRefFrames?: number;
  ParControl?: H264ParControl;
  ParDenominator?: number;
  ParNumerator?: number;
  Profile?: H264Profile;
  QualityLevel?: H264QualityLevel;
  QvbrQualityLevel?: number;
  RateControlMode?: H264RateControlMode;
  ScanType?: H264ScanType;
  SceneChangeDetect?: H264SceneChangeDetect;
  Slices?: number;
  Softness?: number;
  SpatialAq?: H264SpatialAq;
  SubgopLength?: H264SubGopLength;
  Syntax?: H264Syntax;
  TemporalAq?: H264TemporalAq;
  TimecodeInsertion?: H264TimecodeInsertionBehavior;
  TimecodeBurninSettings?: TimecodeBurninSettings;
}
export declare const H265AdaptiveQuantization: {
  readonly AUTO: "AUTO";
  readonly HIGH: "HIGH";
  readonly HIGHER: "HIGHER";
  readonly LOW: "LOW";
  readonly MAX: "MAX";
  readonly MEDIUM: "MEDIUM";
  readonly OFF: "OFF";
};
export type H265AdaptiveQuantization =
  (typeof H265AdaptiveQuantization)[keyof typeof H265AdaptiveQuantization];
export declare const H265AlternativeTransferFunction: {
  readonly INSERT: "INSERT";
  readonly OMIT: "OMIT";
};
export type H265AlternativeTransferFunction =
  (typeof H265AlternativeTransferFunction)[keyof typeof H265AlternativeTransferFunction];
export declare const H265ColorMetadata: {
  readonly IGNORE: "IGNORE";
  readonly INSERT: "INSERT";
};
export type H265ColorMetadata =
  (typeof H265ColorMetadata)[keyof typeof H265ColorMetadata];
export interface DolbyVision81Settings {}
export interface H265ColorSpaceSettings {
  ColorSpacePassthroughSettings?: ColorSpacePassthroughSettings;
  DolbyVision81Settings?: DolbyVision81Settings;
  Hdr10Settings?: Hdr10Settings;
  Rec601Settings?: Rec601Settings;
  Rec709Settings?: Rec709Settings;
}
export interface H265FilterSettings {
  TemporalFilterSettings?: TemporalFilterSettings;
}
export declare const H265FlickerAq: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type H265FlickerAq = (typeof H265FlickerAq)[keyof typeof H265FlickerAq];
export declare const H265GopSizeUnits: {
  readonly FRAMES: "FRAMES";
  readonly SECONDS: "SECONDS";
};
export type H265GopSizeUnits =
  (typeof H265GopSizeUnits)[keyof typeof H265GopSizeUnits];
export declare const H265Level: {
  readonly H265_LEVEL_1: "H265_LEVEL_1";
  readonly H265_LEVEL_2: "H265_LEVEL_2";
  readonly H265_LEVEL_2_1: "H265_LEVEL_2_1";
  readonly H265_LEVEL_3: "H265_LEVEL_3";
  readonly H265_LEVEL_3_1: "H265_LEVEL_3_1";
  readonly H265_LEVEL_4: "H265_LEVEL_4";
  readonly H265_LEVEL_4_1: "H265_LEVEL_4_1";
  readonly H265_LEVEL_5: "H265_LEVEL_5";
  readonly H265_LEVEL_5_1: "H265_LEVEL_5_1";
  readonly H265_LEVEL_5_2: "H265_LEVEL_5_2";
  readonly H265_LEVEL_6: "H265_LEVEL_6";
  readonly H265_LEVEL_6_1: "H265_LEVEL_6_1";
  readonly H265_LEVEL_6_2: "H265_LEVEL_6_2";
  readonly H265_LEVEL_AUTO: "H265_LEVEL_AUTO";
};
export type H265Level = (typeof H265Level)[keyof typeof H265Level];
export declare const H265LookAheadRateControl: {
  readonly HIGH: "HIGH";
  readonly LOW: "LOW";
  readonly MEDIUM: "MEDIUM";
};
export type H265LookAheadRateControl =
  (typeof H265LookAheadRateControl)[keyof typeof H265LookAheadRateControl];
export declare const H265MvOverPictureBoundaries: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type H265MvOverPictureBoundaries =
  (typeof H265MvOverPictureBoundaries)[keyof typeof H265MvOverPictureBoundaries];
export declare const H265MvTemporalPredictor: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type H265MvTemporalPredictor =
  (typeof H265MvTemporalPredictor)[keyof typeof H265MvTemporalPredictor];
export declare const H265Profile: {
  readonly MAIN: "MAIN";
  readonly MAIN_10BIT: "MAIN_10BIT";
};
export type H265Profile = (typeof H265Profile)[keyof typeof H265Profile];
export declare const H265RateControlMode: {
  readonly CBR: "CBR";
  readonly MULTIPLEX: "MULTIPLEX";
  readonly QVBR: "QVBR";
};
export type H265RateControlMode =
  (typeof H265RateControlMode)[keyof typeof H265RateControlMode];
export declare const H265ScanType: {
  readonly INTERLACED: "INTERLACED";
  readonly PROGRESSIVE: "PROGRESSIVE";
};
export type H265ScanType = (typeof H265ScanType)[keyof typeof H265ScanType];
export declare const H265SceneChangeDetect: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type H265SceneChangeDetect =
  (typeof H265SceneChangeDetect)[keyof typeof H265SceneChangeDetect];
export declare const H265Tier: {
  readonly HIGH: "HIGH";
  readonly MAIN: "MAIN";
};
export type H265Tier = (typeof H265Tier)[keyof typeof H265Tier];
export declare const H265TilePadding: {
  readonly NONE: "NONE";
  readonly PADDED: "PADDED";
};
export type H265TilePadding =
  (typeof H265TilePadding)[keyof typeof H265TilePadding];
export declare const H265TimecodeInsertionBehavior: {
  readonly DISABLED: "DISABLED";
  readonly PIC_TIMING_SEI: "PIC_TIMING_SEI";
};
export type H265TimecodeInsertionBehavior =
  (typeof H265TimecodeInsertionBehavior)[keyof typeof H265TimecodeInsertionBehavior];
export declare const H265TreeblockSize: {
  readonly AUTO: "AUTO";
  readonly TREE_SIZE_32X32: "TREE_SIZE_32X32";
};
export type H265TreeblockSize =
  (typeof H265TreeblockSize)[keyof typeof H265TreeblockSize];
export interface H265Settings {
  AdaptiveQuantization?: H265AdaptiveQuantization;
  AfdSignaling?: AfdSignaling;
  AlternativeTransferFunction?: H265AlternativeTransferFunction;
  Bitrate?: number;
  BufSize?: number;
  ColorMetadata?: H265ColorMetadata;
  ColorSpaceSettings?: H265ColorSpaceSettings;
  FilterSettings?: H265FilterSettings;
  FixedAfd?: FixedAfd;
  FlickerAq?: H265FlickerAq;
  FramerateDenominator: number | undefined;
  FramerateNumerator: number | undefined;
  GopClosedCadence?: number;
  GopSize?: number;
  GopSizeUnits?: H265GopSizeUnits;
  Level?: H265Level;
  LookAheadRateControl?: H265LookAheadRateControl;
  MaxBitrate?: number;
  MinIInterval?: number;
  ParDenominator?: number;
  ParNumerator?: number;
  Profile?: H265Profile;
  QvbrQualityLevel?: number;
  RateControlMode?: H265RateControlMode;
  ScanType?: H265ScanType;
  SceneChangeDetect?: H265SceneChangeDetect;
  Slices?: number;
  Tier?: H265Tier;
  TimecodeInsertion?: H265TimecodeInsertionBehavior;
  TimecodeBurninSettings?: TimecodeBurninSettings;
  MvOverPictureBoundaries?: H265MvOverPictureBoundaries;
  MvTemporalPredictor?: H265MvTemporalPredictor;
  TileHeight?: number;
  TilePadding?: H265TilePadding;
  TileWidth?: number;
  TreeblockSize?: H265TreeblockSize;
}
export declare const Mpeg2AdaptiveQuantization: {
  readonly AUTO: "AUTO";
  readonly HIGH: "HIGH";
  readonly LOW: "LOW";
  readonly MEDIUM: "MEDIUM";
  readonly OFF: "OFF";
};
export type Mpeg2AdaptiveQuantization =
  (typeof Mpeg2AdaptiveQuantization)[keyof typeof Mpeg2AdaptiveQuantization];
export declare const Mpeg2ColorMetadata: {
  readonly IGNORE: "IGNORE";
  readonly INSERT: "INSERT";
};
export type Mpeg2ColorMetadata =
  (typeof Mpeg2ColorMetadata)[keyof typeof Mpeg2ColorMetadata];
export declare const Mpeg2ColorSpace: {
  readonly AUTO: "AUTO";
  readonly PASSTHROUGH: "PASSTHROUGH";
};
export type Mpeg2ColorSpace =
  (typeof Mpeg2ColorSpace)[keyof typeof Mpeg2ColorSpace];
export declare const Mpeg2DisplayRatio: {
  readonly DISPLAYRATIO16X9: "DISPLAYRATIO16X9";
  readonly DISPLAYRATIO4X3: "DISPLAYRATIO4X3";
};
export type Mpeg2DisplayRatio =
  (typeof Mpeg2DisplayRatio)[keyof typeof Mpeg2DisplayRatio];
export interface Mpeg2FilterSettings {
  TemporalFilterSettings?: TemporalFilterSettings;
}
export declare const Mpeg2GopSizeUnits: {
  readonly FRAMES: "FRAMES";
  readonly SECONDS: "SECONDS";
};
export type Mpeg2GopSizeUnits =
  (typeof Mpeg2GopSizeUnits)[keyof typeof Mpeg2GopSizeUnits];
export declare const Mpeg2ScanType: {
  readonly INTERLACED: "INTERLACED";
  readonly PROGRESSIVE: "PROGRESSIVE";
};
export type Mpeg2ScanType = (typeof Mpeg2ScanType)[keyof typeof Mpeg2ScanType];
export declare const Mpeg2SubGopLength: {
  readonly DYNAMIC: "DYNAMIC";
  readonly FIXED: "FIXED";
};
export type Mpeg2SubGopLength =
  (typeof Mpeg2SubGopLength)[keyof typeof Mpeg2SubGopLength];
export declare const Mpeg2TimecodeInsertionBehavior: {
  readonly DISABLED: "DISABLED";
  readonly GOP_TIMECODE: "GOP_TIMECODE";
};
export type Mpeg2TimecodeInsertionBehavior =
  (typeof Mpeg2TimecodeInsertionBehavior)[keyof typeof Mpeg2TimecodeInsertionBehavior];
export interface Mpeg2Settings {
  AdaptiveQuantization?: Mpeg2AdaptiveQuantization;
  AfdSignaling?: AfdSignaling;
  ColorMetadata?: Mpeg2ColorMetadata;
  ColorSpace?: Mpeg2ColorSpace;
  DisplayAspectRatio?: Mpeg2DisplayRatio;
  FilterSettings?: Mpeg2FilterSettings;
  FixedAfd?: FixedAfd;
  FramerateDenominator: number | undefined;
  FramerateNumerator: number | undefined;
  GopClosedCadence?: number;
  GopNumBFrames?: number;
  GopSize?: number;
  GopSizeUnits?: Mpeg2GopSizeUnits;
  ScanType?: Mpeg2ScanType;
  SubgopLength?: Mpeg2SubGopLength;
  TimecodeInsertion?: Mpeg2TimecodeInsertionBehavior;
  TimecodeBurninSettings?: TimecodeBurninSettings;
}
export interface VideoCodecSettings {
  FrameCaptureSettings?: FrameCaptureSettings;
  H264Settings?: H264Settings;
  H265Settings?: H265Settings;
  Mpeg2Settings?: Mpeg2Settings;
}
export declare const VideoDescriptionRespondToAfd: {
  readonly NONE: "NONE";
  readonly PASSTHROUGH: "PASSTHROUGH";
  readonly RESPOND: "RESPOND";
};
export type VideoDescriptionRespondToAfd =
  (typeof VideoDescriptionRespondToAfd)[keyof typeof VideoDescriptionRespondToAfd];
export declare const VideoDescriptionScalingBehavior: {
  readonly DEFAULT: "DEFAULT";
  readonly STRETCH_TO_OUTPUT: "STRETCH_TO_OUTPUT";
};
export type VideoDescriptionScalingBehavior =
  (typeof VideoDescriptionScalingBehavior)[keyof typeof VideoDescriptionScalingBehavior];
export interface VideoDescription {
  CodecSettings?: VideoCodecSettings;
  Height?: number;
  Name: string | undefined;
  RespondToAfd?: VideoDescriptionRespondToAfd;
  ScalingBehavior?: VideoDescriptionScalingBehavior;
  Sharpness?: number;
  Width?: number;
}
export declare const AcceptHeader: {
  readonly image_jpeg: "image/jpeg";
};
export type AcceptHeader = (typeof AcceptHeader)[keyof typeof AcceptHeader];
export interface AcceptInputDeviceTransferRequest {
  InputDeviceId: string | undefined;
}
export interface AcceptInputDeviceTransferResponse {}
export declare class BadGatewayException extends __BaseException {
  readonly name: "BadGatewayException";
  readonly $fault: "server";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<BadGatewayException, __BaseException>
  );
}
export declare class BadRequestException extends __BaseException {
  readonly name: "BadRequestException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<BadRequestException, __BaseException>
  );
}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  Message?: string;
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export declare class ForbiddenException extends __BaseException {
  readonly name: "ForbiddenException";
  readonly $fault: "client";
  Message?: string;
  constructor(opts: __ExceptionOptionType<ForbiddenException, __BaseException>);
}
export declare class GatewayTimeoutException extends __BaseException {
  readonly name: "GatewayTimeoutException";
  readonly $fault: "server";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<GatewayTimeoutException, __BaseException>
  );
}
export declare class InternalServerErrorException extends __BaseException {
  readonly name: "InternalServerErrorException";
  readonly $fault: "server";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InternalServerErrorException, __BaseException>
  );
}
export declare class NotFoundException extends __BaseException {
  readonly name: "NotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(opts: __ExceptionOptionType<NotFoundException, __BaseException>);
}
export declare class TooManyRequestsException extends __BaseException {
  readonly name: "TooManyRequestsException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TooManyRequestsException, __BaseException>
  );
}
export declare class UnprocessableEntityException extends __BaseException {
  readonly name: "UnprocessableEntityException";
  readonly $fault: "client";
  Message?: string;
  ValidationErrors?: ValidationError[];
  constructor(
    opts: __ExceptionOptionType<UnprocessableEntityException, __BaseException>
  );
}
export interface AccountConfiguration {
  KmsKeyId?: string;
}
export declare const AvailBlankingState: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type AvailBlankingState =
  (typeof AvailBlankingState)[keyof typeof AvailBlankingState];
export interface AvailBlanking {
  AvailBlankingImage?: InputLocation;
  State?: AvailBlankingState;
}
export interface Esam {
  AcquisitionPointId: string | undefined;
  AdAvailOffset?: number;
  PasswordParam?: string;
  PoisEndpoint: string | undefined;
  Username?: string;
  ZoneIdentity?: string;
}
export declare const Scte35SpliceInsertNoRegionalBlackoutBehavior: {
  readonly FOLLOW: "FOLLOW";
  readonly IGNORE: "IGNORE";
};
export type Scte35SpliceInsertNoRegionalBlackoutBehavior =
  (typeof Scte35SpliceInsertNoRegionalBlackoutBehavior)[keyof typeof Scte35SpliceInsertNoRegionalBlackoutBehavior];
export declare const Scte35SpliceInsertWebDeliveryAllowedBehavior: {
  readonly FOLLOW: "FOLLOW";
  readonly IGNORE: "IGNORE";
};
export type Scte35SpliceInsertWebDeliveryAllowedBehavior =
  (typeof Scte35SpliceInsertWebDeliveryAllowedBehavior)[keyof typeof Scte35SpliceInsertWebDeliveryAllowedBehavior];
export interface Scte35SpliceInsert {
  AdAvailOffset?: number;
  NoRegionalBlackoutFlag?: Scte35SpliceInsertNoRegionalBlackoutBehavior;
  WebDeliveryAllowedFlag?: Scte35SpliceInsertWebDeliveryAllowedBehavior;
}
export declare const Scte35AposNoRegionalBlackoutBehavior: {
  readonly FOLLOW: "FOLLOW";
  readonly IGNORE: "IGNORE";
};
export type Scte35AposNoRegionalBlackoutBehavior =
  (typeof Scte35AposNoRegionalBlackoutBehavior)[keyof typeof Scte35AposNoRegionalBlackoutBehavior];
export declare const Scte35AposWebDeliveryAllowedBehavior: {
  readonly FOLLOW: "FOLLOW";
  readonly IGNORE: "IGNORE";
};
export type Scte35AposWebDeliveryAllowedBehavior =
  (typeof Scte35AposWebDeliveryAllowedBehavior)[keyof typeof Scte35AposWebDeliveryAllowedBehavior];
export interface Scte35TimeSignalApos {
  AdAvailOffset?: number;
  NoRegionalBlackoutFlag?: Scte35AposNoRegionalBlackoutBehavior;
  WebDeliveryAllowedFlag?: Scte35AposWebDeliveryAllowedBehavior;
}
export interface AvailSettings {
  Esam?: Esam;
  Scte35SpliceInsert?: Scte35SpliceInsert;
  Scte35TimeSignalApos?: Scte35TimeSignalApos;
}
export interface AvailConfiguration {
  AvailSettings?: AvailSettings;
}
export interface BatchDeleteRequest {
  ChannelIds?: string[];
  InputIds?: string[];
  InputSecurityGroupIds?: string[];
  MultiplexIds?: string[];
}
export interface BatchDeleteResponse {
  Failed?: BatchFailedResultModel[];
  Successful?: BatchSuccessfulResultModel[];
}
export interface BatchScheduleActionCreateRequest {
  ScheduleActions: ScheduleAction[] | undefined;
}
export interface BatchScheduleActionCreateResult {
  ScheduleActions: ScheduleAction[] | undefined;
}
export interface BatchScheduleActionDeleteRequest {
  ActionNames: string[] | undefined;
}
export interface BatchScheduleActionDeleteResult {
  ScheduleActions: ScheduleAction[] | undefined;
}
export interface BatchStartRequest {
  ChannelIds?: string[];
  MultiplexIds?: string[];
}
export interface BatchStartResponse {
  Failed?: BatchFailedResultModel[];
  Successful?: BatchSuccessfulResultModel[];
}
export interface BatchStopRequest {
  ChannelIds?: string[];
  MultiplexIds?: string[];
}
export interface BatchStopResponse {
  Failed?: BatchFailedResultModel[];
  Successful?: BatchSuccessfulResultModel[];
}
export interface BatchUpdateScheduleRequest {
  ChannelId: string | undefined;
  Creates?: BatchScheduleActionCreateRequest;
  Deletes?: BatchScheduleActionDeleteRequest;
}
export interface BatchUpdateScheduleResponse {
  Creates?: BatchScheduleActionCreateResult;
  Deletes?: BatchScheduleActionDeleteResult;
}
export declare const BlackoutSlateNetworkEndBlackout: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type BlackoutSlateNetworkEndBlackout =
  (typeof BlackoutSlateNetworkEndBlackout)[keyof typeof BlackoutSlateNetworkEndBlackout];
export declare const BlackoutSlateState: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type BlackoutSlateState =
  (typeof BlackoutSlateState)[keyof typeof BlackoutSlateState];
export interface BlackoutSlate {
  BlackoutSlateImage?: InputLocation;
  NetworkEndBlackout?: BlackoutSlateNetworkEndBlackout;
  NetworkEndBlackoutImage?: InputLocation;
  NetworkId?: string;
  State?: BlackoutSlateState;
}
export interface CancelInputDeviceTransferRequest {
  InputDeviceId: string | undefined;
}
export interface CancelInputDeviceTransferResponse {}
export interface ColorCorrectionSettings {
  GlobalColorCorrections: ColorCorrection[] | undefined;
}
export declare const FeatureActivationsInputPrepareScheduleActions: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type FeatureActivationsInputPrepareScheduleActions =
  (typeof FeatureActivationsInputPrepareScheduleActions)[keyof typeof FeatureActivationsInputPrepareScheduleActions];
export declare const FeatureActivationsOutputStaticImageOverlayScheduleActions: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type FeatureActivationsOutputStaticImageOverlayScheduleActions =
  (typeof FeatureActivationsOutputStaticImageOverlayScheduleActions)[keyof typeof FeatureActivationsOutputStaticImageOverlayScheduleActions];
export interface FeatureActivations {
  InputPrepareScheduleActions?: FeatureActivationsInputPrepareScheduleActions;
  OutputStaticImageOverlayScheduleActions?: FeatureActivationsOutputStaticImageOverlayScheduleActions;
}
export declare const GlobalConfigurationInputEndAction: {
  readonly NONE: "NONE";
  readonly SWITCH_AND_LOOP_INPUTS: "SWITCH_AND_LOOP_INPUTS";
};
export type GlobalConfigurationInputEndAction =
  (typeof GlobalConfigurationInputEndAction)[keyof typeof GlobalConfigurationInputEndAction];
export declare const InputLossImageType: {
  readonly COLOR: "COLOR";
  readonly SLATE: "SLATE";
};
export type InputLossImageType =
  (typeof InputLossImageType)[keyof typeof InputLossImageType];
export interface InputLossBehavior {
  BlackFrameMsec?: number;
  InputLossImageColor?: string;
  InputLossImageSlate?: InputLocation;
  InputLossImageType?: InputLossImageType;
  RepeatFrameMsec?: number;
}
export declare const GlobalConfigurationOutputLockingMode: {
  readonly EPOCH_LOCKING: "EPOCH_LOCKING";
  readonly PIPELINE_LOCKING: "PIPELINE_LOCKING";
};
export type GlobalConfigurationOutputLockingMode =
  (typeof GlobalConfigurationOutputLockingMode)[keyof typeof GlobalConfigurationOutputLockingMode];
export interface EpochLockingSettings {
  CustomEpoch?: string;
  JamSyncTime?: string;
}
export interface PipelineLockingSettings {}
export interface OutputLockingSettings {
  EpochLockingSettings?: EpochLockingSettings;
  PipelineLockingSettings?: PipelineLockingSettings;
}
export declare const GlobalConfigurationOutputTimingSource: {
  readonly INPUT_CLOCK: "INPUT_CLOCK";
  readonly SYSTEM_CLOCK: "SYSTEM_CLOCK";
};
export type GlobalConfigurationOutputTimingSource =
  (typeof GlobalConfigurationOutputTimingSource)[keyof typeof GlobalConfigurationOutputTimingSource];
export declare const GlobalConfigurationLowFramerateInputs: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type GlobalConfigurationLowFramerateInputs =
  (typeof GlobalConfigurationLowFramerateInputs)[keyof typeof GlobalConfigurationLowFramerateInputs];
export interface GlobalConfiguration {
  InitialAudioGain?: number;
  InputEndAction?: GlobalConfigurationInputEndAction;
  InputLossBehavior?: InputLossBehavior;
  OutputLockingMode?: GlobalConfigurationOutputLockingMode;
  OutputTimingSource?: GlobalConfigurationOutputTimingSource;
  SupportLowFramerateInputs?: GlobalConfigurationLowFramerateInputs;
  OutputLockingSettings?: OutputLockingSettings;
}
export declare const MotionGraphicsInsertion: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type MotionGraphicsInsertion =
  (typeof MotionGraphicsInsertion)[keyof typeof MotionGraphicsInsertion];
export interface HtmlMotionGraphicsSettings {}
export interface MotionGraphicsSettings {
  HtmlMotionGraphicsSettings?: HtmlMotionGraphicsSettings;
}
export interface MotionGraphicsConfiguration {
  MotionGraphicsInsertion?: MotionGraphicsInsertion;
  MotionGraphicsSettings: MotionGraphicsSettings | undefined;
}
export declare const NielsenPcmToId3TaggingState: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type NielsenPcmToId3TaggingState =
  (typeof NielsenPcmToId3TaggingState)[keyof typeof NielsenPcmToId3TaggingState];
export interface NielsenConfiguration {
  DistributorId?: string;
  NielsenPcmToId3Tagging?: NielsenPcmToId3TaggingState;
}
export declare const ThumbnailState: {
  readonly AUTO: "AUTO";
  readonly DISABLED: "DISABLED";
};
export type ThumbnailState =
  (typeof ThumbnailState)[keyof typeof ThumbnailState];
export interface ThumbnailConfiguration {
  State: ThumbnailState | undefined;
}
export declare const TimecodeConfigSource: {
  readonly EMBEDDED: "EMBEDDED";
  readonly SYSTEMCLOCK: "SYSTEMCLOCK";
  readonly ZEROBASED: "ZEROBASED";
};
export type TimecodeConfigSource =
  (typeof TimecodeConfigSource)[keyof typeof TimecodeConfigSource];
export interface TimecodeConfig {
  Source: TimecodeConfigSource | undefined;
  SyncThreshold?: number;
}
export interface EncoderSettings {
  AudioDescriptions: AudioDescription[] | undefined;
  AvailBlanking?: AvailBlanking;
  AvailConfiguration?: AvailConfiguration;
  BlackoutSlate?: BlackoutSlate;
  CaptionDescriptions?: CaptionDescription[];
  FeatureActivations?: FeatureActivations;
  GlobalConfiguration?: GlobalConfiguration;
  MotionGraphicsConfiguration?: MotionGraphicsConfiguration;
  NielsenConfiguration?: NielsenConfiguration;
  OutputGroups: OutputGroup[] | undefined;
  TimecodeConfig: TimecodeConfig | undefined;
  VideoDescriptions: VideoDescription[] | undefined;
  ThumbnailConfiguration?: ThumbnailConfiguration;
  ColorCorrectionSettings?: ColorCorrectionSettings;
}
export interface Channel {
  Arn?: string;
  CdiInputSpecification?: CdiInputSpecification;
  ChannelClass?: ChannelClass;
  Destinations?: OutputDestination[];
  EgressEndpoints?: ChannelEgressEndpoint[];
  EncoderSettings?: EncoderSettings;
  Id?: string;
  InputAttachments?: InputAttachment[];
  InputSpecification?: InputSpecification;
  LogLevel?: LogLevel;
  Maintenance?: MaintenanceStatus;
  Name?: string;
  PipelineDetails?: PipelineDetail[];
  PipelinesRunningCount?: number;
  RoleArn?: string;
  State?: ChannelState;
  Tags?: Record<string, string>;
  Vpc?: VpcOutputSettingsDescription;
}
export interface ClaimDeviceRequest {
  Id?: string;
}
export interface ClaimDeviceResponse {}
export declare const ContentType: {
  readonly image_jpeg: "image/jpeg";
};
export type ContentType = (typeof ContentType)[keyof typeof ContentType];
export interface MaintenanceCreateSettings {
  MaintenanceDay?: MaintenanceDay;
  MaintenanceStartTime?: string;
}
export interface VpcOutputSettings {
  PublicAddressAllocationIds?: string[];
  SecurityGroupIds?: string[];
  SubnetIds: string[] | undefined;
}
export interface CreateChannelRequest {
  CdiInputSpecification?: CdiInputSpecification;
  ChannelClass?: ChannelClass;
  Destinations?: OutputDestination[];
  EncoderSettings?: EncoderSettings;
  InputAttachments?: InputAttachment[];
  InputSpecification?: InputSpecification;
  LogLevel?: LogLevel;
  Maintenance?: MaintenanceCreateSettings;
  Name?: string;
  RequestId?: string;
  Reserved?: string;
  RoleArn?: string;
  Tags?: Record<string, string>;
  Vpc?: VpcOutputSettings;
}
export interface CreateChannelResponse {
  Channel?: Channel;
}
export interface CreateCloudWatchAlarmTemplateRequest {
  ComparisonOperator: CloudWatchAlarmTemplateComparisonOperator | undefined;
  DatapointsToAlarm?: number;
  Description?: string;
  EvaluationPeriods: number | undefined;
  GroupIdentifier: string | undefined;
  MetricName: string | undefined;
  Name: string | undefined;
  Period: number | undefined;
  Statistic: CloudWatchAlarmTemplateStatistic | undefined;
  Tags?: Record<string, string>;
  TargetResourceType: CloudWatchAlarmTemplateTargetResourceType | undefined;
  Threshold: number | undefined;
  TreatMissingData: CloudWatchAlarmTemplateTreatMissingData | undefined;
}
export interface CreateCloudWatchAlarmTemplateResponse {
  Arn?: string;
  ComparisonOperator?: CloudWatchAlarmTemplateComparisonOperator;
  CreatedAt?: Date;
  DatapointsToAlarm?: number;
  Description?: string;
  EvaluationPeriods?: number;
  GroupId?: string;
  Id?: string;
  MetricName?: string;
  ModifiedAt?: Date;
  Name?: string;
  Period?: number;
  Statistic?: CloudWatchAlarmTemplateStatistic;
  Tags?: Record<string, string>;
  TargetResourceType?: CloudWatchAlarmTemplateTargetResourceType;
  Threshold?: number;
  TreatMissingData?: CloudWatchAlarmTemplateTreatMissingData;
}
export interface CreateCloudWatchAlarmTemplateGroupRequest {
  Description?: string;
  Name: string | undefined;
  Tags?: Record<string, string>;
}
export interface CreateCloudWatchAlarmTemplateGroupResponse {
  Arn?: string;
  CreatedAt?: Date;
  Description?: string;
  Id?: string;
  ModifiedAt?: Date;
  Name?: string;
  Tags?: Record<string, string>;
}
export interface CreateEventBridgeRuleTemplateRequest {
  Description?: string;
  EventTargets?: EventBridgeRuleTemplateTarget[];
  EventType: EventBridgeRuleTemplateEventType | undefined;
  GroupIdentifier: string | undefined;
  Name: string | undefined;
  Tags?: Record<string, string>;
}
export interface CreateEventBridgeRuleTemplateResponse {
  Arn?: string;
  CreatedAt?: Date;
  Description?: string;
  EventTargets?: EventBridgeRuleTemplateTarget[];
  EventType?: EventBridgeRuleTemplateEventType;
  GroupId?: string;
  Id?: string;
  ModifiedAt?: Date;
  Name?: string;
  Tags?: Record<string, string>;
}
export interface CreateEventBridgeRuleTemplateGroupRequest {
  Description?: string;
  Name: string | undefined;
  Tags?: Record<string, string>;
}
export interface CreateEventBridgeRuleTemplateGroupResponse {
  Arn?: string;
  CreatedAt?: Date;
  Description?: string;
  Id?: string;
  ModifiedAt?: Date;
  Name?: string;
  Tags?: Record<string, string>;
}
export interface InputVpcRequest {
  SecurityGroupIds?: string[];
  SubnetIds: string[] | undefined;
}
export interface CreateInputRequest {
  Destinations?: InputDestinationRequest[];
  InputDevices?: InputDeviceSettings[];
  InputSecurityGroups?: string[];
  MediaConnectFlows?: MediaConnectFlowRequest[];
  Name?: string;
  RequestId?: string;
  RoleArn?: string;
  Sources?: InputSourceRequest[];
  Tags?: Record<string, string>;
  Type?: InputType;
  Vpc?: InputVpcRequest;
}
export interface CreateInputResponse {
  Input?: Input;
}
export interface CreateInputSecurityGroupRequest {
  Tags?: Record<string, string>;
  WhitelistRules?: InputWhitelistRuleCidr[];
}
export interface CreateInputSecurityGroupResponse {
  SecurityGroup?: InputSecurityGroup;
}
export interface MultiplexSettings {
  MaximumVideoBufferDelayMilliseconds?: number;
  TransportStreamBitrate: number | undefined;
  TransportStreamId: number | undefined;
  TransportStreamReservedBitrate?: number;
}
export interface CreateMultiplexRequest {
  AvailabilityZones: string[] | undefined;
  MultiplexSettings: MultiplexSettings | undefined;
  Name: string | undefined;
  RequestId?: string;
  Tags?: Record<string, string>;
}
export interface Multiplex {
  Arn?: string;
  AvailabilityZones?: string[];
  Destinations?: MultiplexOutputDestination[];
  Id?: string;
  MultiplexSettings?: MultiplexSettings;
  Name?: string;
  PipelinesRunningCount?: number;
  ProgramCount?: number;
  State?: MultiplexState;
  Tags?: Record<string, string>;
}
export interface CreateMultiplexResponse {
  Multiplex?: Multiplex;
}
export declare const PreferredChannelPipeline: {
  readonly CURRENTLY_ACTIVE: "CURRENTLY_ACTIVE";
  readonly PIPELINE_0: "PIPELINE_0";
  readonly PIPELINE_1: "PIPELINE_1";
};
export type PreferredChannelPipeline =
  (typeof PreferredChannelPipeline)[keyof typeof PreferredChannelPipeline];
export interface MultiplexProgramServiceDescriptor {
  ProviderName: string | undefined;
  ServiceName: string | undefined;
}
export interface MultiplexStatmuxVideoSettings {
  MaximumBitrate?: number;
  MinimumBitrate?: number;
  Priority?: number;
}
export interface MultiplexVideoSettings {
  ConstantBitrate?: number;
  StatmuxSettings?: MultiplexStatmuxVideoSettings;
}
export interface MultiplexProgramSettings {
  PreferredChannelPipeline?: PreferredChannelPipeline;
  ProgramNumber: number | undefined;
  ServiceDescriptor?: MultiplexProgramServiceDescriptor;
  VideoSettings?: MultiplexVideoSettings;
}
export interface CreateMultiplexProgramRequest {
  MultiplexId: string | undefined;
  MultiplexProgramSettings: MultiplexProgramSettings | undefined;
  ProgramName: string | undefined;
  RequestId?: string;
}
export interface MultiplexProgramPacketIdentifiersMap {
  AudioPids?: number[];
  DvbSubPids?: number[];
  DvbTeletextPid?: number;
  EtvPlatformPid?: number;
  EtvSignalPid?: number;
  KlvDataPids?: number[];
  PcrPid?: number;
  PmtPid?: number;
  PrivateMetadataPid?: number;
  Scte27Pids?: number[];
  Scte35Pid?: number;
  TimedMetadataPid?: number;
  VideoPid?: number;
}
export interface MultiplexProgram {
  ChannelId?: string;
  MultiplexProgramSettings?: MultiplexProgramSettings;
  PacketIdentifiersMap?: MultiplexProgramPacketIdentifiersMap;
  PipelineDetails?: MultiplexProgramPipelineDetail[];
  ProgramName?: string;
}
export interface CreateMultiplexProgramResponse {
  MultiplexProgram?: MultiplexProgram;
}
export interface CreatePartnerInputRequest {
  InputId: string | undefined;
  RequestId?: string;
  Tags?: Record<string, string>;
}
export interface CreatePartnerInputResponse {
  Input?: Input;
}
export interface CreateSignalMapRequest {
  CloudWatchAlarmTemplateGroupIdentifiers?: string[];
  Description?: string;
  DiscoveryEntryPointArn: string | undefined;
  EventBridgeRuleTemplateGroupIdentifiers?: string[];
  Name: string | undefined;
  Tags?: Record<string, string>;
}
export interface MediaResource {
  Destinations?: MediaResourceNeighbor[];
  Name?: string;
  Sources?: MediaResourceNeighbor[];
}
export interface SuccessfulMonitorDeployment {
  DetailsUri: string | undefined;
  Status: SignalMapMonitorDeploymentStatus | undefined;
}
export interface MonitorDeployment {
  DetailsUri?: string;
  ErrorMessage?: string;
  Status: SignalMapMonitorDeploymentStatus | undefined;
}
export interface CreateSignalMapResponse {
  Arn?: string;
  CloudWatchAlarmTemplateGroupIds?: string[];
  CreatedAt?: Date;
  Description?: string;
  DiscoveryEntryPointArn?: string;
  ErrorMessage?: string;
  EventBridgeRuleTemplateGroupIds?: string[];
  FailedMediaResourceMap?: Record<string, MediaResource>;
  Id?: string;
  LastDiscoveredAt?: Date;
  LastSuccessfulMonitorDeployment?: SuccessfulMonitorDeployment;
  MediaResourceMap?: Record<string, MediaResource>;
  ModifiedAt?: Date;
  MonitorChangesPendingDeployment?: boolean;
  MonitorDeployment?: MonitorDeployment;
  Name?: string;
  Status?: SignalMapStatus;
  Tags?: Record<string, string>;
}
export interface CreateTagsRequest {
  ResourceArn: string | undefined;
  Tags?: Record<string, string>;
}
export interface DeleteChannelRequest {
  ChannelId: string | undefined;
}
export interface DeleteChannelResponse {
  Arn?: string;
  CdiInputSpecification?: CdiInputSpecification;
  ChannelClass?: ChannelClass;
  Destinations?: OutputDestination[];
  EgressEndpoints?: ChannelEgressEndpoint[];
  EncoderSettings?: EncoderSettings;
  Id?: string;
  InputAttachments?: InputAttachment[];
  InputSpecification?: InputSpecification;
  LogLevel?: LogLevel;
  Maintenance?: MaintenanceStatus;
  Name?: string;
  PipelineDetails?: PipelineDetail[];
  PipelinesRunningCount?: number;
  RoleArn?: string;
  State?: ChannelState;
  Tags?: Record<string, string>;
  Vpc?: VpcOutputSettingsDescription;
}
