import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { BatchServiceException as __BaseException } from "./BatchServiceException";
export declare const ArrayJobDependency: {
  readonly N_TO_N: "N_TO_N";
  readonly SEQUENTIAL: "SEQUENTIAL";
};
export type ArrayJobDependency =
  (typeof ArrayJobDependency)[keyof typeof ArrayJobDependency];
export interface ArrayProperties {
  size?: number;
}
export interface ArrayPropertiesDetail {
  statusSummary?: Record<string, number>;
  size?: number;
  index?: number;
}
export interface ArrayPropertiesSummary {
  size?: number;
  index?: number;
}
export declare const AssignPublicIp: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type AssignPublicIp =
  (typeof AssignPublicIp)[keyof typeof AssignPublicIp];
export interface NetworkInterface {
  attachmentId?: string;
  ipv6Address?: string;
  privateIpv4Address?: string;
}
export interface AttemptContainerDetail {
  containerInstanceArn?: string;
  taskArn?: string;
  exitCode?: number;
  reason?: string;
  logStreamName?: string;
  networkInterfaces?: NetworkInterface[];
}
export interface AttemptTaskContainerDetails {
  exitCode?: number;
  name?: string;
  reason?: string;
  logStreamName?: string;
  networkInterfaces?: NetworkInterface[];
}
export interface AttemptEcsTaskDetails {
  containerInstanceArn?: string;
  taskArn?: string;
  containers?: AttemptTaskContainerDetails[];
}
export interface AttemptDetail {
  container?: AttemptContainerDetail;
  startedAt?: number;
  stoppedAt?: number;
  statusReason?: string;
  taskProperties?: AttemptEcsTaskDetails[];
}
export interface CancelJobRequest {
  jobId: string | undefined;
  reason: string | undefined;
}
export interface CancelJobResponse {}
export declare class ClientException extends __BaseException {
  readonly name: "ClientException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<ClientException, __BaseException>);
}
export declare class ServerException extends __BaseException {
  readonly name: "ServerException";
  readonly $fault: "server";
  constructor(opts: __ExceptionOptionType<ServerException, __BaseException>);
}
export declare const CRAllocationStrategy: {
  readonly BEST_FIT: "BEST_FIT";
  readonly BEST_FIT_PROGRESSIVE: "BEST_FIT_PROGRESSIVE";
  readonly SPOT_CAPACITY_OPTIMIZED: "SPOT_CAPACITY_OPTIMIZED";
  readonly SPOT_PRICE_CAPACITY_OPTIMIZED: "SPOT_PRICE_CAPACITY_OPTIMIZED";
};
export type CRAllocationStrategy =
  (typeof CRAllocationStrategy)[keyof typeof CRAllocationStrategy];
export interface Ec2Configuration {
  imageType: string | undefined;
  imageIdOverride?: string;
  imageKubernetesVersion?: string;
}
export interface LaunchTemplateSpecification {
  launchTemplateId?: string;
  launchTemplateName?: string;
  version?: string;
}
export declare const CRType: {
  readonly EC2: "EC2";
  readonly FARGATE: "FARGATE";
  readonly FARGATE_SPOT: "FARGATE_SPOT";
  readonly SPOT: "SPOT";
};
export type CRType = (typeof CRType)[keyof typeof CRType];
export interface ComputeResource {
  type: CRType | undefined;
  allocationStrategy?: CRAllocationStrategy;
  minvCpus?: number;
  maxvCpus: number | undefined;
  desiredvCpus?: number;
  instanceTypes?: string[];
  imageId?: string;
  subnets: string[] | undefined;
  securityGroupIds?: string[];
  ec2KeyPair?: string;
  instanceRole?: string;
  tags?: Record<string, string>;
  placementGroup?: string;
  bidPercentage?: number;
  spotIamFleetRole?: string;
  launchTemplate?: LaunchTemplateSpecification;
  ec2Configuration?: Ec2Configuration[];
}
export interface EksConfiguration {
  eksClusterArn: string | undefined;
  kubernetesNamespace: string | undefined;
}
export declare const CEState: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type CEState = (typeof CEState)[keyof typeof CEState];
export declare const CEType: {
  readonly MANAGED: "MANAGED";
  readonly UNMANAGED: "UNMANAGED";
};
export type CEType = (typeof CEType)[keyof typeof CEType];
export interface CreateComputeEnvironmentRequest {
  computeEnvironmentName: string | undefined;
  type: CEType | undefined;
  state?: CEState;
  unmanagedvCpus?: number;
  computeResources?: ComputeResource;
  serviceRole?: string;
  tags?: Record<string, string>;
  eksConfiguration?: EksConfiguration;
}
export interface CreateComputeEnvironmentResponse {
  computeEnvironmentName?: string;
  computeEnvironmentArn?: string;
}
export interface ComputeEnvironmentOrder {
  order: number | undefined;
  computeEnvironment: string | undefined;
}
export declare const JobStateTimeLimitActionsAction: {
  readonly CANCEL: "CANCEL";
};
export type JobStateTimeLimitActionsAction =
  (typeof JobStateTimeLimitActionsAction)[keyof typeof JobStateTimeLimitActionsAction];
export declare const JobStateTimeLimitActionsState: {
  readonly RUNNABLE: "RUNNABLE";
};
export type JobStateTimeLimitActionsState =
  (typeof JobStateTimeLimitActionsState)[keyof typeof JobStateTimeLimitActionsState];
export interface JobStateTimeLimitAction {
  reason: string | undefined;
  state: JobStateTimeLimitActionsState | undefined;
  maxTimeSeconds: number | undefined;
  action: JobStateTimeLimitActionsAction | undefined;
}
export declare const JQState: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type JQState = (typeof JQState)[keyof typeof JQState];
export interface CreateJobQueueRequest {
  jobQueueName: string | undefined;
  state?: JQState;
  schedulingPolicyArn?: string;
  priority: number | undefined;
  computeEnvironmentOrder: ComputeEnvironmentOrder[] | undefined;
  tags?: Record<string, string>;
  jobStateTimeLimitActions?: JobStateTimeLimitAction[];
}
export interface CreateJobQueueResponse {
  jobQueueName: string | undefined;
  jobQueueArn: string | undefined;
}
export interface ShareAttributes {
  shareIdentifier: string | undefined;
  weightFactor?: number;
}
export interface FairsharePolicy {
  shareDecaySeconds?: number;
  computeReservation?: number;
  shareDistribution?: ShareAttributes[];
}
export interface CreateSchedulingPolicyRequest {
  name: string | undefined;
  fairsharePolicy?: FairsharePolicy;
  tags?: Record<string, string>;
}
export interface CreateSchedulingPolicyResponse {
  name: string | undefined;
  arn: string | undefined;
}
export interface DeleteComputeEnvironmentRequest {
  computeEnvironment: string | undefined;
}
export interface DeleteComputeEnvironmentResponse {}
export interface DeleteJobQueueRequest {
  jobQueue: string | undefined;
}
export interface DeleteJobQueueResponse {}
export interface DeleteSchedulingPolicyRequest {
  arn: string | undefined;
}
export interface DeleteSchedulingPolicyResponse {}
export interface DeregisterJobDefinitionRequest {
  jobDefinition: string | undefined;
}
export interface DeregisterJobDefinitionResponse {}
export interface DescribeComputeEnvironmentsRequest {
  computeEnvironments?: string[];
  maxResults?: number;
  nextToken?: string;
}
export declare const OrchestrationType: {
  readonly ECS: "ECS";
  readonly EKS: "EKS";
};
export type OrchestrationType =
  (typeof OrchestrationType)[keyof typeof OrchestrationType];
export declare const CEStatus: {
  readonly CREATING: "CREATING";
  readonly DELETED: "DELETED";
  readonly DELETING: "DELETING";
  readonly INVALID: "INVALID";
  readonly UPDATING: "UPDATING";
  readonly VALID: "VALID";
};
export type CEStatus = (typeof CEStatus)[keyof typeof CEStatus];
export interface UpdatePolicy {
  terminateJobsOnUpdate?: boolean;
  jobExecutionTimeoutMinutes?: number;
}
export interface ComputeEnvironmentDetail {
  computeEnvironmentName: string | undefined;
  computeEnvironmentArn: string | undefined;
  unmanagedvCpus?: number;
  ecsClusterArn?: string;
  tags?: Record<string, string>;
  type?: CEType;
  state?: CEState;
  status?: CEStatus;
  statusReason?: string;
  computeResources?: ComputeResource;
  serviceRole?: string;
  updatePolicy?: UpdatePolicy;
  eksConfiguration?: EksConfiguration;
  containerOrchestrationType?: OrchestrationType;
  uuid?: string;
}
export interface DescribeComputeEnvironmentsResponse {
  computeEnvironments?: ComputeEnvironmentDetail[];
  nextToken?: string;
}
export interface DescribeJobDefinitionsRequest {
  jobDefinitions?: string[];
  maxResults?: number;
  jobDefinitionName?: string;
  status?: string;
  nextToken?: string;
}
export interface KeyValuePair {
  name?: string;
  value?: string;
}
export interface EphemeralStorage {
  sizeInGiB: number | undefined;
}
export interface FargatePlatformConfiguration {
  platformVersion?: string;
}
export declare const DeviceCgroupPermission: {
  readonly MKNOD: "MKNOD";
  readonly READ: "READ";
  readonly WRITE: "WRITE";
};
export type DeviceCgroupPermission =
  (typeof DeviceCgroupPermission)[keyof typeof DeviceCgroupPermission];
export interface Device {
  hostPath: string | undefined;
  containerPath?: string;
  permissions?: DeviceCgroupPermission[];
}
export interface Tmpfs {
  containerPath: string | undefined;
  size: number | undefined;
  mountOptions?: string[];
}
export interface LinuxParameters {
  devices?: Device[];
  initProcessEnabled?: boolean;
  sharedMemorySize?: number;
  tmpfs?: Tmpfs[];
  maxSwap?: number;
  swappiness?: number;
}
export declare const LogDriver: {
  readonly AWSLOGS: "awslogs";
  readonly FLUENTD: "fluentd";
  readonly GELF: "gelf";
  readonly JOURNALD: "journald";
  readonly JSON_FILE: "json-file";
  readonly SPLUNK: "splunk";
  readonly SYSLOG: "syslog";
};
export type LogDriver = (typeof LogDriver)[keyof typeof LogDriver];
export interface Secret {
  name: string | undefined;
  valueFrom: string | undefined;
}
export interface LogConfiguration {
  logDriver: LogDriver | undefined;
  options?: Record<string, string>;
  secretOptions?: Secret[];
}
export interface MountPoint {
  containerPath?: string;
  readOnly?: boolean;
  sourceVolume?: string;
}
export interface NetworkConfiguration {
  assignPublicIp?: AssignPublicIp;
}
export interface RepositoryCredentials {
  credentialsParameter: string | undefined;
}
export declare const ResourceType: {
  readonly GPU: "GPU";
  readonly MEMORY: "MEMORY";
  readonly VCPU: "VCPU";
};
export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType];
export interface ResourceRequirement {
  value: string | undefined;
  type: ResourceType | undefined;
}
export interface RuntimePlatform {
  operatingSystemFamily?: string;
  cpuArchitecture?: string;
}
export interface Ulimit {
  hardLimit: number | undefined;
  name: string | undefined;
  softLimit: number | undefined;
}
export declare const EFSAuthorizationConfigIAM: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type EFSAuthorizationConfigIAM =
  (typeof EFSAuthorizationConfigIAM)[keyof typeof EFSAuthorizationConfigIAM];
export interface EFSAuthorizationConfig {
  accessPointId?: string;
  iam?: EFSAuthorizationConfigIAM;
}
export declare const EFSTransitEncryption: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type EFSTransitEncryption =
  (typeof EFSTransitEncryption)[keyof typeof EFSTransitEncryption];
export interface EFSVolumeConfiguration {
  fileSystemId: string | undefined;
  rootDirectory?: string;
  transitEncryption?: EFSTransitEncryption;
  transitEncryptionPort?: number;
  authorizationConfig?: EFSAuthorizationConfig;
}
export interface Host {
  sourcePath?: string;
}
export interface Volume {
  host?: Host;
  name?: string;
  efsVolumeConfiguration?: EFSVolumeConfiguration;
}
export interface ContainerProperties {
  image?: string;
  vcpus?: number;
  memory?: number;
  command?: string[];
  jobRoleArn?: string;
  executionRoleArn?: string;
  volumes?: Volume[];
  environment?: KeyValuePair[];
  mountPoints?: MountPoint[];
  readonlyRootFilesystem?: boolean;
  privileged?: boolean;
  ulimits?: Ulimit[];
  user?: string;
  instanceType?: string;
  resourceRequirements?: ResourceRequirement[];
  linuxParameters?: LinuxParameters;
  logConfiguration?: LogConfiguration;
  secrets?: Secret[];
  networkConfiguration?: NetworkConfiguration;
  fargatePlatformConfiguration?: FargatePlatformConfiguration;
  ephemeralStorage?: EphemeralStorage;
  runtimePlatform?: RuntimePlatform;
  repositoryCredentials?: RepositoryCredentials;
}
export interface TaskContainerDependency {
  containerName?: string;
  condition?: string;
}
export interface TaskContainerProperties {
  command?: string[];
  dependsOn?: TaskContainerDependency[];
  environment?: KeyValuePair[];
  essential?: boolean;
  image: string | undefined;
  linuxParameters?: LinuxParameters;
  logConfiguration?: LogConfiguration;
  mountPoints?: MountPoint[];
  name?: string;
  privileged?: boolean;
  readonlyRootFilesystem?: boolean;
  repositoryCredentials?: RepositoryCredentials;
  resourceRequirements?: ResourceRequirement[];
  secrets?: Secret[];
  ulimits?: Ulimit[];
  user?: string;
}
export interface EcsTaskProperties {
  containers: TaskContainerProperties[] | undefined;
  ephemeralStorage?: EphemeralStorage;
  executionRoleArn?: string;
  platformVersion?: string;
  ipcMode?: string;
  taskRoleArn?: string;
  pidMode?: string;
  networkConfiguration?: NetworkConfiguration;
  runtimePlatform?: RuntimePlatform;
  volumes?: Volume[];
}
export interface EcsProperties {
  taskProperties: EcsTaskProperties[] | undefined;
}
export interface EksContainerEnvironmentVariable {
  name: string | undefined;
  value?: string;
}
export interface EksContainerResourceRequirements {
  limits?: Record<string, string>;
  requests?: Record<string, string>;
}
export interface EksContainerSecurityContext {
  runAsUser?: number;
  runAsGroup?: number;
  privileged?: boolean;
  allowPrivilegeEscalation?: boolean;
  readOnlyRootFilesystem?: boolean;
  runAsNonRoot?: boolean;
}
export interface EksContainerVolumeMount {
  name?: string;
  mountPath?: string;
  readOnly?: boolean;
}
export interface EksContainer {
  name?: string;
  image: string | undefined;
  imagePullPolicy?: string;
  command?: string[];
  args?: string[];
  env?: EksContainerEnvironmentVariable[];
  resources?: EksContainerResourceRequirements;
  volumeMounts?: EksContainerVolumeMount[];
  securityContext?: EksContainerSecurityContext;
}
export interface ImagePullSecret {
  name: string | undefined;
}
export interface EksMetadata {
  labels?: Record<string, string>;
}
export interface EksEmptyDir {
  medium?: string;
  sizeLimit?: string;
}
export interface EksHostPath {
  path?: string;
}
export interface EksSecret {
  secretName: string | undefined;
  optional?: boolean;
}
export interface EksVolume {
  name: string | undefined;
  hostPath?: EksHostPath;
  emptyDir?: EksEmptyDir;
  secret?: EksSecret;
}
export interface EksPodProperties {
  serviceAccountName?: string;
  hostNetwork?: boolean;
  dnsPolicy?: string;
  imagePullSecrets?: ImagePullSecret[];
  containers?: EksContainer[];
  initContainers?: EksContainer[];
  volumes?: EksVolume[];
  metadata?: EksMetadata;
  shareProcessNamespace?: boolean;
}
export interface EksProperties {
  podProperties?: EksPodProperties;
}
export interface NodeRangeProperty {
  targetNodes: string | undefined;
  container?: ContainerProperties;
  instanceTypes?: string[];
  ecsProperties?: EcsProperties;
}
export interface NodeProperties {
  numNodes: number | undefined;
  mainNode: number | undefined;
  nodeRangeProperties: NodeRangeProperty[] | undefined;
}
export declare const PlatformCapability: {
  readonly EC2: "EC2";
  readonly FARGATE: "FARGATE";
};
export type PlatformCapability =
  (typeof PlatformCapability)[keyof typeof PlatformCapability];
export declare const RetryAction: {
  readonly EXIT: "EXIT";
  readonly RETRY: "RETRY";
};
export type RetryAction = (typeof RetryAction)[keyof typeof RetryAction];
export interface EvaluateOnExit {
  onStatusReason?: string;
  onReason?: string;
  onExitCode?: string;
  action: RetryAction | undefined;
}
export interface RetryStrategy {
  attempts?: number;
  evaluateOnExit?: EvaluateOnExit[];
}
export interface JobTimeout {
  attemptDurationSeconds?: number;
}
export interface JobDefinition {
  jobDefinitionName: string | undefined;
  jobDefinitionArn: string | undefined;
  revision: number | undefined;
  status?: string;
  type: string | undefined;
  schedulingPriority?: number;
  parameters?: Record<string, string>;
  retryStrategy?: RetryStrategy;
  containerProperties?: ContainerProperties;
  timeout?: JobTimeout;
  nodeProperties?: NodeProperties;
  tags?: Record<string, string>;
  propagateTags?: boolean;
  platformCapabilities?: PlatformCapability[];
  ecsProperties?: EcsProperties;
  eksProperties?: EksProperties;
  containerOrchestrationType?: OrchestrationType;
}
export interface DescribeJobDefinitionsResponse {
  jobDefinitions?: JobDefinition[];
  nextToken?: string;
}
export interface DescribeJobQueuesRequest {
  jobQueues?: string[];
  maxResults?: number;
  nextToken?: string;
}
export declare const JQStatus: {
  readonly CREATING: "CREATING";
  readonly DELETED: "DELETED";
  readonly DELETING: "DELETING";
  readonly INVALID: "INVALID";
  readonly UPDATING: "UPDATING";
  readonly VALID: "VALID";
};
export type JQStatus = (typeof JQStatus)[keyof typeof JQStatus];
export interface JobQueueDetail {
  jobQueueName: string | undefined;
  jobQueueArn: string | undefined;
  state: JQState | undefined;
  schedulingPolicyArn?: string;
  status?: JQStatus;
  statusReason?: string;
  priority: number | undefined;
  computeEnvironmentOrder: ComputeEnvironmentOrder[] | undefined;
  tags?: Record<string, string>;
  jobStateTimeLimitActions?: JobStateTimeLimitAction[];
}
export interface DescribeJobQueuesResponse {
  jobQueues?: JobQueueDetail[];
  nextToken?: string;
}
export interface DescribeJobsRequest {
  jobs: string[] | undefined;
}
export interface ContainerDetail {
  image?: string;
  vcpus?: number;
  memory?: number;
  command?: string[];
  jobRoleArn?: string;
  executionRoleArn?: string;
  volumes?: Volume[];
  environment?: KeyValuePair[];
  mountPoints?: MountPoint[];
  readonlyRootFilesystem?: boolean;
  ulimits?: Ulimit[];
  privileged?: boolean;
  user?: string;
  exitCode?: number;
  reason?: string;
  containerInstanceArn?: string;
  taskArn?: string;
  logStreamName?: string;
  instanceType?: string;
  networkInterfaces?: NetworkInterface[];
  resourceRequirements?: ResourceRequirement[];
  linuxParameters?: LinuxParameters;
  logConfiguration?: LogConfiguration;
  secrets?: Secret[];
  networkConfiguration?: NetworkConfiguration;
  fargatePlatformConfiguration?: FargatePlatformConfiguration;
  ephemeralStorage?: EphemeralStorage;
  runtimePlatform?: RuntimePlatform;
  repositoryCredentials?: RepositoryCredentials;
}
export interface JobDependency {
  jobId?: string;
  type?: ArrayJobDependency;
}
export interface TaskContainerDetails {
  command?: string[];
  dependsOn?: TaskContainerDependency[];
  environment?: KeyValuePair[];
  essential?: boolean;
  image?: string;
  linuxParameters?: LinuxParameters;
  logConfiguration?: LogConfiguration;
  mountPoints?: MountPoint[];
  name?: string;
  privileged?: boolean;
  readonlyRootFilesystem?: boolean;
  repositoryCredentials?: RepositoryCredentials;
  resourceRequirements?: ResourceRequirement[];
  secrets?: Secret[];
  ulimits?: Ulimit[];
  user?: string;
  exitCode?: number;
  reason?: string;
  logStreamName?: string;
  networkInterfaces?: NetworkInterface[];
}
export interface EcsTaskDetails {
  containers?: TaskContainerDetails[];
  containerInstanceArn?: string;
  taskArn?: string;
  ephemeralStorage?: EphemeralStorage;
  executionRoleArn?: string;
  platformVersion?: string;
  ipcMode?: string;
  taskRoleArn?: string;
  pidMode?: string;
  networkConfiguration?: NetworkConfiguration;
  runtimePlatform?: RuntimePlatform;
  volumes?: Volume[];
}
export interface EcsPropertiesDetail {
  taskProperties?: EcsTaskDetails[];
}
export interface EksAttemptContainerDetail {
  name?: string;
  exitCode?: number;
  reason?: string;
}
export interface EksAttemptDetail {
  containers?: EksAttemptContainerDetail[];
  initContainers?: EksAttemptContainerDetail[];
  podName?: string;
  nodeName?: string;
  startedAt?: number;
  stoppedAt?: number;
  statusReason?: string;
}
export interface EksContainerDetail {
  name?: string;
  image?: string;
  imagePullPolicy?: string;
  command?: string[];
  args?: string[];
  env?: EksContainerEnvironmentVariable[];
  resources?: EksContainerResourceRequirements;
  exitCode?: number;
  reason?: string;
  volumeMounts?: EksContainerVolumeMount[];
  securityContext?: EksContainerSecurityContext;
}
export interface EksPodPropertiesDetail {
  serviceAccountName?: string;
  hostNetwork?: boolean;
  dnsPolicy?: string;
  imagePullSecrets?: ImagePullSecret[];
  containers?: EksContainerDetail[];
  initContainers?: EksContainerDetail[];
  volumes?: EksVolume[];
  podName?: string;
  nodeName?: string;
  metadata?: EksMetadata;
  shareProcessNamespace?: boolean;
}
export interface EksPropertiesDetail {
  podProperties?: EksPodPropertiesDetail;
}
export interface NodeDetails {
  nodeIndex?: number;
  isMainNode?: boolean;
}
export declare const JobStatus: {
  readonly FAILED: "FAILED";
  readonly PENDING: "PENDING";
  readonly RUNNABLE: "RUNNABLE";
  readonly RUNNING: "RUNNING";
  readonly STARTING: "STARTING";
  readonly SUBMITTED: "SUBMITTED";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus];
export interface JobDetail {
  jobArn?: string;
  jobName: string | undefined;
  jobId: string | undefined;
  jobQueue: string | undefined;
  status: JobStatus | undefined;
  shareIdentifier?: string;
  schedulingPriority?: number;
  attempts?: AttemptDetail[];
  statusReason?: string;
  createdAt?: number;
  retryStrategy?: RetryStrategy;
  startedAt: number | undefined;
  stoppedAt?: number;
  dependsOn?: JobDependency[];
  jobDefinition: string | undefined;
  parameters?: Record<string, string>;
  container?: ContainerDetail;
  nodeDetails?: NodeDetails;
  nodeProperties?: NodeProperties;
  arrayProperties?: ArrayPropertiesDetail;
  timeout?: JobTimeout;
  tags?: Record<string, string>;
  propagateTags?: boolean;
  platformCapabilities?: PlatformCapability[];
  eksProperties?: EksPropertiesDetail;
  eksAttempts?: EksAttemptDetail[];
  ecsProperties?: EcsPropertiesDetail;
  isCancelled?: boolean;
  isTerminated?: boolean;
}
export interface DescribeJobsResponse {
  jobs?: JobDetail[];
}
export interface DescribeSchedulingPoliciesRequest {
  arns: string[] | undefined;
}
export interface SchedulingPolicyDetail {
  name: string | undefined;
  arn: string | undefined;
  fairsharePolicy?: FairsharePolicy;
  tags?: Record<string, string>;
}
export interface DescribeSchedulingPoliciesResponse {
  schedulingPolicies?: SchedulingPolicyDetail[];
}
export interface KeyValuesPair {
  name?: string;
  values?: string[];
}
export interface ListJobsRequest {
  jobQueue?: string;
  arrayJobId?: string;
  multiNodeJobId?: string;
  jobStatus?: JobStatus;
  maxResults?: number;
  nextToken?: string;
  filters?: KeyValuesPair[];
}
export interface ContainerSummary {
  exitCode?: number;
  reason?: string;
}
export interface NodePropertiesSummary {
  isMainNode?: boolean;
  numNodes?: number;
  nodeIndex?: number;
}
export interface JobSummary {
  jobArn?: string;
  jobId: string | undefined;
  jobName: string | undefined;
  createdAt?: number;
  status?: JobStatus;
  statusReason?: string;
  startedAt?: number;
  stoppedAt?: number;
  container?: ContainerSummary;
  arrayProperties?: ArrayPropertiesSummary;
  nodeProperties?: NodePropertiesSummary;
  jobDefinition?: string;
}
export interface ListJobsResponse {
  jobSummaryList: JobSummary[] | undefined;
  nextToken?: string;
}
export interface ListSchedulingPoliciesRequest {
  maxResults?: number;
  nextToken?: string;
}
export interface SchedulingPolicyListingDetail {
  arn: string | undefined;
}
export interface ListSchedulingPoliciesResponse {
  schedulingPolicies?: SchedulingPolicyListingDetail[];
  nextToken?: string;
}
export interface ListTagsForResourceRequest {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  tags?: Record<string, string>;
}
export declare const JobDefinitionType: {
  readonly Container: "container";
  readonly Multinode: "multinode";
};
export type JobDefinitionType =
  (typeof JobDefinitionType)[keyof typeof JobDefinitionType];
export interface RegisterJobDefinitionRequest {
  jobDefinitionName: string | undefined;
  type: JobDefinitionType | undefined;
  parameters?: Record<string, string>;
  schedulingPriority?: number;
  containerProperties?: ContainerProperties;
  nodeProperties?: NodeProperties;
  retryStrategy?: RetryStrategy;
  propagateTags?: boolean;
  timeout?: JobTimeout;
  tags?: Record<string, string>;
  platformCapabilities?: PlatformCapability[];
  eksProperties?: EksProperties;
  ecsProperties?: EcsProperties;
}
export interface RegisterJobDefinitionResponse {
  jobDefinitionName: string | undefined;
  jobDefinitionArn: string | undefined;
  revision: number | undefined;
}
export interface ContainerOverrides {
  vcpus?: number;
  memory?: number;
  command?: string[];
  instanceType?: string;
  environment?: KeyValuePair[];
  resourceRequirements?: ResourceRequirement[];
}
export interface TaskContainerOverrides {
  command?: string[];
  environment?: KeyValuePair[];
  name?: string;
  resourceRequirements?: ResourceRequirement[];
}
export interface TaskPropertiesOverride {
  containers?: TaskContainerOverrides[];
}
export interface EcsPropertiesOverride {
  taskProperties?: TaskPropertiesOverride[];
}
export interface EksContainerOverride {
  name?: string;
  image?: string;
  command?: string[];
  args?: string[];
  env?: EksContainerEnvironmentVariable[];
  resources?: EksContainerResourceRequirements;
}
export interface EksPodPropertiesOverride {
  containers?: EksContainerOverride[];
  initContainers?: EksContainerOverride[];
  metadata?: EksMetadata;
}
export interface EksPropertiesOverride {
  podProperties?: EksPodPropertiesOverride;
}
export interface NodePropertyOverride {
  targetNodes: string | undefined;
  containerOverrides?: ContainerOverrides;
  ecsPropertiesOverride?: EcsPropertiesOverride;
  instanceTypes?: string[];
}
export interface NodeOverrides {
  numNodes?: number;
  nodePropertyOverrides?: NodePropertyOverride[];
}
export interface SubmitJobRequest {
  jobName: string | undefined;
  jobQueue: string | undefined;
  shareIdentifier?: string;
  schedulingPriorityOverride?: number;
  arrayProperties?: ArrayProperties;
  dependsOn?: JobDependency[];
  jobDefinition: string | undefined;
  parameters?: Record<string, string>;
  containerOverrides?: ContainerOverrides;
  nodeOverrides?: NodeOverrides;
  retryStrategy?: RetryStrategy;
  propagateTags?: boolean;
  timeout?: JobTimeout;
  tags?: Record<string, string>;
  eksPropertiesOverride?: EksPropertiesOverride;
  ecsPropertiesOverride?: EcsPropertiesOverride;
}
export interface SubmitJobResponse {
  jobArn?: string;
  jobName: string | undefined;
  jobId: string | undefined;
}
export interface TagResourceRequest {
  resourceArn: string | undefined;
  tags: Record<string, string> | undefined;
}
export interface TagResourceResponse {}
export interface TerminateJobRequest {
  jobId: string | undefined;
  reason: string | undefined;
}
export interface TerminateJobResponse {}
export interface UntagResourceRequest {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface UntagResourceResponse {}
export declare const CRUpdateAllocationStrategy: {
  readonly BEST_FIT_PROGRESSIVE: "BEST_FIT_PROGRESSIVE";
  readonly SPOT_CAPACITY_OPTIMIZED: "SPOT_CAPACITY_OPTIMIZED";
  readonly SPOT_PRICE_CAPACITY_OPTIMIZED: "SPOT_PRICE_CAPACITY_OPTIMIZED";
};
export type CRUpdateAllocationStrategy =
  (typeof CRUpdateAllocationStrategy)[keyof typeof CRUpdateAllocationStrategy];
export interface ComputeResourceUpdate {
  minvCpus?: number;
  maxvCpus?: number;
  desiredvCpus?: number;
  subnets?: string[];
  securityGroupIds?: string[];
  allocationStrategy?: CRUpdateAllocationStrategy;
  instanceTypes?: string[];
  ec2KeyPair?: string;
  instanceRole?: string;
  tags?: Record<string, string>;
  placementGroup?: string;
  bidPercentage?: number;
  launchTemplate?: LaunchTemplateSpecification;
  ec2Configuration?: Ec2Configuration[];
  updateToLatestImageVersion?: boolean;
  type?: CRType;
  imageId?: string;
}
export interface UpdateComputeEnvironmentRequest {
  computeEnvironment: string | undefined;
  state?: CEState;
  unmanagedvCpus?: number;
  computeResources?: ComputeResourceUpdate;
  serviceRole?: string;
  updatePolicy?: UpdatePolicy;
}
export interface UpdateComputeEnvironmentResponse {
  computeEnvironmentName?: string;
  computeEnvironmentArn?: string;
}
export interface UpdateJobQueueRequest {
  jobQueue: string | undefined;
  state?: JQState;
  schedulingPolicyArn?: string;
  priority?: number;
  computeEnvironmentOrder?: ComputeEnvironmentOrder[];
  jobStateTimeLimitActions?: JobStateTimeLimitAction[];
}
export interface UpdateJobQueueResponse {
  jobQueueName?: string;
  jobQueueArn?: string;
}
export interface UpdateSchedulingPolicyRequest {
  arn: string | undefined;
  fairsharePolicy?: FairsharePolicy;
}
export interface UpdateSchedulingPolicyResponse {}
