import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

/**
 * Defines values for ActionType. \
 * {@link KnownActionType} can be used interchangeably with ActionType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Allow** \
 * **Block** \
 * **Log** \
 * **Redirect** \
 * **AnomalyScoring** \
 * **JSChallenge**
 */
export declare type ActionType = string;

/**
 * Defines values for AggregationInterval. \
 * {@link KnownAggregationInterval} can be used interchangeably with AggregationInterval,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Hourly** \
 * **Daily**
 */
export declare type AggregationInterval = string;

/**
 * Defines values for Availability. \
 * {@link KnownAvailability} can be used interchangeably with Availability,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Available** \
 * **Unavailable**
 */
export declare type Availability = string;

/** The response body contains the status of the specified asynchronous operation, indicating whether it has succeeded, is in progress, or has failed. Note that this status is distinct from the HTTP status code returned for the Get Operation Status operation itself. If the asynchronous operation succeeded, the response body includes the HTTP status code for the successful request. If the asynchronous operation failed, the response body includes the HTTP status code for the failed request and error information regarding the failure. */
export declare interface AzureAsyncOperationResult {
    /** Status of the Azure async operation. */
    status?: NetworkOperationStatus;
    error?: ErrorModel;
}

/** Backend address of a frontDoor load balancer. */
export declare interface Backend {
    /** Location of the backend (IP address or FQDN) */
    address?: string;
    /** The Alias of the Private Link resource. Populating this optional field indicates that this backend is 'Private' */
    privateLinkAlias?: string;
    /** The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private' */
    privateLinkResourceId?: string;
    /** The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated */
    privateLinkLocation?: string;
    /**
     * The Approval status for the connection to the Private Link
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly privateEndpointStatus?: PrivateEndpointStatus;
    /** A custom message to be included in the approval request to connect to the Private Link */
    privateLinkApprovalMessage?: string;
    /** The HTTP TCP port number. Must be between 1 and 65535. */
    httpPort?: number;
    /** The HTTPS TCP port number. Must be between 1 and 65535. */
    httpsPort?: number;
    /** Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled' */
    enabledState?: BackendEnabledState;
    /** Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy. */
    priority?: number;
    /** Weight of this endpoint for load balancing purposes. */
    weight?: number;
    /** The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host. */
    backendHostHeader?: string;
}

/**
 * Defines values for BackendEnabledState. \
 * {@link KnownBackendEnabledState} can be used interchangeably with BackendEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export declare type BackendEnabledState = string;

/** A backend pool is a collection of backends that can be routed to. */
export declare interface BackendPool extends SubResource {
    /** Resource name. */
    name?: string;
    /**
     * Resource type.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** The set of backends for this pool */
    backends?: Backend[];
    /** Load balancing settings for a backend pool */
    loadBalancingSettings?: SubResource;
    /** L7 health probe settings for a backend pool */
    healthProbeSettings?: SubResource;
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
}

/** Result of the request to list Backend Pools. It contains a list of Backend Pools objects and a URL link to get the next set of results. */
export declare interface BackendPoolListResult {
    /**
     * List of Backend Pools within a Front Door.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: BackendPool[];
    /** URL to get the next set of BackendPool objects if there are any. */
    nextLink?: string;
}

/** The JSON object that contains the properties required to create a Backend Pool. */
export declare interface BackendPoolProperties extends BackendPoolUpdateParameters {
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
}

/** Settings that apply to all backend pools. */
export declare interface BackendPoolsSettings {
    /** Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests. */
    enforceCertificateNameCheck?: EnforceCertificateNameCheckEnabledState;
    /** Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns. */
    sendRecvTimeoutSeconds?: number;
}

/** A collection of backends that can be routed to. */
export declare interface BackendPoolUpdateParameters {
    /** The set of backends for this pool */
    backends?: Backend[];
    /** Load balancing settings for a backend pool */
    loadBalancingSettings?: SubResource;
    /** L7 health probe settings for a backend pool */
    healthProbeSettings?: SubResource;
}

/** Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object. */
export declare interface CacheConfiguration {
    /** Treatment of URL query terms when forming the cache key. */
    queryParameterStripDirective?: FrontDoorQuery;
    /** query parameters to include or exclude (comma separated). */
    queryParameters?: string;
    /** Whether to use dynamic compression for cached content */
    dynamicCompression?: DynamicCompressionEnabled;
    /** The duration for which the content needs to be cached. Allowed format is in ISO 8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations). HTTP requires the value to be no more than a year */
    cacheDuration?: string;
}

/** Input of CheckNameAvailability API. */
export declare interface CheckNameAvailabilityInput {
    /** The resource name to validate. */
    name: string;
    /** The type of the resource whose name is to be validated. */
    type: ResourceType;
}

/** Output of check name availability API. */
export declare interface CheckNameAvailabilityOutput {
    /**
     * Indicates whether the name is available.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly nameAvailability?: Availability;
    /**
     * The reason why the name is not available.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly reason?: string;
    /**
     * The detailed error message describing why the name is not available.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
}

/** Https settings for a domain */
export declare interface CustomHttpsConfiguration {
    /** Defines the source of the SSL certificate */
    certificateSource: FrontDoorCertificateSource;
    /** Defines the TLS extension protocol that is used for secure delivery */
    protocolType: FrontDoorTlsProtocolType;
    /** The minimum TLS version required from the clients to establish an SSL handshake with Front Door. */
    minimumTlsVersion: MinimumTLSVersion;
    /** Defines the type of the certificate used for secure connections to a frontendEndpoint */
    certificateType?: FrontDoorCertificateType;
    /** The Key Vault containing the SSL certificate */
    vault?: KeyVaultCertificateSourceParametersVault;
    /** The name of the Key Vault secret representing the full certificate PFX */
    secretName?: string;
    /** The version of the Key Vault secret representing the full certificate PFX */
    secretVersion?: string;
}

/**
 * Defines values for CustomHttpsProvisioningState. \
 * {@link KnownCustomHttpsProvisioningState} can be used interchangeably with CustomHttpsProvisioningState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabling** \
 * **Enabled** \
 * **Disabling** \
 * **Disabled** \
 * **Failed**
 */
export declare type CustomHttpsProvisioningState = string;

/**
 * Defines values for CustomHttpsProvisioningSubstate. \
 * {@link KnownCustomHttpsProvisioningSubstate} can be used interchangeably with CustomHttpsProvisioningSubstate,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **SubmittingDomainControlValidationRequest** \
 * **PendingDomainControlValidationREquestApproval** \
 * **DomainControlValidationRequestApproved** \
 * **DomainControlValidationRequestRejected** \
 * **DomainControlValidationRequestTimedOut** \
 * **IssuingCertificate** \
 * **DeployingCertificate** \
 * **CertificateDeployed** \
 * **DeletingCertificate** \
 * **CertificateDeleted**
 */
export declare type CustomHttpsProvisioningSubstate = string;

/** Defines contents of a web application rule */
export declare interface CustomRule {
    /** Describes the name of the rule. */
    name?: string;
    /** Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. */
    priority: number;
    /** Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified. */
    enabledState?: CustomRuleEnabledState;
    /** Describes type of rule. */
    ruleType: RuleType;
    /** Time window for resetting the rate limit count. Default is 1 minute. */
    rateLimitDurationInMinutes?: number;
    /** Number of allowed requests per client within the time window. */
    rateLimitThreshold?: number;
    /** Describes the list of variables to group the rate limit requests */
    groupBy?: GroupByVariable[];
    /** List of match conditions. */
    matchConditions: MatchCondition[];
    /** Describes what action to be applied when rule matches. */
    action: ActionType;
}

/**
 * Defines values for CustomRuleEnabledState. \
 * {@link KnownCustomRuleEnabledState} can be used interchangeably with CustomRuleEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Disabled** \
 * **Enabled**
 */
export declare type CustomRuleEnabledState = string;

/** Defines contents of custom rules */
export declare interface CustomRuleList {
    /** List of rules */
    rules?: CustomRule[];
}

/** Error response indicates Front Door service is not able to process the incoming request. The reason is provided in the error message. */
export declare interface DefaultErrorResponse {
    /** Error model. */
    error?: DefaultErrorResponseError;
}

/** Error model. */
export declare interface DefaultErrorResponseError {
    /**
     * Error code.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly code?: string;
    /**
     * Error message indicating why the operation failed.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
}

/**
 * Defines values for DynamicCompressionEnabled. \
 * {@link KnownDynamicCompressionEnabled} can be used interchangeably with DynamicCompressionEnabled,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export declare type DynamicCompressionEnabled = string;

/** Defines the endpoint properties */
export declare interface Endpoint {
    /** The name of the endpoint */
    name?: string;
    /** The endpoint URL */
    endpoint?: string;
}

/** Interface representing a Endpoints. */
export declare interface Endpoints {
    /**
     * Removes a content from Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param contentFilePaths The path to the content to be purged. Path can be a full URL, e.g.
     *                         '/pictures/city.png' which removes a single file, or a directory with a wildcard, e.g. '/pictures/*'
     *                         which removes all folders and files in the directory.
     * @param options The options parameters.
     */
    beginPurgeContent(resourceGroupName: string, frontDoorName: string, contentFilePaths: PurgeParameters, options?: EndpointsPurgeContentOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Removes a content from Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param contentFilePaths The path to the content to be purged. Path can be a full URL, e.g.
     *                         '/pictures/city.png' which removes a single file, or a directory with a wildcard, e.g. '/pictures/*'
     *                         which removes all folders and files in the directory.
     * @param options The options parameters.
     */
    beginPurgeContentAndWait(resourceGroupName: string, frontDoorName: string, contentFilePaths: PurgeParameters, options?: EndpointsPurgeContentOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface EndpointsPurgeContentOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/**
 * Defines values for EndpointType. \
 * {@link KnownEndpointType} can be used interchangeably with EndpointType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **AFD** \
 * **AzureRegion** \
 * **CDN** \
 * **ATM**
 */
export declare type EndpointType = string;

/**
 * Defines values for EnforceCertificateNameCheckEnabledState. \
 * {@link KnownEnforceCertificateNameCheckEnabledState} can be used interchangeably with EnforceCertificateNameCheckEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export declare type EnforceCertificateNameCheckEnabledState = string;

export declare interface ErrorDetails {
    code?: string;
    target?: string;
    message?: string;
}

export declare interface ErrorModel {
    code?: string;
    message?: string;
    target?: string;
    details?: ErrorDetails[];
    innerError?: string;
}

/** Error response indicates Front Door service is not able to process the incoming request. The reason is provided in the error message. */
export declare interface ErrorResponse {
    /**
     * Error code.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly code?: string;
    /**
     * Error message indicating why the operation failed.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
}

/** Defines the properties of an Experiment */
export declare interface Experiment extends Resource {
    /** The description of the details or intents of the Experiment */
    description?: string;
    /** The endpoint A of an experiment */
    endpointA?: Endpoint;
    /** The endpoint B of an experiment */
    endpointB?: Endpoint;
    /** The state of the Experiment */
    enabledState?: State;
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: NetworkExperimentResourceState;
    /**
     * The description of Experiment status from the server side
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly status?: string;
    /**
     * The uri to the Script used in the Experiment
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly scriptFileUri?: string;
}

/** Defines a list of Experiments. It contains a list of Experiment objects and a URL link to get the next set of results. */
export declare interface ExperimentList {
    /**
     * List of Experiments within a resource group.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: Experiment[];
    /** URL to get the next set of Experiment objects if there are any. */
    nextLink?: string;
}

/** Interface representing a Experiments. */
export declare interface Experiments {
    /**
     * Gets a list of Experiments
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    listByProfile(resourceGroupName: string, profileName: string, options?: ExperimentsListByProfileOptionalParams): PagedAsyncIterableIterator<Experiment>;
    /**
     * Gets an Experiment by ExperimentName
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param options The options parameters.
     */
    get(resourceGroupName: string, profileName: string, experimentName: string, options?: ExperimentsGetOptionalParams): Promise<ExperimentsGetResponse>;
    /**
     * Creates or updates an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param parameters The Experiment resource
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName: string, profileName: string, experimentName: string, parameters: Experiment, options?: ExperimentsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ExperimentsCreateOrUpdateResponse>, ExperimentsCreateOrUpdateResponse>>;
    /**
     * Creates or updates an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param parameters The Experiment resource
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName: string, profileName: string, experimentName: string, parameters: Experiment, options?: ExperimentsCreateOrUpdateOptionalParams): Promise<ExperimentsCreateOrUpdateResponse>;
    /**
     * Updates an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param parameters The Experiment Update Model
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, profileName: string, experimentName: string, parameters: ExperimentUpdateModel, options?: ExperimentsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ExperimentsUpdateResponse>, ExperimentsUpdateResponse>>;
    /**
     * Updates an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param parameters The Experiment Update Model
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, profileName: string, experimentName: string, parameters: ExperimentUpdateModel, options?: ExperimentsUpdateOptionalParams): Promise<ExperimentsUpdateResponse>;
    /**
     * Deletes an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, profileName: string, experimentName: string, options?: ExperimentsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Deletes an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, profileName: string, experimentName: string, options?: ExperimentsDeleteOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface ExperimentsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export declare type ExperimentsCreateOrUpdateResponse = Experiment;

/** Optional parameters. */
export declare interface ExperimentsDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface ExperimentsGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type ExperimentsGetResponse = Experiment;

/** Optional parameters. */
export declare interface ExperimentsListByProfileNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByProfileNext operation. */
export declare type ExperimentsListByProfileNextResponse = ExperimentList;

/** Optional parameters. */
export declare interface ExperimentsListByProfileOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByProfile operation. */
export declare type ExperimentsListByProfileResponse = ExperimentList;

/** Optional parameters. */
export declare interface ExperimentsUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type ExperimentsUpdateResponse = Experiment;

/** Defines modifiable attributes of an Experiment */
export declare interface ExperimentUpdateModel {
    /** Resource tags. */
    tags?: {
        [propertyName: string]: string;
    };
    /** The description of the intent or details of the Experiment */
    description?: string;
    /** The state of the Experiment */
    enabledState?: State;
}

/** Describes Forwarding Route. */
export declare interface ForwardingConfiguration extends RouteConfiguration {
    /** Polymorphic discriminator, which specifies the different types this object can be */
    odataType: "#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration";
    /** A custom path used to rewrite resource paths matched by this rule. Leave empty to use incoming path. */
    customForwardingPath?: string;
    /** Protocol this rule will use when forwarding traffic to backends. */
    forwardingProtocol?: FrontDoorForwardingProtocol;
    /** The caching configuration associated with this rule. */
    cacheConfiguration?: CacheConfiguration;
    /** A reference to the BackendPool which this rule routes to. */
    backendPool?: SubResource;
}

/** Front Door represents a collection of backend endpoints to route traffic to along with rules that specify how traffic is sent there. */
export declare interface FrontDoor extends Resource {
    /** A friendly name for the frontDoor */
    friendlyName?: string;
    /** Routing rules associated with this Front Door. */
    routingRules?: RoutingRule[];
    /** Load balancing settings associated with this Front Door instance. */
    loadBalancingSettings?: LoadBalancingSettingsModel[];
    /** Health probe settings associated with this Front Door instance. */
    healthProbeSettings?: HealthProbeSettingsModel[];
    /** Backend pools available to routing rules. */
    backendPools?: BackendPool[];
    /** Frontend endpoints available to routing rules. */
    frontendEndpoints?: FrontendEndpoint[];
    /** Settings for all backendPools */
    backendPoolsSettings?: BackendPoolsSettings;
    /** Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled' */
    enabledState?: FrontDoorEnabledState;
    /**
     * Resource status of the Front Door.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
    /**
     * Provisioning state of the Front Door.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /**
     * The host that each frontendEndpoint must CNAME to.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly cname?: string;
    /**
     * The Id of the frontdoor.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly frontdoorId?: string;
    /**
     * Rules Engine Configurations available to routing rules.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly rulesEngines?: RulesEngine[];
    /**
     * Key-Value pair representing additional properties for frontdoor.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly extendedProperties?: {
        [propertyName: string]: string;
    };
}

/**
 * Defines values for FrontDoorCertificateSource. \
 * {@link KnownFrontDoorCertificateSource} can be used interchangeably with FrontDoorCertificateSource,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **AzureKeyVault** \
 * **FrontDoor**
 */
export declare type FrontDoorCertificateSource = string;

/**
 * Defines values for FrontDoorCertificateType. \
 * {@link KnownFrontDoorCertificateType} can be used interchangeably with FrontDoorCertificateType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Dedicated**
 */
export declare type FrontDoorCertificateType = string;

/**
 * Defines values for FrontDoorEnabledState. \
 * {@link KnownFrontDoorEnabledState} can be used interchangeably with FrontDoorEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export declare type FrontDoorEnabledState = string;

/**
 * Defines values for FrontDoorForwardingProtocol. \
 * {@link KnownFrontDoorForwardingProtocol} can be used interchangeably with FrontDoorForwardingProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **HttpOnly** \
 * **HttpsOnly** \
 * **MatchRequest**
 */
export declare type FrontDoorForwardingProtocol = string;

/**
 * Defines values for FrontDoorHealthProbeMethod. \
 * {@link KnownFrontDoorHealthProbeMethod} can be used interchangeably with FrontDoorHealthProbeMethod,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **GET** \
 * **HEAD**
 */
export declare type FrontDoorHealthProbeMethod = string;

/** Result of the request to list Front Doors. It contains a list of Front Door objects and a URL link to get the next set of results. */
export declare interface FrontDoorListResult {
    /**
     * List of Front Doors within a resource group.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: FrontDoor[];
    /** URL to get the next set of Front Door objects if there are any. */
    nextLink?: string;
}

export declare class FrontDoorManagementClient extends coreClient.ServiceClient {
    $host: string;
    subscriptionId?: string;
    /**
     * Initializes a new instance of the FrontDoorManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription credentials which uniquely identify the Microsoft Azure
     *                       subscription. The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: FrontDoorManagementClientOptionalParams);
    constructor(credentials: coreAuth.TokenCredential, options?: FrontDoorManagementClientOptionalParams);
    policies: Policies;
    managedRuleSets: ManagedRuleSets;
    frontDoorNameAvailability: FrontDoorNameAvailability;
    frontDoorNameAvailabilityWithSubscription: FrontDoorNameAvailabilityWithSubscription;
    frontDoors: FrontDoors;
    frontendEndpoints: FrontendEndpoints;
    endpoints: Endpoints;
    rulesEngines: RulesEngines;
    networkExperimentProfiles: NetworkExperimentProfiles;
    preconfiguredEndpoints: PreconfiguredEndpoints;
    experiments: Experiments;
    reports: Reports;
}

/** Optional parameters. */
export declare interface FrontDoorManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    /** server parameter */
    $host?: string;
    /** Overrides client endpoint. */
    endpoint?: string;
}

/** Interface representing a FrontDoorNameAvailability. */
export declare interface FrontDoorNameAvailability {
    /**
     * Check the availability of a Front Door resource name.
     * @param checkFrontDoorNameAvailabilityInput Input to check.
     * @param options The options parameters.
     */
    check(checkFrontDoorNameAvailabilityInput: CheckNameAvailabilityInput, options?: FrontDoorNameAvailabilityCheckOptionalParams): Promise<FrontDoorNameAvailabilityCheckResponse>;
}

/** Optional parameters. */
export declare interface FrontDoorNameAvailabilityCheckOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the check operation. */
export declare type FrontDoorNameAvailabilityCheckResponse = CheckNameAvailabilityOutput;

/** Interface representing a FrontDoorNameAvailabilityWithSubscription. */
export declare interface FrontDoorNameAvailabilityWithSubscription {
    /**
     * Check the availability of a Front Door subdomain.
     * @param checkFrontDoorNameAvailabilityInput Input to check.
     * @param options The options parameters.
     */
    check(checkFrontDoorNameAvailabilityInput: CheckNameAvailabilityInput, options?: FrontDoorNameAvailabilityWithSubscriptionCheckOptionalParams): Promise<FrontDoorNameAvailabilityWithSubscriptionCheckResponse>;
}

/** Optional parameters. */
export declare interface FrontDoorNameAvailabilityWithSubscriptionCheckOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the check operation. */
export declare type FrontDoorNameAvailabilityWithSubscriptionCheckResponse = CheckNameAvailabilityOutput;

/** The JSON object that contains the properties required to create an endpoint. */
export declare interface FrontDoorProperties extends FrontDoorUpdateParameters {
    /**
     * Resource status of the Front Door.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
    /**
     * Provisioning state of the Front Door.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /**
     * The host that each frontendEndpoint must CNAME to.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly cname?: string;
    /**
     * The Id of the frontdoor.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly frontdoorId?: string;
    /**
     * Rules Engine Configurations available to routing rules.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly rulesEngines?: RulesEngine[];
    /**
     * Key-Value pair representing additional properties for frontdoor.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly extendedProperties?: {
        [propertyName: string]: string;
    };
}

/**
 * Defines values for FrontDoorProtocol. \
 * {@link KnownFrontDoorProtocol} can be used interchangeably with FrontDoorProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Http** \
 * **Https**
 */
export declare type FrontDoorProtocol = string;

/**
 * Defines values for FrontDoorQuery. \
 * {@link KnownFrontDoorQuery} can be used interchangeably with FrontDoorQuery,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **StripNone** \
 * **StripAll** \
 * **StripOnly** \
 * **StripAllExcept**
 */
export declare type FrontDoorQuery = string;

/**
 * Defines values for FrontDoorRedirectProtocol. \
 * {@link KnownFrontDoorRedirectProtocol} can be used interchangeably with FrontDoorRedirectProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **HttpOnly** \
 * **HttpsOnly** \
 * **MatchRequest**
 */
export declare type FrontDoorRedirectProtocol = string;

/**
 * Defines values for FrontDoorRedirectType. \
 * {@link KnownFrontDoorRedirectType} can be used interchangeably with FrontDoorRedirectType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Moved** \
 * **Found** \
 * **TemporaryRedirect** \
 * **PermanentRedirect**
 */
export declare type FrontDoorRedirectType = string;

/**
 * Defines values for FrontDoorResourceState. \
 * {@link KnownFrontDoorResourceState} can be used interchangeably with FrontDoorResourceState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Creating** \
 * **Enabling** \
 * **Enabled** \
 * **Disabling** \
 * **Disabled** \
 * **Deleting** \
 * **Migrating** \
 * **Migrated**
 */
export declare type FrontDoorResourceState = string;

/** Interface representing a FrontDoors. */
export declare interface FrontDoors {
    /**
     * Lists all of the Front Doors within an Azure subscription.
     * @param options The options parameters.
     */
    list(options?: FrontDoorsListOptionalParams): PagedAsyncIterableIterator<FrontDoor>;
    /**
     * Lists all of the Front Doors within a resource group under a subscription.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName: string, options?: FrontDoorsListByResourceGroupOptionalParams): PagedAsyncIterableIterator<FrontDoor>;
    /**
     * Gets a Front Door with the specified Front Door name under the specified subscription and resource
     * group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    get(resourceGroupName: string, frontDoorName: string, options?: FrontDoorsGetOptionalParams): Promise<FrontDoorsGetResponse>;
    /**
     * Creates a new Front Door with a Front Door name under the specified subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontDoorParameters Front Door properties needed to create a new Front Door.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName: string, frontDoorName: string, frontDoorParameters: FrontDoor, options?: FrontDoorsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<FrontDoorsCreateOrUpdateResponse>, FrontDoorsCreateOrUpdateResponse>>;
    /**
     * Creates a new Front Door with a Front Door name under the specified subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontDoorParameters Front Door properties needed to create a new Front Door.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName: string, frontDoorName: string, frontDoorParameters: FrontDoor, options?: FrontDoorsCreateOrUpdateOptionalParams): Promise<FrontDoorsCreateOrUpdateResponse>;
    /**
     * Deletes an existing Front Door with the specified parameters.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, frontDoorName: string, options?: FrontDoorsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Deletes an existing Front Door with the specified parameters.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, frontDoorName: string, options?: FrontDoorsDeleteOptionalParams): Promise<void>;
    /**
     * Validates the custom domain mapping to ensure it maps to the correct Front Door endpoint in DNS.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param customDomainProperties Custom domain to be validated.
     * @param options The options parameters.
     */
    validateCustomDomain(resourceGroupName: string, frontDoorName: string, customDomainProperties: ValidateCustomDomainInput, options?: FrontDoorsValidateCustomDomainOptionalParams): Promise<FrontDoorsValidateCustomDomainResponse>;
}

/** Optional parameters. */
export declare interface FrontDoorsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export declare type FrontDoorsCreateOrUpdateResponse = FrontDoor;

/** Optional parameters. */
export declare interface FrontDoorsDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface FrontDoorsGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type FrontDoorsGetResponse = FrontDoor;

/** Optional parameters. */
export declare interface FrontDoorsListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByResourceGroupNext operation. */
export declare type FrontDoorsListByResourceGroupNextResponse = FrontDoorListResult;

/** Optional parameters. */
export declare interface FrontDoorsListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByResourceGroup operation. */
export declare type FrontDoorsListByResourceGroupResponse = FrontDoorListResult;

/** Optional parameters. */
export declare interface FrontDoorsListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type FrontDoorsListNextResponse = FrontDoorListResult;

/** Optional parameters. */
export declare interface FrontDoorsListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type FrontDoorsListResponse = FrontDoorListResult;

/** Optional parameters. */
export declare interface FrontDoorsValidateCustomDomainOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the validateCustomDomain operation. */
export declare type FrontDoorsValidateCustomDomainResponse = ValidateCustomDomainOutput;

/**
 * Defines values for FrontDoorTlsProtocolType. \
 * {@link KnownFrontDoorTlsProtocolType} can be used interchangeably with FrontDoorTlsProtocolType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **ServerNameIndication**
 */
export declare type FrontDoorTlsProtocolType = string;

/** The properties needed to update a Front Door */
export declare interface FrontDoorUpdateParameters {
    /** A friendly name for the frontDoor */
    friendlyName?: string;
    /** Routing rules associated with this Front Door. */
    routingRules?: RoutingRule[];
    /** Load balancing settings associated with this Front Door instance. */
    loadBalancingSettings?: LoadBalancingSettingsModel[];
    /** Health probe settings associated with this Front Door instance. */
    healthProbeSettings?: HealthProbeSettingsModel[];
    /** Backend pools available to routing rules. */
    backendPools?: BackendPool[];
    /** Frontend endpoints available to routing rules. */
    frontendEndpoints?: FrontendEndpoint[];
    /** Settings for all backendPools */
    backendPoolsSettings?: BackendPoolsSettings;
    /** Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled' */
    enabledState?: FrontDoorEnabledState;
}

/** A frontend endpoint used for routing. */
export declare interface FrontendEndpoint extends SubResource {
    /** Resource name. */
    name?: string;
    /**
     * Resource type.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** The host name of the frontendEndpoint. Must be a domain name. */
    hostName?: string;
    /** Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled' */
    sessionAffinityEnabledState?: SessionAffinityEnabledState;
    /** UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable. */
    sessionAffinityTtlSeconds?: number;
    /** Defines the Web Application Firewall policy for each host (if applicable) */
    webApplicationFirewallPolicyLink?: FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink;
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
    /**
     * Provisioning status of Custom Https of the frontendEndpoint.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly customHttpsProvisioningState?: CustomHttpsProvisioningState;
    /**
     * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly customHttpsProvisioningSubstate?: CustomHttpsProvisioningSubstate;
    /**
     * The configuration specifying how to enable HTTPS
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly customHttpsConfiguration?: CustomHttpsConfiguration;
}

/** Defines the Resource ID for a Frontend Endpoint. */
export declare interface FrontendEndpointLink {
    /** Resource ID. */
    id?: string;
}

/** The JSON object that contains the properties required to create a frontend endpoint. */
export declare interface FrontendEndpointProperties extends FrontendEndpointUpdateParameters {
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
    /**
     * Provisioning status of Custom Https of the frontendEndpoint.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly customHttpsProvisioningState?: CustomHttpsProvisioningState;
    /**
     * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly customHttpsProvisioningSubstate?: CustomHttpsProvisioningSubstate;
    /**
     * The configuration specifying how to enable HTTPS
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly customHttpsConfiguration?: CustomHttpsConfiguration;
}

/** Interface representing a FrontendEndpoints. */
export declare interface FrontendEndpoints {
    /**
     * Lists all of the frontend endpoints within a Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    listByFrontDoor(resourceGroupName: string, frontDoorName: string, options?: FrontendEndpointsListByFrontDoorOptionalParams): PagedAsyncIterableIterator<FrontendEndpoint>;
    /**
     * Gets a Frontend endpoint with the specified name within the specified Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontendEndpointName Name of the Frontend endpoint which is unique within the Front Door.
     * @param options The options parameters.
     */
    get(resourceGroupName: string, frontDoorName: string, frontendEndpointName: string, options?: FrontendEndpointsGetOptionalParams): Promise<FrontendEndpointsGetResponse>;
    /**
     * Enables a frontendEndpoint for HTTPS traffic
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontendEndpointName Name of the Frontend endpoint which is unique within the Front Door.
     * @param customHttpsConfiguration The configuration specifying how to enable HTTPS
     * @param options The options parameters.
     */
    beginEnableHttps(resourceGroupName: string, frontDoorName: string, frontendEndpointName: string, customHttpsConfiguration: CustomHttpsConfiguration, options?: FrontendEndpointsEnableHttpsOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Enables a frontendEndpoint for HTTPS traffic
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontendEndpointName Name of the Frontend endpoint which is unique within the Front Door.
     * @param customHttpsConfiguration The configuration specifying how to enable HTTPS
     * @param options The options parameters.
     */
    beginEnableHttpsAndWait(resourceGroupName: string, frontDoorName: string, frontendEndpointName: string, customHttpsConfiguration: CustomHttpsConfiguration, options?: FrontendEndpointsEnableHttpsOptionalParams): Promise<void>;
    /**
     * Disables a frontendEndpoint for HTTPS traffic
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontendEndpointName Name of the Frontend endpoint which is unique within the Front Door.
     * @param options The options parameters.
     */
    beginDisableHttps(resourceGroupName: string, frontDoorName: string, frontendEndpointName: string, options?: FrontendEndpointsDisableHttpsOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Disables a frontendEndpoint for HTTPS traffic
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontendEndpointName Name of the Frontend endpoint which is unique within the Front Door.
     * @param options The options parameters.
     */
    beginDisableHttpsAndWait(resourceGroupName: string, frontDoorName: string, frontendEndpointName: string, options?: FrontendEndpointsDisableHttpsOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface FrontendEndpointsDisableHttpsOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface FrontendEndpointsEnableHttpsOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface FrontendEndpointsGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type FrontendEndpointsGetResponse = FrontendEndpoint;

/** Optional parameters. */
export declare interface FrontendEndpointsListByFrontDoorNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByFrontDoorNext operation. */
export declare type FrontendEndpointsListByFrontDoorNextResponse = FrontendEndpointsListResult;

/** Optional parameters. */
export declare interface FrontendEndpointsListByFrontDoorOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByFrontDoor operation. */
export declare type FrontendEndpointsListByFrontDoorResponse = FrontendEndpointsListResult;

/** Result of the request to list frontend endpoints. It contains a list of Frontend endpoint objects and a URL link to get the next set of results. */
export declare interface FrontendEndpointsListResult {
    /**
     * List of Frontend endpoints within a Front Door.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: FrontendEndpoint[];
    /** URL to get the next set of frontend endpoints if there are any. */
    nextLink?: string;
}

/** Frontend endpoint used in routing rule */
export declare interface FrontendEndpointUpdateParameters {
    /** The host name of the frontendEndpoint. Must be a domain name. */
    hostName?: string;
    /** Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled' */
    sessionAffinityEnabledState?: SessionAffinityEnabledState;
    /** UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable. */
    sessionAffinityTtlSeconds?: number;
    /** Defines the Web Application Firewall policy for each host (if applicable) */
    webApplicationFirewallPolicyLink?: FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink;
}

/** Defines the Web Application Firewall policy for each host (if applicable) */
export declare interface FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink {
    /** Resource ID. */
    id?: string;
}

/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
export declare function getContinuationToken(page: unknown): string | undefined;

/** Describes the variables available to group the rate limit requests */
export declare interface GroupByVariable {
    /** Describes the supported variable for group by */
    variableName: VariableName;
}

/** An action that can manipulate an http header. */
export declare interface HeaderAction {
    /** Which type of manipulation to apply to the header. */
    headerActionType: HeaderActionType;
    /** The name of the header this action will apply to. */
    headerName: string;
    /** The value to update the given header name with. This value is not used if the actionType is Delete. */
    value?: string;
}

/**
 * Defines values for HeaderActionType. \
 * {@link KnownHeaderActionType} can be used interchangeably with HeaderActionType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Append** \
 * **Delete** \
 * **Overwrite**
 */
export declare type HeaderActionType = string;

/**
 * Defines values for HealthProbeEnabled. \
 * {@link KnownHealthProbeEnabled} can be used interchangeably with HealthProbeEnabled,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export declare type HealthProbeEnabled = string;

/** Result of the request to list HealthProbeSettings. It contains a list of HealthProbeSettings objects and a URL link to get the next set of results. */
export declare interface HealthProbeSettingsListResult {
    /**
     * List of HealthProbeSettings within a Front Door.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: HealthProbeSettingsModel[];
    /** URL to get the next set of HealthProbeSettings objects if there are any. */
    nextLink?: string;
}

/** Load balancing settings for a backend pool */
export declare interface HealthProbeSettingsModel extends SubResource {
    /** Resource name. */
    name?: string;
    /**
     * Resource type.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** The path to use for the health probe. Default is / */
    path?: string;
    /** Protocol scheme to use for this probe */
    protocol?: FrontDoorProtocol;
    /** The number of seconds between health probes. */
    intervalInSeconds?: number;
    /** Configures which HTTP method to use to probe the backends defined under backendPools. */
    healthProbeMethod?: FrontDoorHealthProbeMethod;
    /** Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool. */
    enabledState?: HealthProbeEnabled;
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
}

/** The JSON object that contains the properties required to create a health probe settings. */
export declare interface HealthProbeSettingsProperties extends HealthProbeSettingsUpdateParameters {
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
}

/** L7 health probe settings for a backend pool */
export declare interface HealthProbeSettingsUpdateParameters {
    /** The path to use for the health probe. Default is / */
    path?: string;
    /** Protocol scheme to use for this probe */
    protocol?: FrontDoorProtocol;
    /** The number of seconds between health probes. */
    intervalInSeconds?: number;
    /** Configures which HTTP method to use to probe the backends defined under backendPools. */
    healthProbeMethod?: FrontDoorHealthProbeMethod;
    /** Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool. */
    enabledState?: HealthProbeEnabled;
}

/** The Key Vault containing the SSL certificate */
export declare interface KeyVaultCertificateSourceParametersVault {
    /** Resource ID. */
    id?: string;
}

/** Known values of {@link ActionType} that the service accepts. */
export declare enum KnownActionType {
    /** Allow */
    Allow = "Allow",
    /** Block */
    Block = "Block",
    /** Log */
    Log = "Log",
    /** Redirect */
    Redirect = "Redirect",
    /** AnomalyScoring */
    AnomalyScoring = "AnomalyScoring",
    /** JSChallenge */
    JSChallenge = "JSChallenge"
}

/** Known values of {@link AggregationInterval} that the service accepts. */
export declare enum KnownAggregationInterval {
    /** Hourly */
    Hourly = "Hourly",
    /** Daily */
    Daily = "Daily"
}

/** Known values of {@link Availability} that the service accepts. */
export declare enum KnownAvailability {
    /** Available */
    Available = "Available",
    /** Unavailable */
    Unavailable = "Unavailable"
}

/** Known values of {@link BackendEnabledState} that the service accepts. */
export declare enum KnownBackendEnabledState {
    /** Enabled */
    Enabled = "Enabled",
    /** Disabled */
    Disabled = "Disabled"
}

/** Known values of {@link CustomHttpsProvisioningState} that the service accepts. */
export declare enum KnownCustomHttpsProvisioningState {
    /** Enabling */
    Enabling = "Enabling",
    /** Enabled */
    Enabled = "Enabled",
    /** Disabling */
    Disabling = "Disabling",
    /** Disabled */
    Disabled = "Disabled",
    /** Failed */
    Failed = "Failed"
}

/** Known values of {@link CustomHttpsProvisioningSubstate} that the service accepts. */
export declare enum KnownCustomHttpsProvisioningSubstate {
    /** SubmittingDomainControlValidationRequest */
    SubmittingDomainControlValidationRequest = "SubmittingDomainControlValidationRequest",
    /** PendingDomainControlValidationREquestApproval */
    PendingDomainControlValidationREquestApproval = "PendingDomainControlValidationREquestApproval",
    /** DomainControlValidationRequestApproved */
    DomainControlValidationRequestApproved = "DomainControlValidationRequestApproved",
    /** DomainControlValidationRequestRejected */
    DomainControlValidationRequestRejected = "DomainControlValidationRequestRejected",
    /** DomainControlValidationRequestTimedOut */
    DomainControlValidationRequestTimedOut = "DomainControlValidationRequestTimedOut",
    /** IssuingCertificate */
    IssuingCertificate = "IssuingCertificate",
    /** DeployingCertificate */
    DeployingCertificate = "DeployingCertificate",
    /** CertificateDeployed */
    CertificateDeployed = "CertificateDeployed",
    /** DeletingCertificate */
    DeletingCertificate = "DeletingCertificate",
    /** CertificateDeleted */
    CertificateDeleted = "CertificateDeleted"
}

/** Known values of {@link CustomRuleEnabledState} that the service accepts. */
export declare enum KnownCustomRuleEnabledState {
    /** Disabled */
    Disabled = "Disabled",
    /** Enabled */
    Enabled = "Enabled"
}

/** Known values of {@link DynamicCompressionEnabled} that the service accepts. */
export declare enum KnownDynamicCompressionEnabled {
    /** Enabled */
    Enabled = "Enabled",
    /** Disabled */
    Disabled = "Disabled"
}

/** Known values of {@link EndpointType} that the service accepts. */
export declare enum KnownEndpointType {
    /** AFD */
    AFD = "AFD",
    /** AzureRegion */
    AzureRegion = "AzureRegion",
    /** CDN */
    CDN = "CDN",
    /** ATM */
    ATM = "ATM"
}

/** Known values of {@link EnforceCertificateNameCheckEnabledState} that the service accepts. */
export declare enum KnownEnforceCertificateNameCheckEnabledState {
    /** Enabled */
    Enabled = "Enabled",
    /** Disabled */
    Disabled = "Disabled"
}

/** Known values of {@link FrontDoorCertificateSource} that the service accepts. */
export declare enum KnownFrontDoorCertificateSource {
    /** AzureKeyVault */
    AzureKeyVault = "AzureKeyVault",
    /** FrontDoor */
    FrontDoor = "FrontDoor"
}

/** Known values of {@link FrontDoorCertificateType} that the service accepts. */
export declare enum KnownFrontDoorCertificateType {
    /** Dedicated */
    Dedicated = "Dedicated"
}

/** Known values of {@link FrontDoorEnabledState} that the service accepts. */
export declare enum KnownFrontDoorEnabledState {
    /** Enabled */
    Enabled = "Enabled",
    /** Disabled */
    Disabled = "Disabled"
}

/** Known values of {@link FrontDoorForwardingProtocol} that the service accepts. */
export declare enum KnownFrontDoorForwardingProtocol {
    /** HttpOnly */
    HttpOnly = "HttpOnly",
    /** HttpsOnly */
    HttpsOnly = "HttpsOnly",
    /** MatchRequest */
    MatchRequest = "MatchRequest"
}

/** Known values of {@link FrontDoorHealthProbeMethod} that the service accepts. */
export declare enum KnownFrontDoorHealthProbeMethod {
    /** GET */
    GET = "GET",
    /** Head */
    Head = "HEAD"
}

/** Known values of {@link FrontDoorProtocol} that the service accepts. */
export declare enum KnownFrontDoorProtocol {
    /** Http */
    Http = "Http",
    /** Https */
    Https = "Https"
}

/** Known values of {@link FrontDoorQuery} that the service accepts. */
export declare enum KnownFrontDoorQuery {
    /** StripNone */
    StripNone = "StripNone",
    /** StripAll */
    StripAll = "StripAll",
    /** StripOnly */
    StripOnly = "StripOnly",
    /** StripAllExcept */
    StripAllExcept = "StripAllExcept"
}

/** Known values of {@link FrontDoorRedirectProtocol} that the service accepts. */
export declare enum KnownFrontDoorRedirectProtocol {
    /** HttpOnly */
    HttpOnly = "HttpOnly",
    /** HttpsOnly */
    HttpsOnly = "HttpsOnly",
    /** MatchRequest */
    MatchRequest = "MatchRequest"
}

/** Known values of {@link FrontDoorRedirectType} that the service accepts. */
export declare enum KnownFrontDoorRedirectType {
    /** Moved */
    Moved = "Moved",
    /** Found */
    Found = "Found",
    /** TemporaryRedirect */
    TemporaryRedirect = "TemporaryRedirect",
    /** PermanentRedirect */
    PermanentRedirect = "PermanentRedirect"
}

/** Known values of {@link FrontDoorResourceState} that the service accepts. */
export declare enum KnownFrontDoorResourceState {
    /** Creating */
    Creating = "Creating",
    /** Enabling */
    Enabling = "Enabling",
    /** Enabled */
    Enabled = "Enabled",
    /** Disabling */
    Disabling = "Disabling",
    /** Disabled */
    Disabled = "Disabled",
    /** Deleting */
    Deleting = "Deleting",
    /** Migrating */
    Migrating = "Migrating",
    /** Migrated */
    Migrated = "Migrated"
}

/** Known values of {@link FrontDoorTlsProtocolType} that the service accepts. */
export declare enum KnownFrontDoorTlsProtocolType {
    /** ServerNameIndication */
    ServerNameIndication = "ServerNameIndication"
}

/** Known values of {@link HeaderActionType} that the service accepts. */
export declare enum KnownHeaderActionType {
    /** Append */
    Append = "Append",
    /** Delete */
    Delete = "Delete",
    /** Overwrite */
    Overwrite = "Overwrite"
}

/** Known values of {@link HealthProbeEnabled} that the service accepts. */
export declare enum KnownHealthProbeEnabled {
    /** Enabled */
    Enabled = "Enabled",
    /** Disabled */
    Disabled = "Disabled"
}

/** Known values of {@link LatencyScorecardAggregationInterval} that the service accepts. */
export declare enum KnownLatencyScorecardAggregationInterval {
    /** Daily */
    Daily = "Daily",
    /** Weekly */
    Weekly = "Weekly",
    /** Monthly */
    Monthly = "Monthly"
}

/** Known values of {@link ManagedRuleEnabledState} that the service accepts. */
export declare enum KnownManagedRuleEnabledState {
    /** Disabled */
    Disabled = "Disabled",
    /** Enabled */
    Enabled = "Enabled"
}

/** Known values of {@link ManagedRuleExclusionMatchVariable} that the service accepts. */
export declare enum KnownManagedRuleExclusionMatchVariable {
    /** RequestHeaderNames */
    RequestHeaderNames = "RequestHeaderNames",
    /** RequestCookieNames */
    RequestCookieNames = "RequestCookieNames",
    /** QueryStringArgNames */
    QueryStringArgNames = "QueryStringArgNames",
    /** RequestBodyPostArgNames */
    RequestBodyPostArgNames = "RequestBodyPostArgNames",
    /** RequestBodyJsonArgNames */
    RequestBodyJsonArgNames = "RequestBodyJsonArgNames"
}

/** Known values of {@link ManagedRuleExclusionSelectorMatchOperator} that the service accepts. */
export declare enum KnownManagedRuleExclusionSelectorMatchOperator {
    /** Equals */
    Equals = "Equals",
    /** Contains */
    Contains = "Contains",
    /** StartsWith */
    StartsWith = "StartsWith",
    /** EndsWith */
    EndsWith = "EndsWith",
    /** EqualsAny */
    EqualsAny = "EqualsAny"
}

/** Known values of {@link ManagedRuleSetActionType} that the service accepts. */
export declare enum KnownManagedRuleSetActionType {
    /** Block */
    Block = "Block",
    /** Log */
    Log = "Log",
    /** Redirect */
    Redirect = "Redirect"
}

/** Known values of {@link MatchProcessingBehavior} that the service accepts. */
export declare enum KnownMatchProcessingBehavior {
    /** Continue */
    Continue = "Continue",
    /** Stop */
    Stop = "Stop"
}

/** Known values of {@link MatchVariable} that the service accepts. */
export declare enum KnownMatchVariable {
    /** RemoteAddr */
    RemoteAddr = "RemoteAddr",
    /** RequestMethod */
    RequestMethod = "RequestMethod",
    /** QueryString */
    QueryString = "QueryString",
    /** PostArgs */
    PostArgs = "PostArgs",
    /** RequestUri */
    RequestUri = "RequestUri",
    /** RequestHeader */
    RequestHeader = "RequestHeader",
    /** RequestBody */
    RequestBody = "RequestBody",
    /** Cookies */
    Cookies = "Cookies",
    /** SocketAddr */
    SocketAddr = "SocketAddr"
}

/** Known values of {@link MinimumTLSVersion} that the service accepts. */
export declare enum KnownMinimumTLSVersion {
    /** One0 */
    One0 = "1.0",
    /** One2 */
    One2 = "1.2"
}

/** Known values of {@link NetworkExperimentResourceState} that the service accepts. */
export declare enum KnownNetworkExperimentResourceState {
    /** Creating */
    Creating = "Creating",
    /** Enabling */
    Enabling = "Enabling",
    /** Enabled */
    Enabled = "Enabled",
    /** Disabling */
    Disabling = "Disabling",
    /** Disabled */
    Disabled = "Disabled",
    /** Deleting */
    Deleting = "Deleting"
}

/** Known values of {@link NetworkOperationStatus} that the service accepts. */
export declare enum KnownNetworkOperationStatus {
    /** InProgress */
    InProgress = "InProgress",
    /** Succeeded */
    Succeeded = "Succeeded",
    /** Failed */
    Failed = "Failed"
}

/** Known values of {@link Operator} that the service accepts. */
export declare enum KnownOperator {
    /** Any */
    Any = "Any",
    /** IPMatch */
    IPMatch = "IPMatch",
    /** GeoMatch */
    GeoMatch = "GeoMatch",
    /** Equal */
    Equal = "Equal",
    /** Contains */
    Contains = "Contains",
    /** LessThan */
    LessThan = "LessThan",
    /** GreaterThan */
    GreaterThan = "GreaterThan",
    /** LessThanOrEqual */
    LessThanOrEqual = "LessThanOrEqual",
    /** GreaterThanOrEqual */
    GreaterThanOrEqual = "GreaterThanOrEqual",
    /** BeginsWith */
    BeginsWith = "BeginsWith",
    /** EndsWith */
    EndsWith = "EndsWith",
    /** RegEx */
    RegEx = "RegEx"
}

/** Known values of {@link PolicyEnabledState} that the service accepts. */
export declare enum KnownPolicyEnabledState {
    /** Disabled */
    Disabled = "Disabled",
    /** Enabled */
    Enabled = "Enabled"
}

/** Known values of {@link PolicyMode} that the service accepts. */
export declare enum KnownPolicyMode {
    /** Prevention */
    Prevention = "Prevention",
    /** Detection */
    Detection = "Detection"
}

/** Known values of {@link PolicyRequestBodyCheck} that the service accepts. */
export declare enum KnownPolicyRequestBodyCheck {
    /** Disabled */
    Disabled = "Disabled",
    /** Enabled */
    Enabled = "Enabled"
}

/** Known values of {@link PolicyResourceState} that the service accepts. */
export declare enum KnownPolicyResourceState {
    /** Creating */
    Creating = "Creating",
    /** Enabling */
    Enabling = "Enabling",
    /** Enabled */
    Enabled = "Enabled",
    /** Disabling */
    Disabling = "Disabling",
    /** Disabled */
    Disabled = "Disabled",
    /** Deleting */
    Deleting = "Deleting"
}

/** Known values of {@link PrivateEndpointStatus} that the service accepts. */
export declare enum KnownPrivateEndpointStatus {
    /** Pending */
    Pending = "Pending",
    /** Approved */
    Approved = "Approved",
    /** Rejected */
    Rejected = "Rejected",
    /** Disconnected */
    Disconnected = "Disconnected",
    /** Timeout */
    Timeout = "Timeout"
}

/** Known values of {@link RoutingRuleEnabledState} that the service accepts. */
export declare enum KnownRoutingRuleEnabledState {
    /** Enabled */
    Enabled = "Enabled",
    /** Disabled */
    Disabled = "Disabled"
}

/** Known values of {@link RulesEngineMatchVariable} that the service accepts. */
export declare enum KnownRulesEngineMatchVariable {
    /** IsMobile */
    IsMobile = "IsMobile",
    /** RemoteAddr */
    RemoteAddr = "RemoteAddr",
    /** RequestMethod */
    RequestMethod = "RequestMethod",
    /** QueryString */
    QueryString = "QueryString",
    /** PostArgs */
    PostArgs = "PostArgs",
    /** RequestUri */
    RequestUri = "RequestUri",
    /** RequestPath */
    RequestPath = "RequestPath",
    /** RequestFilename */
    RequestFilename = "RequestFilename",
    /** RequestFilenameExtension */
    RequestFilenameExtension = "RequestFilenameExtension",
    /** RequestHeader */
    RequestHeader = "RequestHeader",
    /** RequestBody */
    RequestBody = "RequestBody",
    /** RequestScheme */
    RequestScheme = "RequestScheme"
}

/** Known values of {@link RulesEngineOperator} that the service accepts. */
export declare enum KnownRulesEngineOperator {
    /** Any */
    Any = "Any",
    /** IPMatch */
    IPMatch = "IPMatch",
    /** GeoMatch */
    GeoMatch = "GeoMatch",
    /** Equal */
    Equal = "Equal",
    /** Contains */
    Contains = "Contains",
    /** LessThan */
    LessThan = "LessThan",
    /** GreaterThan */
    GreaterThan = "GreaterThan",
    /** LessThanOrEqual */
    LessThanOrEqual = "LessThanOrEqual",
    /** GreaterThanOrEqual */
    GreaterThanOrEqual = "GreaterThanOrEqual",
    /** BeginsWith */
    BeginsWith = "BeginsWith",
    /** EndsWith */
    EndsWith = "EndsWith"
}

/** Known values of {@link RuleType} that the service accepts. */
export declare enum KnownRuleType {
    /** MatchRule */
    MatchRule = "MatchRule",
    /** RateLimitRule */
    RateLimitRule = "RateLimitRule"
}

/** Known values of {@link ScrubbingRuleEntryMatchOperator} that the service accepts. */
export declare enum KnownScrubbingRuleEntryMatchOperator {
    /** EqualsAny */
    EqualsAny = "EqualsAny",
    /** Equals */
    Equals = "Equals"
}

/** Known values of {@link ScrubbingRuleEntryMatchVariable} that the service accepts. */
export declare enum KnownScrubbingRuleEntryMatchVariable {
    /** RequestIPAddress */
    RequestIPAddress = "RequestIPAddress",
    /** RequestUri */
    RequestUri = "RequestUri",
    /** QueryStringArgNames */
    QueryStringArgNames = "QueryStringArgNames",
    /** RequestHeaderNames */
    RequestHeaderNames = "RequestHeaderNames",
    /** RequestCookieNames */
    RequestCookieNames = "RequestCookieNames",
    /** RequestBodyPostArgNames */
    RequestBodyPostArgNames = "RequestBodyPostArgNames",
    /** RequestBodyJsonArgNames */
    RequestBodyJsonArgNames = "RequestBodyJsonArgNames"
}

/** Known values of {@link ScrubbingRuleEntryState} that the service accepts. */
export declare enum KnownScrubbingRuleEntryState {
    /** Enabled */
    Enabled = "Enabled",
    /** Disabled */
    Disabled = "Disabled"
}

/** Known values of {@link SessionAffinityEnabledState} that the service accepts. */
export declare enum KnownSessionAffinityEnabledState {
    /** Enabled */
    Enabled = "Enabled",
    /** Disabled */
    Disabled = "Disabled"
}

/** Known values of {@link SkuName} that the service accepts. */
export declare enum KnownSkuName {
    /** ClassicAzureFrontDoor */
    ClassicAzureFrontDoor = "Classic_AzureFrontDoor",
    /** StandardAzureFrontDoor */
    StandardAzureFrontDoor = "Standard_AzureFrontDoor",
    /** PremiumAzureFrontDoor */
    PremiumAzureFrontDoor = "Premium_AzureFrontDoor"
}

/** Known values of {@link State} that the service accepts. */
export declare enum KnownState {
    /** Enabled */
    Enabled = "Enabled",
    /** Disabled */
    Disabled = "Disabled"
}

/** Known values of {@link TimeseriesAggregationInterval} that the service accepts. */
export declare enum KnownTimeseriesAggregationInterval {
    /** Hourly */
    Hourly = "Hourly",
    /** Daily */
    Daily = "Daily"
}

/** Known values of {@link TimeseriesType} that the service accepts. */
export declare enum KnownTimeseriesType {
    /** MeasurementCounts */
    MeasurementCounts = "MeasurementCounts",
    /** LatencyP50 */
    LatencyP50 = "LatencyP50",
    /** LatencyP75 */
    LatencyP75 = "LatencyP75",
    /** LatencyP95 */
    LatencyP95 = "LatencyP95"
}

/** Known values of {@link Transform} that the service accepts. */
export declare enum KnownTransform {
    /** Lowercase */
    Lowercase = "Lowercase",
    /** Uppercase */
    Uppercase = "Uppercase",
    /** Trim */
    Trim = "Trim",
    /** UrlDecode */
    UrlDecode = "UrlDecode",
    /** UrlEncode */
    UrlEncode = "UrlEncode",
    /** RemoveNulls */
    RemoveNulls = "RemoveNulls"
}

/** Known values of {@link TransformType} that the service accepts. */
export declare enum KnownTransformType {
    /** Lowercase */
    Lowercase = "Lowercase",
    /** Uppercase */
    Uppercase = "Uppercase",
    /** Trim */
    Trim = "Trim",
    /** UrlDecode */
    UrlDecode = "UrlDecode",
    /** UrlEncode */
    UrlEncode = "UrlEncode",
    /** RemoveNulls */
    RemoveNulls = "RemoveNulls"
}

/** Known values of {@link VariableName} that the service accepts. */
export declare enum KnownVariableName {
    /** SocketAddr */
    SocketAddr = "SocketAddr",
    /** GeoLocation */
    GeoLocation = "GeoLocation",
    /** None */
    None = "None"
}

/** Known values of {@link WebApplicationFirewallScrubbingState} that the service accepts. */
export declare enum KnownWebApplicationFirewallScrubbingState {
    /** Enabled */
    Enabled = "Enabled",
    /** Disabled */
    Disabled = "Disabled"
}

/** Defines the properties of a latency metric used in the latency scorecard */
export declare interface LatencyMetric {
    /**
     * The name of the Latency Metric
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * The end time of the Latency Scorecard in UTC
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly endDateTimeUTC?: string;
    /**
     * The metric value of the A endpoint
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly aValue?: number;
    /**
     * The metric value of the B endpoint
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly bValue?: number;
    /**
     * The difference in value between endpoint A and B
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly delta?: number;
    /**
     * The percent difference between endpoint A and B
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly deltaPercent?: number;
    /**
     * The lower end of the 95% confidence interval for endpoint A
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly aCLower95CI?: number;
    /**
     * The upper end of the 95% confidence interval for endpoint A
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly aHUpper95CI?: number;
    /**
     * The lower end of the 95% confidence interval for endpoint B
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly bCLower95CI?: number;
    /**
     * The upper end of the 95% confidence interval for endpoint B
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly bUpper95CI?: number;
}

/** Defines the LatencyScorecard */
export declare interface LatencyScorecard extends Resource {
    /**
     * The unique identifier of the Latency Scorecard
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly idPropertiesId?: string;
    /**
     * The name of the Latency Scorecard
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly namePropertiesName?: string;
    /**
     * The description of the Latency Scorecard
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly description?: string;
    /**
     * The A endpoint in the scorecard
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly endpointA?: string;
    /**
     * The B endpoint in the scorecard
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly endpointB?: string;
    /**
     * The start time of the Latency Scorecard in UTC
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly startDateTimeUTC?: Date;
    /**
     * The end time of the Latency Scorecard in UTC
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly endDateTimeUTC?: Date;
    /**
     * The country associated with the Latency Scorecard. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly country?: string;
    /** The latency metrics of the Latency Scorecard */
    latencyMetrics?: LatencyMetric[];
}

/**
 * Defines values for LatencyScorecardAggregationInterval. \
 * {@link KnownLatencyScorecardAggregationInterval} can be used interchangeably with LatencyScorecardAggregationInterval,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Daily** \
 * **Weekly** \
 * **Monthly**
 */
export declare type LatencyScorecardAggregationInterval = string;

/** Result of the request to list load balancing settings. It contains a list of load balancing settings objects and a URL link to get the next set of results. */
export declare interface LoadBalancingSettingsListResult {
    /**
     * List of Backend Pools within a Front Door.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: LoadBalancingSettingsModel[];
    /** URL to get the next set of LoadBalancingSettings objects if there are any. */
    nextLink?: string;
}

/** Load balancing settings for a backend pool */
export declare interface LoadBalancingSettingsModel extends SubResource {
    /** Resource name. */
    name?: string;
    /**
     * Resource type.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** The number of samples to consider for load balancing decisions */
    sampleSize?: number;
    /** The number of samples within the sample period that must succeed */
    successfulSamplesRequired?: number;
    /** The additional latency in milliseconds for probes to fall into the lowest latency bucket */
    additionalLatencyMilliseconds?: number;
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
}

/** The JSON object that contains the properties required to create load balancing settings */
export declare interface LoadBalancingSettingsProperties extends LoadBalancingSettingsUpdateParameters {
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
}

/** Round-Robin load balancing settings for a backend pool */
export declare interface LoadBalancingSettingsUpdateParameters {
    /** The number of samples to consider for load balancing decisions */
    sampleSize?: number;
    /** The number of samples within the sample period that must succeed */
    successfulSamplesRequired?: number;
    /** The additional latency in milliseconds for probes to fall into the lowest latency bucket */
    additionalLatencyMilliseconds?: number;
}

/** Describes a managed rule definition. */
export declare interface ManagedRuleDefinition {
    /**
     * Identifier for the managed rule.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly ruleId?: string;
    /**
     * Describes the default state for the managed rule.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly defaultState?: ManagedRuleEnabledState;
    /**
     * Describes the default action to be applied when the managed rule matches.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly defaultAction?: ActionType;
    /**
     * Describes the functionality of the managed rule.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly description?: string;
}

/**
 * Defines values for ManagedRuleEnabledState. \
 * {@link KnownManagedRuleEnabledState} can be used interchangeably with ManagedRuleEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Disabled** \
 * **Enabled**
 */
export declare type ManagedRuleEnabledState = string;

/** Exclude variables from managed rule evaluation. */
export declare interface ManagedRuleExclusion {
    /** The variable type to be excluded. */
    matchVariable: ManagedRuleExclusionMatchVariable;
    /** Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. */
    selectorMatchOperator: ManagedRuleExclusionSelectorMatchOperator;
    /** Selector value for which elements in the collection this exclusion applies to. */
    selector: string;
}

/**
 * Defines values for ManagedRuleExclusionMatchVariable. \
 * {@link KnownManagedRuleExclusionMatchVariable} can be used interchangeably with ManagedRuleExclusionMatchVariable,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **RequestHeaderNames** \
 * **RequestCookieNames** \
 * **QueryStringArgNames** \
 * **RequestBodyPostArgNames** \
 * **RequestBodyJsonArgNames**
 */
export declare type ManagedRuleExclusionMatchVariable = string;

/**
 * Defines values for ManagedRuleExclusionSelectorMatchOperator. \
 * {@link KnownManagedRuleExclusionSelectorMatchOperator} can be used interchangeably with ManagedRuleExclusionSelectorMatchOperator,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Equals** \
 * **Contains** \
 * **StartsWith** \
 * **EndsWith** \
 * **EqualsAny**
 */
export declare type ManagedRuleExclusionSelectorMatchOperator = string;

/** Describes a managed rule group. */
export declare interface ManagedRuleGroupDefinition {
    /**
     * Name of the managed rule group.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly ruleGroupName?: string;
    /**
     * Description of the managed rule group.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly description?: string;
    /**
     * List of rules within the managed rule group.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly rules?: ManagedRuleDefinition[];
}

/** Defines a managed rule group override setting. */
export declare interface ManagedRuleGroupOverride {
    /** Describes the managed rule group to override. */
    ruleGroupName: string;
    /** Describes the exclusions that are applied to all rules in the group. */
    exclusions?: ManagedRuleExclusion[];
    /** List of rules that will be disabled. If none specified, all rules in the group will be disabled. */
    rules?: ManagedRuleOverride[];
}

/** Defines a managed rule group override setting. */
export declare interface ManagedRuleOverride {
    /** Identifier for the managed rule. */
    ruleId: string;
    /** Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified. */
    enabledState?: ManagedRuleEnabledState;
    /** Describes the override action to be applied when rule matches. */
    action?: ActionType;
    /** Describes the exclusions that are applied to this specific rule. */
    exclusions?: ManagedRuleExclusion[];
}

/** Defines a managed rule set. */
export declare interface ManagedRuleSet {
    /** Defines the rule set type to use. */
    ruleSetType: string;
    /** Defines the version of the rule set to use. */
    ruleSetVersion: string;
    /** Defines the rule set action. */
    ruleSetAction?: ManagedRuleSetActionType;
    /** Describes the exclusions that are applied to all rules in the set. */
    exclusions?: ManagedRuleExclusion[];
    /** Defines the rule group overrides to apply to the rule set. */
    ruleGroupOverrides?: ManagedRuleGroupOverride[];
}

/**
 * Defines values for ManagedRuleSetActionType. \
 * {@link KnownManagedRuleSetActionType} can be used interchangeably with ManagedRuleSetActionType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Block** \
 * **Log** \
 * **Redirect**
 */
export declare type ManagedRuleSetActionType = string;

/** Describes the a managed rule set definition. */
export declare interface ManagedRuleSetDefinition extends Resource {
    /**
     * Provisioning state of the managed rule set.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /**
     * Id of the managed rule set.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly ruleSetId?: string;
    /**
     * Type of the managed rule set.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly ruleSetType?: string;
    /**
     * Version of the managed rule set type.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly ruleSetVersion?: string;
    /**
     * Rule groups of the managed rule set.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly ruleGroups?: ManagedRuleGroupDefinition[];
}

/** List of managed rule set definitions available for use in a policy. */
export declare interface ManagedRuleSetDefinitionList {
    /**
     * List of managed rule set definitions.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: ManagedRuleSetDefinition[];
    /** URL to retrieve next set of managed rule set definitions. */
    nextLink?: string;
}

/** Defines the list of managed rule sets for the policy. */
export declare interface ManagedRuleSetList {
    /** List of rule sets. */
    managedRuleSets?: ManagedRuleSet[];
}

/** Interface representing a ManagedRuleSets. */
export declare interface ManagedRuleSets {
    /**
     * Lists all available managed rule sets.
     * @param options The options parameters.
     */
    list(options?: ManagedRuleSetsListOptionalParams): PagedAsyncIterableIterator<ManagedRuleSetDefinition>;
}

/** Optional parameters. */
export declare interface ManagedRuleSetsListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type ManagedRuleSetsListNextResponse = ManagedRuleSetDefinitionList;

/** Optional parameters. */
export declare interface ManagedRuleSetsListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type ManagedRuleSetsListResponse = ManagedRuleSetDefinitionList;

/** Define a match condition. */
export declare interface MatchCondition {
    /** Request variable to compare with. */
    matchVariable: MatchVariable;
    /** Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is null. */
    selector?: string;
    /** Comparison type to use for matching with the variable value. */
    operator: Operator;
    /** Describes if the result of this condition should be negated. */
    negateCondition?: boolean;
    /** List of possible match values. */
    matchValue: string[];
    /** List of transforms. */
    transforms?: TransformType[];
}

/**
 * Defines values for MatchProcessingBehavior. \
 * {@link KnownMatchProcessingBehavior} can be used interchangeably with MatchProcessingBehavior,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Continue** \
 * **Stop**
 */
export declare type MatchProcessingBehavior = string;

/**
 * Defines values for MatchVariable. \
 * {@link KnownMatchVariable} can be used interchangeably with MatchVariable,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **RemoteAddr** \
 * **RequestMethod** \
 * **QueryString** \
 * **PostArgs** \
 * **RequestUri** \
 * **RequestHeader** \
 * **RequestBody** \
 * **Cookies** \
 * **SocketAddr**
 */
export declare type MatchVariable = string;

/**
 * Defines values for MinimumTLSVersion. \
 * {@link KnownMinimumTLSVersion} can be used interchangeably with MinimumTLSVersion,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **1.0** \
 * **1.2**
 */
export declare type MinimumTLSVersion = string;

/** Interface representing a NetworkExperimentProfiles. */
export declare interface NetworkExperimentProfiles {
    /**
     * Gets a list of Network Experiment Profiles under a subscription
     * @param options The options parameters.
     */
    list(options?: NetworkExperimentProfilesListOptionalParams): PagedAsyncIterableIterator<Profile>;
    /**
     * Gets a list of Network Experiment Profiles within a resource group under a subscription
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName: string, options?: NetworkExperimentProfilesListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Profile>;
    /**
     * Gets an NetworkExperiment Profile by ProfileName
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    get(resourceGroupName: string, profileName: string, options?: NetworkExperimentProfilesGetOptionalParams): Promise<NetworkExperimentProfilesGetResponse>;
    /**
     * Creates an NetworkExperiment Profile
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param parameters An Network Experiment Profile
     * @param options The options parameters.
     */
    beginCreateOrUpdate(profileName: string, resourceGroupName: string, parameters: Profile, options?: NetworkExperimentProfilesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<NetworkExperimentProfilesCreateOrUpdateResponse>, NetworkExperimentProfilesCreateOrUpdateResponse>>;
    /**
     * Creates an NetworkExperiment Profile
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param parameters An Network Experiment Profile
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(profileName: string, resourceGroupName: string, parameters: Profile, options?: NetworkExperimentProfilesCreateOrUpdateOptionalParams): Promise<NetworkExperimentProfilesCreateOrUpdateResponse>;
    /**
     * Updates an NetworkExperimentProfiles
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param parameters The Profile Update Model
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, profileName: string, parameters: ProfileUpdateModel, options?: NetworkExperimentProfilesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<NetworkExperimentProfilesUpdateResponse>, NetworkExperimentProfilesUpdateResponse>>;
    /**
     * Updates an NetworkExperimentProfiles
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param parameters The Profile Update Model
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, profileName: string, parameters: ProfileUpdateModel, options?: NetworkExperimentProfilesUpdateOptionalParams): Promise<NetworkExperimentProfilesUpdateResponse>;
    /**
     * Deletes an NetworkExperiment Profile by ProfileName
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, profileName: string, options?: NetworkExperimentProfilesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Deletes an NetworkExperiment Profile by ProfileName
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, profileName: string, options?: NetworkExperimentProfilesDeleteOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface NetworkExperimentProfilesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export declare type NetworkExperimentProfilesCreateOrUpdateResponse = Profile;

/** Optional parameters. */
export declare interface NetworkExperimentProfilesDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface NetworkExperimentProfilesGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type NetworkExperimentProfilesGetResponse = Profile;

/** Optional parameters. */
export declare interface NetworkExperimentProfilesListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByResourceGroupNext operation. */
export declare type NetworkExperimentProfilesListByResourceGroupNextResponse = ProfileList;

/** Optional parameters. */
export declare interface NetworkExperimentProfilesListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByResourceGroup operation. */
export declare type NetworkExperimentProfilesListByResourceGroupResponse = ProfileList;

/** Optional parameters. */
export declare interface NetworkExperimentProfilesListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type NetworkExperimentProfilesListNextResponse = ProfileList;

/** Optional parameters. */
export declare interface NetworkExperimentProfilesListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type NetworkExperimentProfilesListResponse = ProfileList;

/** Optional parameters. */
export declare interface NetworkExperimentProfilesUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type NetworkExperimentProfilesUpdateResponse = Profile;

/**
 * Defines values for NetworkExperimentResourceState. \
 * {@link KnownNetworkExperimentResourceState} can be used interchangeably with NetworkExperimentResourceState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Creating** \
 * **Enabling** \
 * **Enabled** \
 * **Disabling** \
 * **Disabled** \
 * **Deleting**
 */
export declare type NetworkExperimentResourceState = string;

/**
 * Defines values for NetworkOperationStatus. \
 * {@link KnownNetworkOperationStatus} can be used interchangeably with NetworkOperationStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **InProgress** \
 * **Succeeded** \
 * **Failed**
 */
export declare type NetworkOperationStatus = string;

/**
 * Defines values for Operator. \
 * {@link KnownOperator} can be used interchangeably with Operator,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Any** \
 * **IPMatch** \
 * **GeoMatch** \
 * **Equal** \
 * **Contains** \
 * **LessThan** \
 * **GreaterThan** \
 * **LessThanOrEqual** \
 * **GreaterThanOrEqual** \
 * **BeginsWith** \
 * **EndsWith** \
 * **RegEx**
 */
export declare type Operator = string;

/** Interface representing a Policies. */
export declare interface Policies {
    /**
     * Lists all of the protection policies within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    list(resourceGroupName: string, options?: PoliciesListOptionalParams): PagedAsyncIterableIterator<WebApplicationFirewallPolicy>;
    /**
     * Lists all of the protection policies within a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options?: PoliciesListBySubscriptionOptionalParams): PagedAsyncIterableIterator<WebApplicationFirewallPolicy>;
    /**
     * Retrieve protection policy with specified name within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param options The options parameters.
     */
    get(resourceGroupName: string, policyName: string, options?: PoliciesGetOptionalParams): Promise<PoliciesGetResponse>;
    /**
     * Create or update policy with specified rule set name within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param parameters Policy to be created.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName: string, policyName: string, parameters: WebApplicationFirewallPolicy, options?: PoliciesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<PoliciesCreateOrUpdateResponse>, PoliciesCreateOrUpdateResponse>>;
    /**
     * Create or update policy with specified rule set name within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param parameters Policy to be created.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName: string, policyName: string, parameters: WebApplicationFirewallPolicy, options?: PoliciesCreateOrUpdateOptionalParams): Promise<PoliciesCreateOrUpdateResponse>;
    /**
     * Patch a specific frontdoor webApplicationFirewall policy for tags update under the specified
     * subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param parameters FrontdoorWebApplicationFirewallPolicy parameters to be patched.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName: string, policyName: string, parameters: TagsObject, options?: PoliciesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<PoliciesUpdateResponse>, PoliciesUpdateResponse>>;
    /**
     * Patch a specific frontdoor webApplicationFirewall policy for tags update under the specified
     * subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param parameters FrontdoorWebApplicationFirewallPolicy parameters to be patched.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName: string, policyName: string, parameters: TagsObject, options?: PoliciesUpdateOptionalParams): Promise<PoliciesUpdateResponse>;
    /**
     * Deletes Policy
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, policyName: string, options?: PoliciesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Deletes Policy
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, policyName: string, options?: PoliciesDeleteOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface PoliciesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export declare type PoliciesCreateOrUpdateResponse = WebApplicationFirewallPolicy;

/** Optional parameters. */
export declare interface PoliciesDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface PoliciesGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type PoliciesGetResponse = WebApplicationFirewallPolicy;

/** Optional parameters. */
export declare interface PoliciesListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listBySubscriptionNext operation. */
export declare type PoliciesListBySubscriptionNextResponse = WebApplicationFirewallPolicyList;

/** Optional parameters. */
export declare interface PoliciesListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listBySubscription operation. */
export declare type PoliciesListBySubscriptionResponse = WebApplicationFirewallPolicyList;

/** Optional parameters. */
export declare interface PoliciesListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type PoliciesListNextResponse = WebApplicationFirewallPolicyList;

/** Optional parameters. */
export declare interface PoliciesListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type PoliciesListResponse = WebApplicationFirewallPolicyList;

/** Optional parameters. */
export declare interface PoliciesUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type PoliciesUpdateResponse = WebApplicationFirewallPolicy;

/**
 * Defines values for PolicyEnabledState. \
 * {@link KnownPolicyEnabledState} can be used interchangeably with PolicyEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Disabled** \
 * **Enabled**
 */
export declare type PolicyEnabledState = string;

/**
 * Defines values for PolicyMode. \
 * {@link KnownPolicyMode} can be used interchangeably with PolicyMode,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Prevention** \
 * **Detection**
 */
export declare type PolicyMode = string;

/**
 * Defines values for PolicyRequestBodyCheck. \
 * {@link KnownPolicyRequestBodyCheck} can be used interchangeably with PolicyRequestBodyCheck,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Disabled** \
 * **Enabled**
 */
export declare type PolicyRequestBodyCheck = string;

/**
 * Defines values for PolicyResourceState. \
 * {@link KnownPolicyResourceState} can be used interchangeably with PolicyResourceState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Creating** \
 * **Enabling** \
 * **Enabled** \
 * **Disabling** \
 * **Disabled** \
 * **Deleting**
 */
export declare type PolicyResourceState = string;

/** Defines top-level WebApplicationFirewallPolicy configuration settings. */
export declare interface PolicySettings {
    /** Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified. */
    enabledState?: PolicyEnabledState;
    /** Describes if it is in detection mode or prevention mode at policy level. */
    mode?: PolicyMode;
    /** If action type is redirect, this field represents redirect URL for the client. */
    redirectUrl?: string;
    /** If the action type is block, customer can override the response status code. */
    customBlockResponseStatusCode?: number;
    /** If the action type is block, customer can override the response body. The body must be specified in base64 encoding. */
    customBlockResponseBody?: string;
    /** Describes if policy managed rules will inspect the request body content. */
    requestBodyCheck?: PolicyRequestBodyCheck;
    /** Defines the JavaScript challenge cookie validity lifetime in minutes. This setting is only applicable to Premium_AzureFrontDoor. Value must be an integer between 5 and 1440 with the default value being 30. */
    javascriptChallengeExpirationInMinutes?: number;
    /** State of the log scrubbing config. Default value is Enabled. */
    state?: WebApplicationFirewallScrubbingState;
    /** List of log scrubbing rules applied to the Web Application Firewall logs. */
    scrubbingRules?: WebApplicationFirewallScrubbingRules[];
}

/** Defines the properties of a preconfigured endpoint */
export declare interface PreconfiguredEndpoint extends Resource {
    /** The description of the endpoint */
    description?: string;
    /** The endpoint that is preconfigured */
    endpoint?: string;
    /** The type of endpoint */
    endpointType?: EndpointType;
    /** The preconfigured endpoint backend */
    backend?: string;
}

/** Defines a list of preconfigured endpoints. */
export declare interface PreconfiguredEndpointList {
    /**
     * List of PreconfiguredEndpoints supported by NetworkExperiment.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: PreconfiguredEndpoint[];
    /** URL to get the next set of PreconfiguredEndpoints if there are any. */
    nextLink?: string;
}

/** Interface representing a PreconfiguredEndpoints. */
export declare interface PreconfiguredEndpoints {
    /**
     * Gets a list of Preconfigured Endpoints
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    list(resourceGroupName: string, profileName: string, options?: PreconfiguredEndpointsListOptionalParams): PagedAsyncIterableIterator<PreconfiguredEndpoint>;
}

/** Optional parameters. */
export declare interface PreconfiguredEndpointsListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type PreconfiguredEndpointsListNextResponse = PreconfiguredEndpointList;

/** Optional parameters. */
export declare interface PreconfiguredEndpointsListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type PreconfiguredEndpointsListResponse = PreconfiguredEndpointList;

/**
 * Defines values for PrivateEndpointStatus. \
 * {@link KnownPrivateEndpointStatus} can be used interchangeably with PrivateEndpointStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Pending** \
 * **Approved** \
 * **Rejected** \
 * **Disconnected** \
 * **Timeout**
 */
export declare type PrivateEndpointStatus = string;

/** Defines an Network Experiment Profile and lists of Experiments */
export declare interface Profile extends Resource {
    /** Gets a unique read-only string that changes whenever the resource is updated. */
    etag?: string;
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: NetworkExperimentResourceState;
    /** The state of the Experiment */
    enabledState?: State;
}

/** Defines a list of Profiles. It contains a list of Profile objects and a URL link to get the next set of results. */
export declare interface ProfileList {
    /**
     * List of Profiles within a resource group.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: Profile[];
    /** URL to get the next set of Profile objects if there are any. */
    nextLink?: string;
}

/** Defines modifiable attributes of a Profile */
export declare interface ProfileUpdateModel {
    /** Resource tags. */
    tags?: {
        [propertyName: string]: string;
    };
    /** The enabled state of the Profile */
    enabledState?: State;
}

/** Parameters required for content purge. */
export declare interface PurgeParameters {
    /** The path to the content to be purged. Can describe a file path or a wild card directory. */
    contentPaths: string[];
}

/** Describes Redirect Route. */
export declare interface RedirectConfiguration extends RouteConfiguration {
    /** Polymorphic discriminator, which specifies the different types this object can be */
    odataType: "#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration";
    /** The redirect type the rule will use when redirecting traffic. */
    redirectType?: FrontDoorRedirectType;
    /** The protocol of the destination to where the traffic is redirected */
    redirectProtocol?: FrontDoorRedirectProtocol;
    /** Host to redirect. Leave empty to use the incoming host as the destination host. */
    customHost?: string;
    /** The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination path. */
    customPath?: string;
    /** Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include the #. */
    customFragment?: string;
    /** The set of query strings to be placed in the redirect URL. Setting this value would replace any existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format. The first ? and & will be added automatically so do not include them in the front, but do separate multiple query strings with &. */
    customQueryString?: string;
}

/** Interface representing a Reports. */
export declare interface Reports {
    /**
     * Gets a Latency Scorecard for a given Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param aggregationInterval The aggregation interval of the Latency Scorecard
     * @param options The options parameters.
     */
    getLatencyScorecards(resourceGroupName: string, profileName: string, experimentName: string, aggregationInterval: LatencyScorecardAggregationInterval, options?: ReportsGetLatencyScorecardsOptionalParams): Promise<ReportsGetLatencyScorecardsResponse>;
    /**
     * Gets a Timeseries for a given Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param startDateTimeUTC The start DateTime of the Timeseries in UTC
     * @param endDateTimeUTC The end DateTime of the Timeseries in UTC
     * @param aggregationInterval The aggregation interval of the Timeseries
     * @param timeseriesType The type of Timeseries
     * @param options The options parameters.
     */
    getTimeseries(resourceGroupName: string, profileName: string, experimentName: string, startDateTimeUTC: Date, endDateTimeUTC: Date, aggregationInterval: TimeseriesAggregationInterval, timeseriesType: TimeseriesType, options?: ReportsGetTimeseriesOptionalParams): Promise<ReportsGetTimeseriesResponse>;
}

/** Optional parameters. */
export declare interface ReportsGetLatencyScorecardsOptionalParams extends coreClient.OperationOptions {
    /** The end DateTime of the Latency Scorecard in UTC */
    endDateTimeUTC?: string;
    /** The country associated with the Latency Scorecard. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html */
    country?: string;
}

/** Contains response data for the getLatencyScorecards operation. */
export declare type ReportsGetLatencyScorecardsResponse = LatencyScorecard;

/** Optional parameters. */
export declare interface ReportsGetTimeseriesOptionalParams extends coreClient.OperationOptions {
    /** The country associated with the Timeseries. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html */
    country?: string;
    /** The specific endpoint */
    endpoint?: string;
}

/** Contains response data for the getTimeseries operation. */
export declare type ReportsGetTimeseriesResponse = Timeseries;

/** Common resource representation. */
export declare interface Resource {
    /**
     * Resource ID.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Resource name.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Resource location. */
    location?: string;
    /** Resource tags. */
    tags?: {
        [propertyName: string]: string;
    };
}

/** Defines values for ResourceType. */
export declare type ResourceType = "Microsoft.Network/frontDoors" | "Microsoft.Network/frontDoors/frontendEndpoints";

/** Base class for all types of Route. */
export declare interface RouteConfiguration {
    /** Polymorphic discriminator, which specifies the different types this object can be */
    odataType: "#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration" | "#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration";
}

export declare type RouteConfigurationUnion = RouteConfiguration | ForwardingConfiguration | RedirectConfiguration;

/** A routing rule represents a specification for traffic to treat and where to send it, along with health probe information. */
export declare interface RoutingRule extends SubResource {
    /** Resource name. */
    name?: string;
    /**
     * Resource type.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Frontend endpoints associated with this rule */
    frontendEndpoints?: SubResource[];
    /** Protocol schemes to match for this rule */
    acceptedProtocols?: FrontDoorProtocol[];
    /** The route patterns of the rule. */
    patternsToMatch?: string[];
    /** Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled' */
    enabledState?: RoutingRuleEnabledState;
    /** A reference to the routing configuration. */
    routeConfiguration?: RouteConfigurationUnion;
    /** A reference to a specific Rules Engine Configuration to apply to this route. */
    rulesEngine?: SubResource;
    /** Defines the Web Application Firewall policy for each routing rule (if applicable) */
    webApplicationFirewallPolicyLink?: RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink;
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
}

/**
 * Defines values for RoutingRuleEnabledState. \
 * {@link KnownRoutingRuleEnabledState} can be used interchangeably with RoutingRuleEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export declare type RoutingRuleEnabledState = string;

/** Defines the Resource ID for a Routing Rule. */
export declare interface RoutingRuleLink {
    /** Resource ID. */
    id?: string;
}

/** Result of the request to list Routing Rules. It contains a list of Routing Rule objects and a URL link to get the next set of results. */
export declare interface RoutingRuleListResult {
    /**
     * List of Routing Rules within a Front Door.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: RoutingRule[];
    /** URL to get the next set of RoutingRule objects if there are any. */
    nextLink?: string;
}

/** The JSON object that contains the properties required to create a routing rule. */
export declare interface RoutingRuleProperties extends RoutingRuleUpdateParameters {
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
}

/** Routing rules to apply to an endpoint */
export declare interface RoutingRuleUpdateParameters {
    /** Frontend endpoints associated with this rule */
    frontendEndpoints?: SubResource[];
    /** Protocol schemes to match for this rule */
    acceptedProtocols?: FrontDoorProtocol[];
    /** The route patterns of the rule. */
    patternsToMatch?: string[];
    /** Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled' */
    enabledState?: RoutingRuleEnabledState;
    /** A reference to the routing configuration. */
    routeConfiguration?: RouteConfigurationUnion;
    /** A reference to a specific Rules Engine Configuration to apply to this route. */
    rulesEngine?: SubResource;
    /** Defines the Web Application Firewall policy for each routing rule (if applicable) */
    webApplicationFirewallPolicyLink?: RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink;
}

/** Defines the Web Application Firewall policy for each routing rule (if applicable) */
export declare interface RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink {
    /** Resource ID. */
    id?: string;
}

/** A rules engine configuration containing a list of rules that will run to modify the runtime behavior of the request and response. */
export declare interface RulesEngine {
    /**
     * Resource name.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /**
     * Resource ID.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /** A list of rules that define a particular Rules Engine Configuration. */
    rules?: RulesEngineRule[];
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
}

/** One or more actions that will execute, modifying the request and/or response. */
export declare interface RulesEngineAction {
    /** A list of header actions to apply from the request from AFD to the origin. */
    requestHeaderActions?: HeaderAction[];
    /** A list of header actions to apply from the response from AFD to the client. */
    responseHeaderActions?: HeaderAction[];
    /** Override the route configuration. */
    routeConfigurationOverride?: RouteConfigurationUnion;
}

/** Result of the request to list Rules Engine Configurations. It contains a list of RulesEngine objects and a URL link to get the next set of results. */
export declare interface RulesEngineListResult {
    /**
     * List of rulesEngines within a Front Door.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: RulesEngine[];
    /** URL to get the next set of RulesEngine objects if there are any. */
    nextLink?: string;
}

/** Define a match condition */
export declare interface RulesEngineMatchCondition {
    /** Match Variable */
    rulesEngineMatchVariable: RulesEngineMatchVariable;
    /** Name of selector in RequestHeader or RequestBody to be matched */
    selector?: string;
    /** Describes operator to apply to the match condition. */
    rulesEngineOperator: RulesEngineOperator;
    /** Describes if this is negate condition or not */
    negateCondition?: boolean;
    /** Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match. */
    rulesEngineMatchValue: string[];
    /** List of transforms */
    transforms?: Transform[];
}

/**
 * Defines values for RulesEngineMatchVariable. \
 * {@link KnownRulesEngineMatchVariable} can be used interchangeably with RulesEngineMatchVariable,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **IsMobile** \
 * **RemoteAddr** \
 * **RequestMethod** \
 * **QueryString** \
 * **PostArgs** \
 * **RequestUri** \
 * **RequestPath** \
 * **RequestFilename** \
 * **RequestFilenameExtension** \
 * **RequestHeader** \
 * **RequestBody** \
 * **RequestScheme**
 */
export declare type RulesEngineMatchVariable = string;

/**
 * Defines values for RulesEngineOperator. \
 * {@link KnownRulesEngineOperator} can be used interchangeably with RulesEngineOperator,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Any** \
 * **IPMatch** \
 * **GeoMatch** \
 * **Equal** \
 * **Contains** \
 * **LessThan** \
 * **GreaterThan** \
 * **LessThanOrEqual** \
 * **GreaterThanOrEqual** \
 * **BeginsWith** \
 * **EndsWith**
 */
export declare type RulesEngineOperator = string;

/** The JSON object that contains the properties required to create a Rules Engine Configuration. */
export declare interface RulesEngineProperties extends RulesEngineUpdateParameters {
    /**
     * Resource status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: FrontDoorResourceState;
}

/** Contains a list of match conditions, and an action on how to modify the request/response. If multiple rules match, the actions from one rule that conflict with a previous rule overwrite for a singular action, or append in the case of headers manipulation. */
export declare interface RulesEngineRule {
    /** A name to refer to this specific rule. */
    name: string;
    /** A priority assigned to this rule. */
    priority: number;
    /** Actions to perform on the request and response if all of the match conditions are met. */
    action: RulesEngineAction;
    /** A list of match conditions that must meet in order for the actions of this rule to run. Having no match conditions means the actions will always run. */
    matchConditions?: RulesEngineMatchCondition[];
    /** If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue. */
    matchProcessingBehavior?: MatchProcessingBehavior;
}

/** Interface representing a RulesEngines. */
export declare interface RulesEngines {
    /**
     * Lists all of the Rules Engine Configurations within a Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    listByFrontDoor(resourceGroupName: string, frontDoorName: string, options?: RulesEnginesListByFrontDoorOptionalParams): PagedAsyncIterableIterator<RulesEngine>;
    /**
     * Gets a Rules Engine Configuration with the specified name within the specified Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param rulesEngineName Name of the Rules Engine which is unique within the Front Door.
     * @param options The options parameters.
     */
    get(resourceGroupName: string, frontDoorName: string, rulesEngineName: string, options?: RulesEnginesGetOptionalParams): Promise<RulesEnginesGetResponse>;
    /**
     * Creates a new Rules Engine Configuration with the specified name within the specified Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param rulesEngineName Name of the Rules Engine which is unique within the Front Door.
     * @param rulesEngineParameters Rules Engine Configuration properties needed to create a new Rules
     *                              Engine Configuration.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName: string, frontDoorName: string, rulesEngineName: string, rulesEngineParameters: RulesEngine, options?: RulesEnginesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<RulesEnginesCreateOrUpdateResponse>, RulesEnginesCreateOrUpdateResponse>>;
    /**
     * Creates a new Rules Engine Configuration with the specified name within the specified Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param rulesEngineName Name of the Rules Engine which is unique within the Front Door.
     * @param rulesEngineParameters Rules Engine Configuration properties needed to create a new Rules
     *                              Engine Configuration.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName: string, frontDoorName: string, rulesEngineName: string, rulesEngineParameters: RulesEngine, options?: RulesEnginesCreateOrUpdateOptionalParams): Promise<RulesEnginesCreateOrUpdateResponse>;
    /**
     * Deletes an existing Rules Engine Configuration with the specified parameters.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param rulesEngineName Name of the Rules Engine which is unique within the Front Door.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName: string, frontDoorName: string, rulesEngineName: string, options?: RulesEnginesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    /**
     * Deletes an existing Rules Engine Configuration with the specified parameters.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param rulesEngineName Name of the Rules Engine which is unique within the Front Door.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName: string, frontDoorName: string, rulesEngineName: string, options?: RulesEnginesDeleteOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface RulesEnginesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export declare type RulesEnginesCreateOrUpdateResponse = RulesEngine;

/** Optional parameters. */
export declare interface RulesEnginesDeleteOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Optional parameters. */
export declare interface RulesEnginesGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type RulesEnginesGetResponse = RulesEngine;

/** Optional parameters. */
export declare interface RulesEnginesListByFrontDoorNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByFrontDoorNext operation. */
export declare type RulesEnginesListByFrontDoorNextResponse = RulesEngineListResult;

/** Optional parameters. */
export declare interface RulesEnginesListByFrontDoorOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listByFrontDoor operation. */
export declare type RulesEnginesListByFrontDoorResponse = RulesEngineListResult;

/** Rules Engine Configuration to apply to a Routing Rule. */
export declare interface RulesEngineUpdateParameters {
    /** A list of rules that define a particular Rules Engine Configuration. */
    rules?: RulesEngineRule[];
}

/**
 * Defines values for RuleType. \
 * {@link KnownRuleType} can be used interchangeably with RuleType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **MatchRule** \
 * **RateLimitRule**
 */
export declare type RuleType = string;

/**
 * Defines values for ScrubbingRuleEntryMatchOperator. \
 * {@link KnownScrubbingRuleEntryMatchOperator} can be used interchangeably with ScrubbingRuleEntryMatchOperator,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **EqualsAny** \
 * **Equals**
 */
export declare type ScrubbingRuleEntryMatchOperator = string;

/**
 * Defines values for ScrubbingRuleEntryMatchVariable. \
 * {@link KnownScrubbingRuleEntryMatchVariable} can be used interchangeably with ScrubbingRuleEntryMatchVariable,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **RequestIPAddress** \
 * **RequestUri** \
 * **QueryStringArgNames** \
 * **RequestHeaderNames** \
 * **RequestCookieNames** \
 * **RequestBodyPostArgNames** \
 * **RequestBodyJsonArgNames**
 */
export declare type ScrubbingRuleEntryMatchVariable = string;

/**
 * Defines values for ScrubbingRuleEntryState. \
 * {@link KnownScrubbingRuleEntryState} can be used interchangeably with ScrubbingRuleEntryState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export declare type ScrubbingRuleEntryState = string;

/** Defines the Resource ID for a Security Policy. */
export declare interface SecurityPolicyLink {
    /** Resource ID. */
    id?: string;
}

/**
 * Defines values for SessionAffinityEnabledState. \
 * {@link KnownSessionAffinityEnabledState} can be used interchangeably with SessionAffinityEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export declare type SessionAffinityEnabledState = string;

/** The pricing tier of the web application firewall policy. */
export declare interface Sku {
    /** Name of the pricing tier. */
    name?: SkuName;
}

/**
 * Defines values for SkuName. \
 * {@link KnownSkuName} can be used interchangeably with SkuName,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Classic_AzureFrontDoor** \
 * **Standard_AzureFrontDoor** \
 * **Premium_AzureFrontDoor**
 */
export declare type SkuName = string;

/**
 * Defines values for State. \
 * {@link KnownState} can be used interchangeably with State,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export declare type State = string;

/** Reference to another subresource. */
export declare interface SubResource {
    /** Resource ID. */
    id?: string;
}

/** Tags object for patch operations. */
export declare interface TagsObject {
    /** Resource tags. */
    tags?: {
        [propertyName: string]: string;
    };
}

/** Defines the Timeseries */
export declare interface Timeseries extends Resource {
    /** The endpoint associated with the Timeseries data point */
    endpoint?: string;
    /** The start DateTime of the Timeseries in UTC */
    startDateTimeUTC?: string;
    /** The end DateTime of the Timeseries in UTC */
    endDateTimeUTC?: string;
    /** The aggregation interval of the Timeseries */
    aggregationInterval?: AggregationInterval;
    /** The type of Timeseries */
    timeseriesType?: TimeseriesType;
    /** The country associated with the Timeseries. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html */
    country?: string;
    /** The set of data points for the timeseries */
    timeseriesData?: TimeseriesDataPoint[];
}

/**
 * Defines values for TimeseriesAggregationInterval. \
 * {@link KnownTimeseriesAggregationInterval} can be used interchangeably with TimeseriesAggregationInterval,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Hourly** \
 * **Daily**
 */
export declare type TimeseriesAggregationInterval = string;

/** Defines a timeseries datapoint used in a timeseries */
export declare interface TimeseriesDataPoint {
    /** The DateTime of the Timeseries data point in UTC */
    dateTimeUTC?: string;
    /** The Value of the Timeseries data point */
    value?: number;
}

/**
 * Defines values for TimeseriesType. \
 * {@link KnownTimeseriesType} can be used interchangeably with TimeseriesType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **MeasurementCounts** \
 * **LatencyP50** \
 * **LatencyP75** \
 * **LatencyP95**
 */
export declare type TimeseriesType = string;

/**
 * Defines values for Transform. \
 * {@link KnownTransform} can be used interchangeably with Transform,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Lowercase** \
 * **Uppercase** \
 * **Trim** \
 * **UrlDecode** \
 * **UrlEncode** \
 * **RemoveNulls**
 */
export declare type Transform = string;

/**
 * Defines values for TransformType. \
 * {@link KnownTransformType} can be used interchangeably with TransformType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Lowercase** \
 * **Uppercase** \
 * **Trim** \
 * **UrlDecode** \
 * **UrlEncode** \
 * **RemoveNulls**
 */
export declare type TransformType = string;

/** Input of the custom domain to be validated for DNS mapping. */
export declare interface ValidateCustomDomainInput {
    /** The host name of the custom domain. Must be a domain name. */
    hostName: string;
}

/** Output of custom domain validation. */
export declare interface ValidateCustomDomainOutput {
    /**
     * Indicates whether the custom domain is valid or not.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly customDomainValidated?: boolean;
    /**
     * The reason why the custom domain is not valid.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly reason?: string;
    /**
     * Error message describing why the custom domain is not valid.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
}

/**
 * Defines values for VariableName. \
 * {@link KnownVariableName} can be used interchangeably with VariableName,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **SocketAddr** \
 * **GeoLocation** \
 * **None**
 */
export declare type VariableName = string;

/** Defines web application firewall policy. */
export declare interface WebApplicationFirewallPolicy extends Resource {
    /** Gets a unique read-only string that changes whenever the resource is updated. */
    etag?: string;
    /** The pricing tier of web application firewall policy. Defaults to Classic_AzureFrontDoor if not specified. */
    sku?: Sku;
    /** Describes settings for the policy. */
    policySettings?: PolicySettings;
    /** Describes custom rules inside the policy. */
    customRules?: CustomRuleList;
    /** Describes managed rules inside the policy. */
    managedRules?: ManagedRuleSetList;
    /**
     * Describes Frontend Endpoints associated with this Web Application Firewall policy.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly frontendEndpointLinks?: FrontendEndpointLink[];
    /**
     * Describes Routing Rules associated with this Web Application Firewall policy.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly routingRuleLinks?: RoutingRuleLink[];
    /**
     * Describes Security Policy associated with this Web Application Firewall policy.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly securityPolicyLinks?: SecurityPolicyLink[];
    /**
     * Provisioning state of the policy.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: string;
    /**
     * Resource status of the policy.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceState?: PolicyResourceState;
}

/** Defines a list of WebApplicationFirewallPolicies. It contains a list of WebApplicationFirewallPolicy objects and a URL link to get the next set of results. */
export declare interface WebApplicationFirewallPolicyList {
    /**
     * List of WebApplicationFirewallPolicies within a resource group.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: WebApplicationFirewallPolicy[];
    /** URL to get the next set of WebApplicationFirewallPolicy objects if there are any. */
    nextLink?: string;
}

/** Defines the contents of the log scrubbing rules. */
export declare interface WebApplicationFirewallScrubbingRules {
    /** The variable to be scrubbed from the logs. */
    matchVariable: ScrubbingRuleEntryMatchVariable;
    /** When matchVariable is a collection, operate on the selector to specify which elements in the collection this rule applies to. */
    selectorMatchOperator: ScrubbingRuleEntryMatchOperator;
    /** When matchVariable is a collection, operator used to specify which elements in the collection this rule applies to. */
    selector?: string;
    /** Defines the state of a log scrubbing rule. Default value is enabled. */
    state?: ScrubbingRuleEntryState;
}

/**
 * Defines values for WebApplicationFirewallScrubbingState. \
 * {@link KnownWebApplicationFirewallScrubbingState} can be used interchangeably with WebApplicationFirewallScrubbingState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export declare type WebApplicationFirewallScrubbingState = string;

export { }
