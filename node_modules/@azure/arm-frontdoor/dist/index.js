'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespaceDefault(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link PolicyEnabledState} that the service accepts. */
exports.KnownPolicyEnabledState = void 0;
(function (KnownPolicyEnabledState) {
    /** Disabled */
    KnownPolicyEnabledState["Disabled"] = "Disabled";
    /** Enabled */
    KnownPolicyEnabledState["Enabled"] = "Enabled";
})(exports.KnownPolicyEnabledState || (exports.KnownPolicyEnabledState = {}));
/** Known values of {@link PolicyMode} that the service accepts. */
exports.KnownPolicyMode = void 0;
(function (KnownPolicyMode) {
    /** Prevention */
    KnownPolicyMode["Prevention"] = "Prevention";
    /** Detection */
    KnownPolicyMode["Detection"] = "Detection";
})(exports.KnownPolicyMode || (exports.KnownPolicyMode = {}));
/** Known values of {@link PolicyRequestBodyCheck} that the service accepts. */
exports.KnownPolicyRequestBodyCheck = void 0;
(function (KnownPolicyRequestBodyCheck) {
    /** Disabled */
    KnownPolicyRequestBodyCheck["Disabled"] = "Disabled";
    /** Enabled */
    KnownPolicyRequestBodyCheck["Enabled"] = "Enabled";
})(exports.KnownPolicyRequestBodyCheck || (exports.KnownPolicyRequestBodyCheck = {}));
/** Known values of {@link WebApplicationFirewallScrubbingState} that the service accepts. */
exports.KnownWebApplicationFirewallScrubbingState = void 0;
(function (KnownWebApplicationFirewallScrubbingState) {
    /** Enabled */
    KnownWebApplicationFirewallScrubbingState["Enabled"] = "Enabled";
    /** Disabled */
    KnownWebApplicationFirewallScrubbingState["Disabled"] = "Disabled";
})(exports.KnownWebApplicationFirewallScrubbingState || (exports.KnownWebApplicationFirewallScrubbingState = {}));
/** Known values of {@link ScrubbingRuleEntryMatchVariable} that the service accepts. */
exports.KnownScrubbingRuleEntryMatchVariable = void 0;
(function (KnownScrubbingRuleEntryMatchVariable) {
    /** RequestIPAddress */
    KnownScrubbingRuleEntryMatchVariable["RequestIPAddress"] = "RequestIPAddress";
    /** RequestUri */
    KnownScrubbingRuleEntryMatchVariable["RequestUri"] = "RequestUri";
    /** QueryStringArgNames */
    KnownScrubbingRuleEntryMatchVariable["QueryStringArgNames"] = "QueryStringArgNames";
    /** RequestHeaderNames */
    KnownScrubbingRuleEntryMatchVariable["RequestHeaderNames"] = "RequestHeaderNames";
    /** RequestCookieNames */
    KnownScrubbingRuleEntryMatchVariable["RequestCookieNames"] = "RequestCookieNames";
    /** RequestBodyPostArgNames */
    KnownScrubbingRuleEntryMatchVariable["RequestBodyPostArgNames"] = "RequestBodyPostArgNames";
    /** RequestBodyJsonArgNames */
    KnownScrubbingRuleEntryMatchVariable["RequestBodyJsonArgNames"] = "RequestBodyJsonArgNames";
})(exports.KnownScrubbingRuleEntryMatchVariable || (exports.KnownScrubbingRuleEntryMatchVariable = {}));
/** Known values of {@link ScrubbingRuleEntryMatchOperator} that the service accepts. */
exports.KnownScrubbingRuleEntryMatchOperator = void 0;
(function (KnownScrubbingRuleEntryMatchOperator) {
    /** EqualsAny */
    KnownScrubbingRuleEntryMatchOperator["EqualsAny"] = "EqualsAny";
    /** Equals */
    KnownScrubbingRuleEntryMatchOperator["Equals"] = "Equals";
})(exports.KnownScrubbingRuleEntryMatchOperator || (exports.KnownScrubbingRuleEntryMatchOperator = {}));
/** Known values of {@link ScrubbingRuleEntryState} that the service accepts. */
exports.KnownScrubbingRuleEntryState = void 0;
(function (KnownScrubbingRuleEntryState) {
    /** Enabled */
    KnownScrubbingRuleEntryState["Enabled"] = "Enabled";
    /** Disabled */
    KnownScrubbingRuleEntryState["Disabled"] = "Disabled";
})(exports.KnownScrubbingRuleEntryState || (exports.KnownScrubbingRuleEntryState = {}));
/** Known values of {@link CustomRuleEnabledState} that the service accepts. */
exports.KnownCustomRuleEnabledState = void 0;
(function (KnownCustomRuleEnabledState) {
    /** Disabled */
    KnownCustomRuleEnabledState["Disabled"] = "Disabled";
    /** Enabled */
    KnownCustomRuleEnabledState["Enabled"] = "Enabled";
})(exports.KnownCustomRuleEnabledState || (exports.KnownCustomRuleEnabledState = {}));
/** Known values of {@link RuleType} that the service accepts. */
exports.KnownRuleType = void 0;
(function (KnownRuleType) {
    /** MatchRule */
    KnownRuleType["MatchRule"] = "MatchRule";
    /** RateLimitRule */
    KnownRuleType["RateLimitRule"] = "RateLimitRule";
})(exports.KnownRuleType || (exports.KnownRuleType = {}));
/** Known values of {@link VariableName} that the service accepts. */
exports.KnownVariableName = void 0;
(function (KnownVariableName) {
    /** SocketAddr */
    KnownVariableName["SocketAddr"] = "SocketAddr";
    /** GeoLocation */
    KnownVariableName["GeoLocation"] = "GeoLocation";
    /** None */
    KnownVariableName["None"] = "None";
})(exports.KnownVariableName || (exports.KnownVariableName = {}));
/** Known values of {@link MatchVariable} that the service accepts. */
exports.KnownMatchVariable = void 0;
(function (KnownMatchVariable) {
    /** RemoteAddr */
    KnownMatchVariable["RemoteAddr"] = "RemoteAddr";
    /** RequestMethod */
    KnownMatchVariable["RequestMethod"] = "RequestMethod";
    /** QueryString */
    KnownMatchVariable["QueryString"] = "QueryString";
    /** PostArgs */
    KnownMatchVariable["PostArgs"] = "PostArgs";
    /** RequestUri */
    KnownMatchVariable["RequestUri"] = "RequestUri";
    /** RequestHeader */
    KnownMatchVariable["RequestHeader"] = "RequestHeader";
    /** RequestBody */
    KnownMatchVariable["RequestBody"] = "RequestBody";
    /** Cookies */
    KnownMatchVariable["Cookies"] = "Cookies";
    /** SocketAddr */
    KnownMatchVariable["SocketAddr"] = "SocketAddr";
})(exports.KnownMatchVariable || (exports.KnownMatchVariable = {}));
/** Known values of {@link Operator} that the service accepts. */
exports.KnownOperator = void 0;
(function (KnownOperator) {
    /** Any */
    KnownOperator["Any"] = "Any";
    /** IPMatch */
    KnownOperator["IPMatch"] = "IPMatch";
    /** GeoMatch */
    KnownOperator["GeoMatch"] = "GeoMatch";
    /** Equal */
    KnownOperator["Equal"] = "Equal";
    /** Contains */
    KnownOperator["Contains"] = "Contains";
    /** LessThan */
    KnownOperator["LessThan"] = "LessThan";
    /** GreaterThan */
    KnownOperator["GreaterThan"] = "GreaterThan";
    /** LessThanOrEqual */
    KnownOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThanOrEqual */
    KnownOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** BeginsWith */
    KnownOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownOperator["EndsWith"] = "EndsWith";
    /** RegEx */
    KnownOperator["RegEx"] = "RegEx";
})(exports.KnownOperator || (exports.KnownOperator = {}));
/** Known values of {@link TransformType} that the service accepts. */
exports.KnownTransformType = void 0;
(function (KnownTransformType) {
    /** Lowercase */
    KnownTransformType["Lowercase"] = "Lowercase";
    /** Uppercase */
    KnownTransformType["Uppercase"] = "Uppercase";
    /** Trim */
    KnownTransformType["Trim"] = "Trim";
    /** UrlDecode */
    KnownTransformType["UrlDecode"] = "UrlDecode";
    /** UrlEncode */
    KnownTransformType["UrlEncode"] = "UrlEncode";
    /** RemoveNulls */
    KnownTransformType["RemoveNulls"] = "RemoveNulls";
})(exports.KnownTransformType || (exports.KnownTransformType = {}));
/** Known values of {@link ActionType} that the service accepts. */
exports.KnownActionType = void 0;
(function (KnownActionType) {
    /** Allow */
    KnownActionType["Allow"] = "Allow";
    /** Block */
    KnownActionType["Block"] = "Block";
    /** Log */
    KnownActionType["Log"] = "Log";
    /** Redirect */
    KnownActionType["Redirect"] = "Redirect";
    /** AnomalyScoring */
    KnownActionType["AnomalyScoring"] = "AnomalyScoring";
    /** JSChallenge */
    KnownActionType["JSChallenge"] = "JSChallenge";
})(exports.KnownActionType || (exports.KnownActionType = {}));
/** Known values of {@link ManagedRuleSetActionType} that the service accepts. */
exports.KnownManagedRuleSetActionType = void 0;
(function (KnownManagedRuleSetActionType) {
    /** Block */
    KnownManagedRuleSetActionType["Block"] = "Block";
    /** Log */
    KnownManagedRuleSetActionType["Log"] = "Log";
    /** Redirect */
    KnownManagedRuleSetActionType["Redirect"] = "Redirect";
})(exports.KnownManagedRuleSetActionType || (exports.KnownManagedRuleSetActionType = {}));
/** Known values of {@link ManagedRuleExclusionMatchVariable} that the service accepts. */
exports.KnownManagedRuleExclusionMatchVariable = void 0;
(function (KnownManagedRuleExclusionMatchVariable) {
    /** RequestHeaderNames */
    KnownManagedRuleExclusionMatchVariable["RequestHeaderNames"] = "RequestHeaderNames";
    /** RequestCookieNames */
    KnownManagedRuleExclusionMatchVariable["RequestCookieNames"] = "RequestCookieNames";
    /** QueryStringArgNames */
    KnownManagedRuleExclusionMatchVariable["QueryStringArgNames"] = "QueryStringArgNames";
    /** RequestBodyPostArgNames */
    KnownManagedRuleExclusionMatchVariable["RequestBodyPostArgNames"] = "RequestBodyPostArgNames";
    /** RequestBodyJsonArgNames */
    KnownManagedRuleExclusionMatchVariable["RequestBodyJsonArgNames"] = "RequestBodyJsonArgNames";
})(exports.KnownManagedRuleExclusionMatchVariable || (exports.KnownManagedRuleExclusionMatchVariable = {}));
/** Known values of {@link ManagedRuleExclusionSelectorMatchOperator} that the service accepts. */
exports.KnownManagedRuleExclusionSelectorMatchOperator = void 0;
(function (KnownManagedRuleExclusionSelectorMatchOperator) {
    /** Equals */
    KnownManagedRuleExclusionSelectorMatchOperator["Equals"] = "Equals";
    /** Contains */
    KnownManagedRuleExclusionSelectorMatchOperator["Contains"] = "Contains";
    /** StartsWith */
    KnownManagedRuleExclusionSelectorMatchOperator["StartsWith"] = "StartsWith";
    /** EndsWith */
    KnownManagedRuleExclusionSelectorMatchOperator["EndsWith"] = "EndsWith";
    /** EqualsAny */
    KnownManagedRuleExclusionSelectorMatchOperator["EqualsAny"] = "EqualsAny";
})(exports.KnownManagedRuleExclusionSelectorMatchOperator || (exports.KnownManagedRuleExclusionSelectorMatchOperator = {}));
/** Known values of {@link ManagedRuleEnabledState} that the service accepts. */
exports.KnownManagedRuleEnabledState = void 0;
(function (KnownManagedRuleEnabledState) {
    /** Disabled */
    KnownManagedRuleEnabledState["Disabled"] = "Disabled";
    /** Enabled */
    KnownManagedRuleEnabledState["Enabled"] = "Enabled";
})(exports.KnownManagedRuleEnabledState || (exports.KnownManagedRuleEnabledState = {}));
/** Known values of {@link PolicyResourceState} that the service accepts. */
exports.KnownPolicyResourceState = void 0;
(function (KnownPolicyResourceState) {
    /** Creating */
    KnownPolicyResourceState["Creating"] = "Creating";
    /** Enabling */
    KnownPolicyResourceState["Enabling"] = "Enabling";
    /** Enabled */
    KnownPolicyResourceState["Enabled"] = "Enabled";
    /** Disabling */
    KnownPolicyResourceState["Disabling"] = "Disabling";
    /** Disabled */
    KnownPolicyResourceState["Disabled"] = "Disabled";
    /** Deleting */
    KnownPolicyResourceState["Deleting"] = "Deleting";
})(exports.KnownPolicyResourceState || (exports.KnownPolicyResourceState = {}));
/** Known values of {@link SkuName} that the service accepts. */
exports.KnownSkuName = void 0;
(function (KnownSkuName) {
    /** ClassicAzureFrontDoor */
    KnownSkuName["ClassicAzureFrontDoor"] = "Classic_AzureFrontDoor";
    /** StandardAzureFrontDoor */
    KnownSkuName["StandardAzureFrontDoor"] = "Standard_AzureFrontDoor";
    /** PremiumAzureFrontDoor */
    KnownSkuName["PremiumAzureFrontDoor"] = "Premium_AzureFrontDoor";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
/** Known values of {@link Availability} that the service accepts. */
exports.KnownAvailability = void 0;
(function (KnownAvailability) {
    /** Available */
    KnownAvailability["Available"] = "Available";
    /** Unavailable */
    KnownAvailability["Unavailable"] = "Unavailable";
})(exports.KnownAvailability || (exports.KnownAvailability = {}));
/** Known values of {@link FrontDoorResourceState} that the service accepts. */
exports.KnownFrontDoorResourceState = void 0;
(function (KnownFrontDoorResourceState) {
    /** Creating */
    KnownFrontDoorResourceState["Creating"] = "Creating";
    /** Enabling */
    KnownFrontDoorResourceState["Enabling"] = "Enabling";
    /** Enabled */
    KnownFrontDoorResourceState["Enabled"] = "Enabled";
    /** Disabling */
    KnownFrontDoorResourceState["Disabling"] = "Disabling";
    /** Disabled */
    KnownFrontDoorResourceState["Disabled"] = "Disabled";
    /** Deleting */
    KnownFrontDoorResourceState["Deleting"] = "Deleting";
    /** Migrating */
    KnownFrontDoorResourceState["Migrating"] = "Migrating";
    /** Migrated */
    KnownFrontDoorResourceState["Migrated"] = "Migrated";
})(exports.KnownFrontDoorResourceState || (exports.KnownFrontDoorResourceState = {}));
/** Known values of {@link HeaderActionType} that the service accepts. */
exports.KnownHeaderActionType = void 0;
(function (KnownHeaderActionType) {
    /** Append */
    KnownHeaderActionType["Append"] = "Append";
    /** Delete */
    KnownHeaderActionType["Delete"] = "Delete";
    /** Overwrite */
    KnownHeaderActionType["Overwrite"] = "Overwrite";
})(exports.KnownHeaderActionType || (exports.KnownHeaderActionType = {}));
/** Known values of {@link RulesEngineMatchVariable} that the service accepts. */
exports.KnownRulesEngineMatchVariable = void 0;
(function (KnownRulesEngineMatchVariable) {
    /** IsMobile */
    KnownRulesEngineMatchVariable["IsMobile"] = "IsMobile";
    /** RemoteAddr */
    KnownRulesEngineMatchVariable["RemoteAddr"] = "RemoteAddr";
    /** RequestMethod */
    KnownRulesEngineMatchVariable["RequestMethod"] = "RequestMethod";
    /** QueryString */
    KnownRulesEngineMatchVariable["QueryString"] = "QueryString";
    /** PostArgs */
    KnownRulesEngineMatchVariable["PostArgs"] = "PostArgs";
    /** RequestUri */
    KnownRulesEngineMatchVariable["RequestUri"] = "RequestUri";
    /** RequestPath */
    KnownRulesEngineMatchVariable["RequestPath"] = "RequestPath";
    /** RequestFilename */
    KnownRulesEngineMatchVariable["RequestFilename"] = "RequestFilename";
    /** RequestFilenameExtension */
    KnownRulesEngineMatchVariable["RequestFilenameExtension"] = "RequestFilenameExtension";
    /** RequestHeader */
    KnownRulesEngineMatchVariable["RequestHeader"] = "RequestHeader";
    /** RequestBody */
    KnownRulesEngineMatchVariable["RequestBody"] = "RequestBody";
    /** RequestScheme */
    KnownRulesEngineMatchVariable["RequestScheme"] = "RequestScheme";
})(exports.KnownRulesEngineMatchVariable || (exports.KnownRulesEngineMatchVariable = {}));
/** Known values of {@link RulesEngineOperator} that the service accepts. */
exports.KnownRulesEngineOperator = void 0;
(function (KnownRulesEngineOperator) {
    /** Any */
    KnownRulesEngineOperator["Any"] = "Any";
    /** IPMatch */
    KnownRulesEngineOperator["IPMatch"] = "IPMatch";
    /** GeoMatch */
    KnownRulesEngineOperator["GeoMatch"] = "GeoMatch";
    /** Equal */
    KnownRulesEngineOperator["Equal"] = "Equal";
    /** Contains */
    KnownRulesEngineOperator["Contains"] = "Contains";
    /** LessThan */
    KnownRulesEngineOperator["LessThan"] = "LessThan";
    /** GreaterThan */
    KnownRulesEngineOperator["GreaterThan"] = "GreaterThan";
    /** LessThanOrEqual */
    KnownRulesEngineOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThanOrEqual */
    KnownRulesEngineOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** BeginsWith */
    KnownRulesEngineOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownRulesEngineOperator["EndsWith"] = "EndsWith";
})(exports.KnownRulesEngineOperator || (exports.KnownRulesEngineOperator = {}));
/** Known values of {@link Transform} that the service accepts. */
exports.KnownTransform = void 0;
(function (KnownTransform) {
    /** Lowercase */
    KnownTransform["Lowercase"] = "Lowercase";
    /** Uppercase */
    KnownTransform["Uppercase"] = "Uppercase";
    /** Trim */
    KnownTransform["Trim"] = "Trim";
    /** UrlDecode */
    KnownTransform["UrlDecode"] = "UrlDecode";
    /** UrlEncode */
    KnownTransform["UrlEncode"] = "UrlEncode";
    /** RemoveNulls */
    KnownTransform["RemoveNulls"] = "RemoveNulls";
})(exports.KnownTransform || (exports.KnownTransform = {}));
/** Known values of {@link MatchProcessingBehavior} that the service accepts. */
exports.KnownMatchProcessingBehavior = void 0;
(function (KnownMatchProcessingBehavior) {
    /** Continue */
    KnownMatchProcessingBehavior["Continue"] = "Continue";
    /** Stop */
    KnownMatchProcessingBehavior["Stop"] = "Stop";
})(exports.KnownMatchProcessingBehavior || (exports.KnownMatchProcessingBehavior = {}));
/** Known values of {@link FrontDoorProtocol} that the service accepts. */
exports.KnownFrontDoorProtocol = void 0;
(function (KnownFrontDoorProtocol) {
    /** Http */
    KnownFrontDoorProtocol["Http"] = "Http";
    /** Https */
    KnownFrontDoorProtocol["Https"] = "Https";
})(exports.KnownFrontDoorProtocol || (exports.KnownFrontDoorProtocol = {}));
/** Known values of {@link RoutingRuleEnabledState} that the service accepts. */
exports.KnownRoutingRuleEnabledState = void 0;
(function (KnownRoutingRuleEnabledState) {
    /** Enabled */
    KnownRoutingRuleEnabledState["Enabled"] = "Enabled";
    /** Disabled */
    KnownRoutingRuleEnabledState["Disabled"] = "Disabled";
})(exports.KnownRoutingRuleEnabledState || (exports.KnownRoutingRuleEnabledState = {}));
/** Known values of {@link FrontDoorHealthProbeMethod} that the service accepts. */
exports.KnownFrontDoorHealthProbeMethod = void 0;
(function (KnownFrontDoorHealthProbeMethod) {
    /** GET */
    KnownFrontDoorHealthProbeMethod["GET"] = "GET";
    /** Head */
    KnownFrontDoorHealthProbeMethod["Head"] = "HEAD";
})(exports.KnownFrontDoorHealthProbeMethod || (exports.KnownFrontDoorHealthProbeMethod = {}));
/** Known values of {@link HealthProbeEnabled} that the service accepts. */
exports.KnownHealthProbeEnabled = void 0;
(function (KnownHealthProbeEnabled) {
    /** Enabled */
    KnownHealthProbeEnabled["Enabled"] = "Enabled";
    /** Disabled */
    KnownHealthProbeEnabled["Disabled"] = "Disabled";
})(exports.KnownHealthProbeEnabled || (exports.KnownHealthProbeEnabled = {}));
/** Known values of {@link PrivateEndpointStatus} that the service accepts. */
exports.KnownPrivateEndpointStatus = void 0;
(function (KnownPrivateEndpointStatus) {
    /** Pending */
    KnownPrivateEndpointStatus["Pending"] = "Pending";
    /** Approved */
    KnownPrivateEndpointStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateEndpointStatus["Rejected"] = "Rejected";
    /** Disconnected */
    KnownPrivateEndpointStatus["Disconnected"] = "Disconnected";
    /** Timeout */
    KnownPrivateEndpointStatus["Timeout"] = "Timeout";
})(exports.KnownPrivateEndpointStatus || (exports.KnownPrivateEndpointStatus = {}));
/** Known values of {@link BackendEnabledState} that the service accepts. */
exports.KnownBackendEnabledState = void 0;
(function (KnownBackendEnabledState) {
    /** Enabled */
    KnownBackendEnabledState["Enabled"] = "Enabled";
    /** Disabled */
    KnownBackendEnabledState["Disabled"] = "Disabled";
})(exports.KnownBackendEnabledState || (exports.KnownBackendEnabledState = {}));
/** Known values of {@link CustomHttpsProvisioningState} that the service accepts. */
exports.KnownCustomHttpsProvisioningState = void 0;
(function (KnownCustomHttpsProvisioningState) {
    /** Enabling */
    KnownCustomHttpsProvisioningState["Enabling"] = "Enabling";
    /** Enabled */
    KnownCustomHttpsProvisioningState["Enabled"] = "Enabled";
    /** Disabling */
    KnownCustomHttpsProvisioningState["Disabling"] = "Disabling";
    /** Disabled */
    KnownCustomHttpsProvisioningState["Disabled"] = "Disabled";
    /** Failed */
    KnownCustomHttpsProvisioningState["Failed"] = "Failed";
})(exports.KnownCustomHttpsProvisioningState || (exports.KnownCustomHttpsProvisioningState = {}));
/** Known values of {@link CustomHttpsProvisioningSubstate} that the service accepts. */
exports.KnownCustomHttpsProvisioningSubstate = void 0;
(function (KnownCustomHttpsProvisioningSubstate) {
    /** SubmittingDomainControlValidationRequest */
    KnownCustomHttpsProvisioningSubstate["SubmittingDomainControlValidationRequest"] = "SubmittingDomainControlValidationRequest";
    /** PendingDomainControlValidationREquestApproval */
    KnownCustomHttpsProvisioningSubstate["PendingDomainControlValidationREquestApproval"] = "PendingDomainControlValidationREquestApproval";
    /** DomainControlValidationRequestApproved */
    KnownCustomHttpsProvisioningSubstate["DomainControlValidationRequestApproved"] = "DomainControlValidationRequestApproved";
    /** DomainControlValidationRequestRejected */
    KnownCustomHttpsProvisioningSubstate["DomainControlValidationRequestRejected"] = "DomainControlValidationRequestRejected";
    /** DomainControlValidationRequestTimedOut */
    KnownCustomHttpsProvisioningSubstate["DomainControlValidationRequestTimedOut"] = "DomainControlValidationRequestTimedOut";
    /** IssuingCertificate */
    KnownCustomHttpsProvisioningSubstate["IssuingCertificate"] = "IssuingCertificate";
    /** DeployingCertificate */
    KnownCustomHttpsProvisioningSubstate["DeployingCertificate"] = "DeployingCertificate";
    /** CertificateDeployed */
    KnownCustomHttpsProvisioningSubstate["CertificateDeployed"] = "CertificateDeployed";
    /** DeletingCertificate */
    KnownCustomHttpsProvisioningSubstate["DeletingCertificate"] = "DeletingCertificate";
    /** CertificateDeleted */
    KnownCustomHttpsProvisioningSubstate["CertificateDeleted"] = "CertificateDeleted";
})(exports.KnownCustomHttpsProvisioningSubstate || (exports.KnownCustomHttpsProvisioningSubstate = {}));
/** Known values of {@link FrontDoorCertificateSource} that the service accepts. */
exports.KnownFrontDoorCertificateSource = void 0;
(function (KnownFrontDoorCertificateSource) {
    /** AzureKeyVault */
    KnownFrontDoorCertificateSource["AzureKeyVault"] = "AzureKeyVault";
    /** FrontDoor */
    KnownFrontDoorCertificateSource["FrontDoor"] = "FrontDoor";
})(exports.KnownFrontDoorCertificateSource || (exports.KnownFrontDoorCertificateSource = {}));
/** Known values of {@link FrontDoorTlsProtocolType} that the service accepts. */
exports.KnownFrontDoorTlsProtocolType = void 0;
(function (KnownFrontDoorTlsProtocolType) {
    /** ServerNameIndication */
    KnownFrontDoorTlsProtocolType["ServerNameIndication"] = "ServerNameIndication";
})(exports.KnownFrontDoorTlsProtocolType || (exports.KnownFrontDoorTlsProtocolType = {}));
/** Known values of {@link MinimumTLSVersion} that the service accepts. */
exports.KnownMinimumTLSVersion = void 0;
(function (KnownMinimumTLSVersion) {
    /** One0 */
    KnownMinimumTLSVersion["One0"] = "1.0";
    /** One2 */
    KnownMinimumTLSVersion["One2"] = "1.2";
})(exports.KnownMinimumTLSVersion || (exports.KnownMinimumTLSVersion = {}));
/** Known values of {@link FrontDoorCertificateType} that the service accepts. */
exports.KnownFrontDoorCertificateType = void 0;
(function (KnownFrontDoorCertificateType) {
    /** Dedicated */
    KnownFrontDoorCertificateType["Dedicated"] = "Dedicated";
})(exports.KnownFrontDoorCertificateType || (exports.KnownFrontDoorCertificateType = {}));
/** Known values of {@link SessionAffinityEnabledState} that the service accepts. */
exports.KnownSessionAffinityEnabledState = void 0;
(function (KnownSessionAffinityEnabledState) {
    /** Enabled */
    KnownSessionAffinityEnabledState["Enabled"] = "Enabled";
    /** Disabled */
    KnownSessionAffinityEnabledState["Disabled"] = "Disabled";
})(exports.KnownSessionAffinityEnabledState || (exports.KnownSessionAffinityEnabledState = {}));
/** Known values of {@link EnforceCertificateNameCheckEnabledState} that the service accepts. */
exports.KnownEnforceCertificateNameCheckEnabledState = void 0;
(function (KnownEnforceCertificateNameCheckEnabledState) {
    /** Enabled */
    KnownEnforceCertificateNameCheckEnabledState["Enabled"] = "Enabled";
    /** Disabled */
    KnownEnforceCertificateNameCheckEnabledState["Disabled"] = "Disabled";
})(exports.KnownEnforceCertificateNameCheckEnabledState || (exports.KnownEnforceCertificateNameCheckEnabledState = {}));
/** Known values of {@link FrontDoorEnabledState} that the service accepts. */
exports.KnownFrontDoorEnabledState = void 0;
(function (KnownFrontDoorEnabledState) {
    /** Enabled */
    KnownFrontDoorEnabledState["Enabled"] = "Enabled";
    /** Disabled */
    KnownFrontDoorEnabledState["Disabled"] = "Disabled";
})(exports.KnownFrontDoorEnabledState || (exports.KnownFrontDoorEnabledState = {}));
/** Known values of {@link NetworkExperimentResourceState} that the service accepts. */
exports.KnownNetworkExperimentResourceState = void 0;
(function (KnownNetworkExperimentResourceState) {
    /** Creating */
    KnownNetworkExperimentResourceState["Creating"] = "Creating";
    /** Enabling */
    KnownNetworkExperimentResourceState["Enabling"] = "Enabling";
    /** Enabled */
    KnownNetworkExperimentResourceState["Enabled"] = "Enabled";
    /** Disabling */
    KnownNetworkExperimentResourceState["Disabling"] = "Disabling";
    /** Disabled */
    KnownNetworkExperimentResourceState["Disabled"] = "Disabled";
    /** Deleting */
    KnownNetworkExperimentResourceState["Deleting"] = "Deleting";
})(exports.KnownNetworkExperimentResourceState || (exports.KnownNetworkExperimentResourceState = {}));
/** Known values of {@link State} that the service accepts. */
exports.KnownState = void 0;
(function (KnownState) {
    /** Enabled */
    KnownState["Enabled"] = "Enabled";
    /** Disabled */
    KnownState["Disabled"] = "Disabled";
})(exports.KnownState || (exports.KnownState = {}));
/** Known values of {@link EndpointType} that the service accepts. */
exports.KnownEndpointType = void 0;
(function (KnownEndpointType) {
    /** AFD */
    KnownEndpointType["AFD"] = "AFD";
    /** AzureRegion */
    KnownEndpointType["AzureRegion"] = "AzureRegion";
    /** CDN */
    KnownEndpointType["CDN"] = "CDN";
    /** ATM */
    KnownEndpointType["ATM"] = "ATM";
})(exports.KnownEndpointType || (exports.KnownEndpointType = {}));
/** Known values of {@link LatencyScorecardAggregationInterval} that the service accepts. */
exports.KnownLatencyScorecardAggregationInterval = void 0;
(function (KnownLatencyScorecardAggregationInterval) {
    /** Daily */
    KnownLatencyScorecardAggregationInterval["Daily"] = "Daily";
    /** Weekly */
    KnownLatencyScorecardAggregationInterval["Weekly"] = "Weekly";
    /** Monthly */
    KnownLatencyScorecardAggregationInterval["Monthly"] = "Monthly";
})(exports.KnownLatencyScorecardAggregationInterval || (exports.KnownLatencyScorecardAggregationInterval = {}));
/** Known values of {@link TimeseriesAggregationInterval} that the service accepts. */
exports.KnownTimeseriesAggregationInterval = void 0;
(function (KnownTimeseriesAggregationInterval) {
    /** Hourly */
    KnownTimeseriesAggregationInterval["Hourly"] = "Hourly";
    /** Daily */
    KnownTimeseriesAggregationInterval["Daily"] = "Daily";
})(exports.KnownTimeseriesAggregationInterval || (exports.KnownTimeseriesAggregationInterval = {}));
/** Known values of {@link TimeseriesType} that the service accepts. */
exports.KnownTimeseriesType = void 0;
(function (KnownTimeseriesType) {
    /** MeasurementCounts */
    KnownTimeseriesType["MeasurementCounts"] = "MeasurementCounts";
    /** LatencyP50 */
    KnownTimeseriesType["LatencyP50"] = "LatencyP50";
    /** LatencyP75 */
    KnownTimeseriesType["LatencyP75"] = "LatencyP75";
    /** LatencyP95 */
    KnownTimeseriesType["LatencyP95"] = "LatencyP95";
})(exports.KnownTimeseriesType || (exports.KnownTimeseriesType = {}));
/** Known values of {@link AggregationInterval} that the service accepts. */
exports.KnownAggregationInterval = void 0;
(function (KnownAggregationInterval) {
    /** Hourly */
    KnownAggregationInterval["Hourly"] = "Hourly";
    /** Daily */
    KnownAggregationInterval["Daily"] = "Daily";
})(exports.KnownAggregationInterval || (exports.KnownAggregationInterval = {}));
/** Known values of {@link NetworkOperationStatus} that the service accepts. */
exports.KnownNetworkOperationStatus = void 0;
(function (KnownNetworkOperationStatus) {
    /** InProgress */
    KnownNetworkOperationStatus["InProgress"] = "InProgress";
    /** Succeeded */
    KnownNetworkOperationStatus["Succeeded"] = "Succeeded";
    /** Failed */
    KnownNetworkOperationStatus["Failed"] = "Failed";
})(exports.KnownNetworkOperationStatus || (exports.KnownNetworkOperationStatus = {}));
/** Known values of {@link FrontDoorForwardingProtocol} that the service accepts. */
exports.KnownFrontDoorForwardingProtocol = void 0;
(function (KnownFrontDoorForwardingProtocol) {
    /** HttpOnly */
    KnownFrontDoorForwardingProtocol["HttpOnly"] = "HttpOnly";
    /** HttpsOnly */
    KnownFrontDoorForwardingProtocol["HttpsOnly"] = "HttpsOnly";
    /** MatchRequest */
    KnownFrontDoorForwardingProtocol["MatchRequest"] = "MatchRequest";
})(exports.KnownFrontDoorForwardingProtocol || (exports.KnownFrontDoorForwardingProtocol = {}));
/** Known values of {@link FrontDoorQuery} that the service accepts. */
exports.KnownFrontDoorQuery = void 0;
(function (KnownFrontDoorQuery) {
    /** StripNone */
    KnownFrontDoorQuery["StripNone"] = "StripNone";
    /** StripAll */
    KnownFrontDoorQuery["StripAll"] = "StripAll";
    /** StripOnly */
    KnownFrontDoorQuery["StripOnly"] = "StripOnly";
    /** StripAllExcept */
    KnownFrontDoorQuery["StripAllExcept"] = "StripAllExcept";
})(exports.KnownFrontDoorQuery || (exports.KnownFrontDoorQuery = {}));
/** Known values of {@link DynamicCompressionEnabled} that the service accepts. */
exports.KnownDynamicCompressionEnabled = void 0;
(function (KnownDynamicCompressionEnabled) {
    /** Enabled */
    KnownDynamicCompressionEnabled["Enabled"] = "Enabled";
    /** Disabled */
    KnownDynamicCompressionEnabled["Disabled"] = "Disabled";
})(exports.KnownDynamicCompressionEnabled || (exports.KnownDynamicCompressionEnabled = {}));
/** Known values of {@link FrontDoorRedirectType} that the service accepts. */
exports.KnownFrontDoorRedirectType = void 0;
(function (KnownFrontDoorRedirectType) {
    /** Moved */
    KnownFrontDoorRedirectType["Moved"] = "Moved";
    /** Found */
    KnownFrontDoorRedirectType["Found"] = "Found";
    /** TemporaryRedirect */
    KnownFrontDoorRedirectType["TemporaryRedirect"] = "TemporaryRedirect";
    /** PermanentRedirect */
    KnownFrontDoorRedirectType["PermanentRedirect"] = "PermanentRedirect";
})(exports.KnownFrontDoorRedirectType || (exports.KnownFrontDoorRedirectType = {}));
/** Known values of {@link FrontDoorRedirectProtocol} that the service accepts. */
exports.KnownFrontDoorRedirectProtocol = void 0;
(function (KnownFrontDoorRedirectProtocol) {
    /** HttpOnly */
    KnownFrontDoorRedirectProtocol["HttpOnly"] = "HttpOnly";
    /** HttpsOnly */
    KnownFrontDoorRedirectProtocol["HttpsOnly"] = "HttpsOnly";
    /** MatchRequest */
    KnownFrontDoorRedirectProtocol["MatchRequest"] = "MatchRequest";
})(exports.KnownFrontDoorRedirectProtocol || (exports.KnownFrontDoorRedirectProtocol = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const WebApplicationFirewallPolicyList = {
    type: {
        name: "Composite",
        className: "WebApplicationFirewallPolicyList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebApplicationFirewallPolicy",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PolicySettings = {
    type: {
        name: "Composite",
        className: "PolicySettings",
        modelProperties: {
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String",
                },
            },
            mode: {
                serializedName: "mode",
                type: {
                    name: "String",
                },
            },
            redirectUrl: {
                serializedName: "redirectUrl",
                type: {
                    name: "String",
                },
            },
            customBlockResponseStatusCode: {
                serializedName: "customBlockResponseStatusCode",
                type: {
                    name: "Number",
                },
            },
            customBlockResponseBody: {
                constraints: {
                    Pattern: new RegExp("^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$"),
                },
                serializedName: "customBlockResponseBody",
                type: {
                    name: "String",
                },
            },
            requestBodyCheck: {
                serializedName: "requestBodyCheck",
                type: {
                    name: "String",
                },
            },
            javascriptChallengeExpirationInMinutes: {
                constraints: {
                    InclusiveMaximum: 1440,
                    InclusiveMinimum: 5,
                },
                serializedName: "javascriptChallengeExpirationInMinutes",
                type: {
                    name: "Number",
                },
            },
            state: {
                serializedName: "logScrubbing.state",
                type: {
                    name: "String",
                },
            },
            scrubbingRules: {
                serializedName: "logScrubbing.scrubbingRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebApplicationFirewallScrubbingRules",
                        },
                    },
                },
            },
        },
    },
};
const WebApplicationFirewallScrubbingRules = {
    type: {
        name: "Composite",
        className: "WebApplicationFirewallScrubbingRules",
        modelProperties: {
            matchVariable: {
                serializedName: "matchVariable",
                required: true,
                type: {
                    name: "String",
                },
            },
            selectorMatchOperator: {
                serializedName: "selectorMatchOperator",
                required: true,
                type: {
                    name: "String",
                },
            },
            selector: {
                serializedName: "selector",
                type: {
                    name: "String",
                },
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CustomRuleList = {
    type: {
        name: "Composite",
        className: "CustomRuleList",
        modelProperties: {
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomRule",
                        },
                    },
                },
            },
        },
    },
};
const CustomRule = {
    type: {
        name: "Composite",
        className: "CustomRule",
        modelProperties: {
            name: {
                constraints: {
                    MaxLength: 128,
                },
                serializedName: "name",
                type: {
                    name: "String",
                },
            },
            priority: {
                serializedName: "priority",
                required: true,
                type: {
                    name: "Number",
                },
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String",
                },
            },
            ruleType: {
                serializedName: "ruleType",
                required: true,
                type: {
                    name: "String",
                },
            },
            rateLimitDurationInMinutes: {
                constraints: {
                    InclusiveMaximum: 5,
                    InclusiveMinimum: 0,
                },
                serializedName: "rateLimitDurationInMinutes",
                type: {
                    name: "Number",
                },
            },
            rateLimitThreshold: {
                constraints: {
                    InclusiveMinimum: 0,
                },
                serializedName: "rateLimitThreshold",
                type: {
                    name: "Number",
                },
            },
            groupBy: {
                serializedName: "groupBy",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GroupByVariable",
                        },
                    },
                },
            },
            matchConditions: {
                serializedName: "matchConditions",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MatchCondition",
                        },
                    },
                },
            },
            action: {
                serializedName: "action",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const GroupByVariable = {
    type: {
        name: "Composite",
        className: "GroupByVariable",
        modelProperties: {
            variableName: {
                serializedName: "variableName",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MatchCondition = {
    type: {
        name: "Composite",
        className: "MatchCondition",
        modelProperties: {
            matchVariable: {
                serializedName: "matchVariable",
                required: true,
                type: {
                    name: "String",
                },
            },
            selector: {
                serializedName: "selector",
                type: {
                    name: "String",
                },
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String",
                },
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean",
                },
            },
            matchValue: {
                serializedName: "matchValue",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const ManagedRuleSetList = {
    type: {
        name: "Composite",
        className: "ManagedRuleSetList",
        modelProperties: {
            managedRuleSets: {
                serializedName: "managedRuleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleSet",
                        },
                    },
                },
            },
        },
    },
};
const ManagedRuleSet = {
    type: {
        name: "Composite",
        className: "ManagedRuleSet",
        modelProperties: {
            ruleSetType: {
                serializedName: "ruleSetType",
                required: true,
                type: {
                    name: "String",
                },
            },
            ruleSetVersion: {
                serializedName: "ruleSetVersion",
                required: true,
                type: {
                    name: "String",
                },
            },
            ruleSetAction: {
                serializedName: "ruleSetAction",
                type: {
                    name: "String",
                },
            },
            exclusions: {
                serializedName: "exclusions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleExclusion",
                        },
                    },
                },
            },
            ruleGroupOverrides: {
                serializedName: "ruleGroupOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleGroupOverride",
                        },
                    },
                },
            },
        },
    },
};
const ManagedRuleExclusion = {
    type: {
        name: "Composite",
        className: "ManagedRuleExclusion",
        modelProperties: {
            matchVariable: {
                serializedName: "matchVariable",
                required: true,
                type: {
                    name: "String",
                },
            },
            selectorMatchOperator: {
                serializedName: "selectorMatchOperator",
                required: true,
                type: {
                    name: "String",
                },
            },
            selector: {
                serializedName: "selector",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedRuleGroupOverride = {
    type: {
        name: "Composite",
        className: "ManagedRuleGroupOverride",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                required: true,
                type: {
                    name: "String",
                },
            },
            exclusions: {
                serializedName: "exclusions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleExclusion",
                        },
                    },
                },
            },
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleOverride",
                        },
                    },
                },
            },
        },
    },
};
const ManagedRuleOverride = {
    type: {
        name: "Composite",
        className: "ManagedRuleOverride",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                required: true,
                type: {
                    name: "String",
                },
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String",
                },
            },
            action: {
                serializedName: "action",
                type: {
                    name: "String",
                },
            },
            exclusions: {
                serializedName: "exclusions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleExclusion",
                        },
                    },
                },
            },
        },
    },
};
const FrontendEndpointLink = {
    type: {
        name: "Composite",
        className: "FrontendEndpointLink",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RoutingRuleLink = {
    type: {
        name: "Composite",
        className: "RoutingRuleLink",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SecurityPolicyLink = {
    type: {
        name: "Composite",
        className: "SecurityPolicyLink",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DefaultErrorResponse = {
    type: {
        name: "Composite",
        className: "DefaultErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "DefaultErrorResponseError",
                },
            },
        },
    },
};
const DefaultErrorResponseError = {
    type: {
        name: "Composite",
        className: "DefaultErrorResponseError",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TagsObject = {
    type: {
        name: "Composite",
        className: "TagsObject",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const ManagedRuleSetDefinitionList = {
    type: {
        name: "Composite",
        className: "ManagedRuleSetDefinitionList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleSetDefinition",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedRuleGroupDefinition = {
    type: {
        name: "Composite",
        className: "ManagedRuleGroupDefinition",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            rules: {
                serializedName: "rules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleDefinition",
                        },
                    },
                },
            },
        },
    },
};
const ManagedRuleDefinition = {
    type: {
        name: "Composite",
        className: "ManagedRuleDefinition",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            defaultState: {
                serializedName: "defaultState",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            defaultAction: {
                serializedName: "defaultAction",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CheckNameAvailabilityInput = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityInput",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Microsoft.Network/frontDoors",
                        "Microsoft.Network/frontDoors/frontendEndpoints",
                    ],
                },
            },
        },
    },
};
const CheckNameAvailabilityOutput = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityOutput",
        modelProperties: {
            nameAvailability: {
                serializedName: "nameAvailability",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FrontDoorListResult = {
    type: {
        name: "Composite",
        className: "FrontDoorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontDoor",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RulesEngine = {
    type: {
        name: "Composite",
        className: "RulesEngine",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RulesEngineRule",
                        },
                    },
                },
            },
            resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RulesEngineUpdateParameters = {
    type: {
        name: "Composite",
        className: "RulesEngineUpdateParameters",
        modelProperties: {
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RulesEngineRule",
                        },
                    },
                },
            },
        },
    },
};
const RulesEngineRule = {
    type: {
        name: "Composite",
        className: "RulesEngineRule",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            },
            priority: {
                serializedName: "priority",
                required: true,
                type: {
                    name: "Number",
                },
            },
            action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "RulesEngineAction",
                },
            },
            matchConditions: {
                serializedName: "matchConditions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RulesEngineMatchCondition",
                        },
                    },
                },
            },
            matchProcessingBehavior: {
                serializedName: "matchProcessingBehavior",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RulesEngineAction = {
    type: {
        name: "Composite",
        className: "RulesEngineAction",
        modelProperties: {
            requestHeaderActions: {
                serializedName: "requestHeaderActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HeaderAction",
                        },
                    },
                },
            },
            responseHeaderActions: {
                serializedName: "responseHeaderActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HeaderAction",
                        },
                    },
                },
            },
            routeConfigurationOverride: {
                serializedName: "routeConfigurationOverride",
                type: {
                    name: "Composite",
                    className: "RouteConfiguration",
                },
            },
        },
    },
};
const HeaderAction = {
    type: {
        name: "Composite",
        className: "HeaderAction",
        modelProperties: {
            headerActionType: {
                serializedName: "headerActionType",
                required: true,
                type: {
                    name: "String",
                },
            },
            headerName: {
                serializedName: "headerName",
                required: true,
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RouteConfiguration = {
    type: {
        name: "Composite",
        className: "RouteConfiguration",
        uberParent: "RouteConfiguration",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odataType",
        },
        modelProperties: {
            odataType: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RulesEngineMatchCondition = {
    type: {
        name: "Composite",
        className: "RulesEngineMatchCondition",
        modelProperties: {
            rulesEngineMatchVariable: {
                serializedName: "rulesEngineMatchVariable",
                required: true,
                type: {
                    name: "String",
                },
            },
            selector: {
                serializedName: "selector",
                type: {
                    name: "String",
                },
            },
            rulesEngineOperator: {
                serializedName: "rulesEngineOperator",
                required: true,
                type: {
                    name: "String",
                },
            },
            negateCondition: {
                serializedName: "negateCondition",
                type: {
                    name: "Boolean",
                },
            },
            rulesEngineMatchValue: {
                serializedName: "rulesEngineMatchValue",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const FrontDoorUpdateParameters = {
    type: {
        name: "Composite",
        className: "FrontDoorUpdateParameters",
        modelProperties: {
            friendlyName: {
                serializedName: "friendlyName",
                type: {
                    name: "String",
                },
            },
            routingRules: {
                serializedName: "routingRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoutingRule",
                        },
                    },
                },
            },
            loadBalancingSettings: {
                serializedName: "loadBalancingSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancingSettingsModel",
                        },
                    },
                },
            },
            healthProbeSettings: {
                serializedName: "healthProbeSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthProbeSettingsModel",
                        },
                    },
                },
            },
            backendPools: {
                serializedName: "backendPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackendPool",
                        },
                    },
                },
            },
            frontendEndpoints: {
                serializedName: "frontendEndpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontendEndpoint",
                        },
                    },
                },
            },
            backendPoolsSettings: {
                serializedName: "backendPoolsSettings",
                type: {
                    name: "Composite",
                    className: "BackendPoolsSettings",
                },
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RoutingRuleUpdateParameters = {
    type: {
        name: "Composite",
        className: "RoutingRuleUpdateParameters",
        modelProperties: {
            frontendEndpoints: {
                serializedName: "frontendEndpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource",
                        },
                    },
                },
            },
            acceptedProtocols: {
                serializedName: "acceptedProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            patternsToMatch: {
                serializedName: "patternsToMatch",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String",
                },
            },
            routeConfiguration: {
                serializedName: "routeConfiguration",
                type: {
                    name: "Composite",
                    className: "RouteConfiguration",
                },
            },
            rulesEngine: {
                serializedName: "rulesEngine",
                type: {
                    name: "Composite",
                    className: "SubResource",
                },
            },
            webApplicationFirewallPolicyLink: {
                serializedName: "webApplicationFirewallPolicyLink",
                type: {
                    name: "Composite",
                    className: "RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink",
                },
            },
        },
    },
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink = {
    type: {
        name: "Composite",
        className: "RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const LoadBalancingSettingsUpdateParameters = {
    type: {
        name: "Composite",
        className: "LoadBalancingSettingsUpdateParameters",
        modelProperties: {
            sampleSize: {
                serializedName: "sampleSize",
                type: {
                    name: "Number",
                },
            },
            successfulSamplesRequired: {
                serializedName: "successfulSamplesRequired",
                type: {
                    name: "Number",
                },
            },
            additionalLatencyMilliseconds: {
                serializedName: "additionalLatencyMilliseconds",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const HealthProbeSettingsUpdateParameters = {
    type: {
        name: "Composite",
        className: "HealthProbeSettingsUpdateParameters",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String",
                },
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String",
                },
            },
            intervalInSeconds: {
                serializedName: "intervalInSeconds",
                type: {
                    name: "Number",
                },
            },
            healthProbeMethod: {
                defaultValue: "HEAD",
                serializedName: "healthProbeMethod",
                type: {
                    name: "String",
                },
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const BackendPoolUpdateParameters = {
    type: {
        name: "Composite",
        className: "BackendPoolUpdateParameters",
        modelProperties: {
            backends: {
                serializedName: "backends",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Backend",
                        },
                    },
                },
            },
            loadBalancingSettings: {
                serializedName: "loadBalancingSettings",
                type: {
                    name: "Composite",
                    className: "SubResource",
                },
            },
            healthProbeSettings: {
                serializedName: "healthProbeSettings",
                type: {
                    name: "Composite",
                    className: "SubResource",
                },
            },
        },
    },
};
const Backend = {
    type: {
        name: "Composite",
        className: "Backend",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "String",
                },
            },
            privateLinkAlias: {
                serializedName: "privateLinkAlias",
                type: {
                    name: "String",
                },
            },
            privateLinkResourceId: {
                serializedName: "privateLinkResourceId",
                type: {
                    name: "String",
                },
            },
            privateLinkLocation: {
                serializedName: "privateLinkLocation",
                type: {
                    name: "String",
                },
            },
            privateEndpointStatus: {
                serializedName: "privateEndpointStatus",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            privateLinkApprovalMessage: {
                serializedName: "privateLinkApprovalMessage",
                type: {
                    name: "String",
                },
            },
            httpPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1,
                },
                serializedName: "httpPort",
                type: {
                    name: "Number",
                },
            },
            httpsPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1,
                },
                serializedName: "httpsPort",
                type: {
                    name: "Number",
                },
            },
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "String",
                },
            },
            priority: {
                constraints: {
                    InclusiveMaximum: 5,
                    InclusiveMinimum: 1,
                },
                serializedName: "priority",
                type: {
                    name: "Number",
                },
            },
            weight: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 1,
                },
                serializedName: "weight",
                type: {
                    name: "Number",
                },
            },
            backendHostHeader: {
                serializedName: "backendHostHeader",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CustomHttpsConfiguration = {
    type: {
        name: "Composite",
        className: "CustomHttpsConfiguration",
        modelProperties: {
            certificateSource: {
                serializedName: "certificateSource",
                required: true,
                type: {
                    name: "String",
                },
            },
            protocolType: {
                serializedName: "protocolType",
                required: true,
                type: {
                    name: "String",
                },
            },
            minimumTlsVersion: {
                serializedName: "minimumTlsVersion",
                required: true,
                type: {
                    name: "String",
                },
            },
            certificateType: {
                serializedName: "frontDoorCertificateSourceParameters.certificateType",
                type: {
                    name: "String",
                },
            },
            vault: {
                serializedName: "keyVaultCertificateSourceParameters.vault",
                type: {
                    name: "Composite",
                    className: "KeyVaultCertificateSourceParametersVault",
                },
            },
            secretName: {
                serializedName: "keyVaultCertificateSourceParameters.secretName",
                type: {
                    name: "String",
                },
            },
            secretVersion: {
                serializedName: "keyVaultCertificateSourceParameters.secretVersion",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const KeyVaultCertificateSourceParametersVault = {
    type: {
        name: "Composite",
        className: "KeyVaultCertificateSourceParametersVault",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FrontendEndpointUpdateParameters = {
    type: {
        name: "Composite",
        className: "FrontendEndpointUpdateParameters",
        modelProperties: {
            hostName: {
                serializedName: "hostName",
                type: {
                    name: "String",
                },
            },
            sessionAffinityEnabledState: {
                serializedName: "sessionAffinityEnabledState",
                type: {
                    name: "String",
                },
            },
            sessionAffinityTtlSeconds: {
                serializedName: "sessionAffinityTtlSeconds",
                type: {
                    name: "Number",
                },
            },
            webApplicationFirewallPolicyLink: {
                serializedName: "webApplicationFirewallPolicyLink",
                type: {
                    name: "Composite",
                    className: "FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink",
                },
            },
        },
    },
};
const FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink = {
    type: {
        name: "Composite",
        className: "FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const BackendPoolsSettings = {
    type: {
        name: "Composite",
        className: "BackendPoolsSettings",
        modelProperties: {
            enforceCertificateNameCheck: {
                defaultValue: "Enabled",
                serializedName: "enforceCertificateNameCheck",
                type: {
                    name: "String",
                },
            },
            sendRecvTimeoutSeconds: {
                constraints: {
                    InclusiveMinimum: 16,
                },
                serializedName: "sendRecvTimeoutSeconds",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const FrontendEndpointsListResult = {
    type: {
        name: "Composite",
        className: "FrontendEndpointsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontendEndpoint",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PurgeParameters = {
    type: {
        name: "Composite",
        className: "PurgeParameters",
        modelProperties: {
            contentPaths: {
                serializedName: "contentPaths",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const ValidateCustomDomainInput = {
    type: {
        name: "Composite",
        className: "ValidateCustomDomainInput",
        modelProperties: {
            hostName: {
                serializedName: "hostName",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ValidateCustomDomainOutput = {
    type: {
        name: "Composite",
        className: "ValidateCustomDomainOutput",
        modelProperties: {
            customDomainValidated: {
                serializedName: "customDomainValidated",
                readOnly: true,
                type: {
                    name: "Boolean",
                },
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RulesEngineListResult = {
    type: {
        name: "Composite",
        className: "RulesEngineListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RulesEngine",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ProfileList = {
    type: {
        name: "Composite",
        className: "ProfileList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Profile",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ProfileUpdateModel = {
    type: {
        name: "Composite",
        className: "ProfileUpdateModel",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PreconfiguredEndpointList = {
    type: {
        name: "Composite",
        className: "PreconfiguredEndpointList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PreconfiguredEndpoint",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ExperimentList = {
    type: {
        name: "Composite",
        className: "ExperimentList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Experiment",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Endpoint = {
    type: {
        name: "Composite",
        className: "Endpoint",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            },
            endpoint: {
                serializedName: "endpoint",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ExperimentUpdateModel = {
    type: {
        name: "Composite",
        className: "ExperimentUpdateModel",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String",
                },
            },
            enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const LatencyMetric = {
    type: {
        name: "Composite",
        className: "LatencyMetric",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            endDateTimeUTC: {
                serializedName: "endDateTimeUTC",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            aValue: {
                serializedName: "aValue",
                readOnly: true,
                type: {
                    name: "Number",
                },
            },
            bValue: {
                serializedName: "bValue",
                readOnly: true,
                type: {
                    name: "Number",
                },
            },
            delta: {
                serializedName: "delta",
                readOnly: true,
                type: {
                    name: "Number",
                },
            },
            deltaPercent: {
                serializedName: "deltaPercent",
                readOnly: true,
                type: {
                    name: "Number",
                },
            },
            aCLower95CI: {
                serializedName: "aCLower95CI",
                readOnly: true,
                type: {
                    name: "Number",
                },
            },
            aHUpper95CI: {
                serializedName: "aHUpper95CI",
                readOnly: true,
                type: {
                    name: "Number",
                },
            },
            bCLower95CI: {
                serializedName: "bCLower95CI",
                readOnly: true,
                type: {
                    name: "Number",
                },
            },
            bUpper95CI: {
                serializedName: "bUpper95CI",
                readOnly: true,
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const TimeseriesDataPoint = {
    type: {
        name: "Composite",
        className: "TimeseriesDataPoint",
        modelProperties: {
            dateTimeUTC: {
                serializedName: "dateTimeUTC",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ErrorDetails = {
    type: {
        name: "Composite",
        className: "ErrorDetails",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String",
                },
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String",
                },
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String",
                },
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetails",
                        },
                    },
                },
            },
            innerError: {
                serializedName: "innerError",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AzureAsyncOperationResult = {
    type: {
        name: "Composite",
        className: "AzureAsyncOperationResult",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String",
                },
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel",
                },
            },
        },
    },
};
const RoutingRuleListResult = {
    type: {
        name: "Composite",
        className: "RoutingRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoutingRule",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CacheConfiguration = {
    type: {
        name: "Composite",
        className: "CacheConfiguration",
        modelProperties: {
            queryParameterStripDirective: {
                serializedName: "queryParameterStripDirective",
                type: {
                    name: "String",
                },
            },
            queryParameters: {
                serializedName: "queryParameters",
                type: {
                    name: "String",
                },
            },
            dynamicCompression: {
                serializedName: "dynamicCompression",
                type: {
                    name: "String",
                },
            },
            cacheDuration: {
                serializedName: "cacheDuration",
                type: {
                    name: "TimeSpan",
                },
            },
        },
    },
};
const LoadBalancingSettingsListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancingSettingsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancingSettingsModel",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const HealthProbeSettingsListResult = {
    type: {
        name: "Composite",
        className: "HealthProbeSettingsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthProbeSettingsModel",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const BackendPoolListResult = {
    type: {
        name: "Composite",
        className: "BackendPoolListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackendPool",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WebApplicationFirewallPolicy = {
    type: {
        name: "Composite",
        className: "WebApplicationFirewallPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                type: {
                    name: "String",
                },
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku",
                },
            }, policySettings: {
                serializedName: "properties.policySettings",
                type: {
                    name: "Composite",
                    className: "PolicySettings",
                },
            }, customRules: {
                serializedName: "properties.customRules",
                type: {
                    name: "Composite",
                    className: "CustomRuleList",
                },
            }, managedRules: {
                serializedName: "properties.managedRules",
                type: {
                    name: "Composite",
                    className: "ManagedRuleSetList",
                },
            }, frontendEndpointLinks: {
                serializedName: "properties.frontendEndpointLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontendEndpointLink",
                        },
                    },
                },
            }, routingRuleLinks: {
                serializedName: "properties.routingRuleLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoutingRuleLink",
                        },
                    },
                },
            }, securityPolicyLinks: {
                serializedName: "properties.securityPolicyLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityPolicyLink",
                        },
                    },
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const ManagedRuleSetDefinition = {
    type: {
        name: "Composite",
        className: "ManagedRuleSetDefinition",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, ruleSetId: {
                serializedName: "properties.ruleSetId",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, ruleSetType: {
                serializedName: "properties.ruleSetType",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, ruleSetVersion: {
                serializedName: "properties.ruleSetVersion",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, ruleGroups: {
                serializedName: "properties.ruleGroups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleGroupDefinition",
                        },
                    },
                },
            } }),
    },
};
const FrontDoor = {
    type: {
        name: "Composite",
        className: "FrontDoor",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { friendlyName: {
                serializedName: "properties.friendlyName",
                type: {
                    name: "String",
                },
            }, routingRules: {
                serializedName: "properties.routingRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoutingRule",
                        },
                    },
                },
            }, loadBalancingSettings: {
                serializedName: "properties.loadBalancingSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancingSettingsModel",
                        },
                    },
                },
            }, healthProbeSettings: {
                serializedName: "properties.healthProbeSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthProbeSettingsModel",
                        },
                    },
                },
            }, backendPools: {
                serializedName: "properties.backendPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackendPool",
                        },
                    },
                },
            }, frontendEndpoints: {
                serializedName: "properties.frontendEndpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontendEndpoint",
                        },
                    },
                },
            }, backendPoolsSettings: {
                serializedName: "properties.backendPoolsSettings",
                type: {
                    name: "Composite",
                    className: "BackendPoolsSettings",
                },
            }, enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String",
                },
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, cname: {
                serializedName: "properties.cname",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, frontdoorId: {
                serializedName: "properties.frontdoorId",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, rulesEngines: {
                serializedName: "properties.rulesEngines",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RulesEngine",
                        },
                    },
                },
            }, extendedProperties: {
                serializedName: "properties.extendedProperties",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            } }),
    },
};
const Profile = {
    type: {
        name: "Composite",
        className: "Profile",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                type: {
                    name: "String",
                },
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String",
                },
            } }),
    },
};
const PreconfiguredEndpoint = {
    type: {
        name: "Composite",
        className: "PreconfiguredEndpoint",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String",
                },
            }, endpoint: {
                serializedName: "properties.endpoint",
                type: {
                    name: "String",
                },
            }, endpointType: {
                serializedName: "properties.endpointType",
                type: {
                    name: "String",
                },
            }, backend: {
                serializedName: "properties.backend",
                type: {
                    name: "String",
                },
            } }),
    },
};
const Experiment = {
    type: {
        name: "Composite",
        className: "Experiment",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String",
                },
            }, endpointA: {
                serializedName: "properties.endpointA",
                type: {
                    name: "Composite",
                    className: "Endpoint",
                },
            }, endpointB: {
                serializedName: "properties.endpointB",
                type: {
                    name: "Composite",
                    className: "Endpoint",
                },
            }, enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String",
                },
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, scriptFileUri: {
                serializedName: "properties.scriptFileUri",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const LatencyScorecard = {
    type: {
        name: "Composite",
        className: "LatencyScorecard",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { idPropertiesId: {
                serializedName: "properties.id",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, namePropertiesName: {
                serializedName: "properties.name",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, endpointA: {
                serializedName: "properties.endpointA",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, endpointB: {
                serializedName: "properties.endpointB",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, startDateTimeUTC: {
                serializedName: "properties.startDateTimeUTC",
                readOnly: true,
                type: {
                    name: "DateTime",
                },
            }, endDateTimeUTC: {
                serializedName: "properties.endDateTimeUTC",
                readOnly: true,
                type: {
                    name: "DateTime",
                },
            }, country: {
                serializedName: "properties.country",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, latencyMetrics: {
                serializedName: "properties.latencyMetrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LatencyMetric",
                        },
                    },
                },
            } }),
    },
};
const Timeseries = {
    type: {
        name: "Composite",
        className: "Timeseries",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { endpoint: {
                serializedName: "properties.endpoint",
                type: {
                    name: "String",
                },
            }, startDateTimeUTC: {
                serializedName: "properties.startDateTimeUTC",
                type: {
                    name: "String",
                },
            }, endDateTimeUTC: {
                serializedName: "properties.endDateTimeUTC",
                type: {
                    name: "String",
                },
            }, aggregationInterval: {
                serializedName: "properties.aggregationInterval",
                type: {
                    name: "String",
                },
            }, timeseriesType: {
                serializedName: "properties.timeseriesType",
                type: {
                    name: "String",
                },
            }, country: {
                serializedName: "properties.country",
                type: {
                    name: "String",
                },
            }, timeseriesData: {
                serializedName: "properties.timeseriesData",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TimeseriesDataPoint",
                        },
                    },
                },
            } }),
    },
};
const RulesEngineProperties = {
    type: {
        name: "Composite",
        className: "RulesEngineProperties",
        modelProperties: Object.assign(Object.assign({}, RulesEngineUpdateParameters.type.modelProperties), { resourceState: {
                serializedName: "resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const ForwardingConfiguration = {
    serializedName: "#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration",
    type: {
        name: "Composite",
        className: "ForwardingConfiguration",
        uberParent: "RouteConfiguration",
        polymorphicDiscriminator: RouteConfiguration.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RouteConfiguration.type.modelProperties), { customForwardingPath: {
                serializedName: "customForwardingPath",
                type: {
                    name: "String",
                },
            }, forwardingProtocol: {
                serializedName: "forwardingProtocol",
                type: {
                    name: "String",
                },
            }, cacheConfiguration: {
                serializedName: "cacheConfiguration",
                type: {
                    name: "Composite",
                    className: "CacheConfiguration",
                },
            }, backendPool: {
                serializedName: "backendPool",
                type: {
                    name: "Composite",
                    className: "SubResource",
                },
            } }),
    },
};
const RedirectConfiguration = {
    serializedName: "#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration",
    type: {
        name: "Composite",
        className: "RedirectConfiguration",
        uberParent: "RouteConfiguration",
        polymorphicDiscriminator: RouteConfiguration.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RouteConfiguration.type.modelProperties), { redirectType: {
                serializedName: "redirectType",
                type: {
                    name: "String",
                },
            }, redirectProtocol: {
                serializedName: "redirectProtocol",
                type: {
                    name: "String",
                },
            }, customHost: {
                serializedName: "customHost",
                type: {
                    name: "String",
                },
            }, customPath: {
                serializedName: "customPath",
                type: {
                    name: "String",
                },
            }, customFragment: {
                serializedName: "customFragment",
                type: {
                    name: "String",
                },
            }, customQueryString: {
                serializedName: "customQueryString",
                type: {
                    name: "String",
                },
            } }),
    },
};
const FrontDoorProperties = {
    type: {
        name: "Composite",
        className: "FrontDoorProperties",
        modelProperties: Object.assign(Object.assign({}, FrontDoorUpdateParameters.type.modelProperties), { resourceState: {
                serializedName: "resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, cname: {
                serializedName: "cname",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, frontdoorId: {
                serializedName: "frontdoorId",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, rulesEngines: {
                serializedName: "rulesEngines",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RulesEngine",
                        },
                    },
                },
            }, extendedProperties: {
                serializedName: "extendedProperties",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            } }),
    },
};
const RoutingRuleProperties = {
    type: {
        name: "Composite",
        className: "RoutingRuleProperties",
        modelProperties: Object.assign(Object.assign({}, RoutingRuleUpdateParameters.type.modelProperties), { resourceState: {
                serializedName: "resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const RoutingRule = {
    type: {
        name: "Composite",
        className: "RoutingRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, frontendEndpoints: {
                serializedName: "properties.frontendEndpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource",
                        },
                    },
                },
            }, acceptedProtocols: {
                serializedName: "properties.acceptedProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, patternsToMatch: {
                serializedName: "properties.patternsToMatch",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String",
                },
            }, routeConfiguration: {
                serializedName: "properties.routeConfiguration",
                type: {
                    name: "Composite",
                    className: "RouteConfiguration",
                },
            }, rulesEngine: {
                serializedName: "properties.rulesEngine",
                type: {
                    name: "Composite",
                    className: "SubResource",
                },
            }, webApplicationFirewallPolicyLink: {
                serializedName: "properties.webApplicationFirewallPolicyLink",
                type: {
                    name: "Composite",
                    className: "RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink",
                },
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const LoadBalancingSettingsModel = {
    type: {
        name: "Composite",
        className: "LoadBalancingSettingsModel",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, sampleSize: {
                serializedName: "properties.sampleSize",
                type: {
                    name: "Number",
                },
            }, successfulSamplesRequired: {
                serializedName: "properties.successfulSamplesRequired",
                type: {
                    name: "Number",
                },
            }, additionalLatencyMilliseconds: {
                serializedName: "properties.additionalLatencyMilliseconds",
                type: {
                    name: "Number",
                },
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const HealthProbeSettingsModel = {
    type: {
        name: "Composite",
        className: "HealthProbeSettingsModel",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, path: {
                serializedName: "properties.path",
                type: {
                    name: "String",
                },
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String",
                },
            }, intervalInSeconds: {
                serializedName: "properties.intervalInSeconds",
                type: {
                    name: "Number",
                },
            }, healthProbeMethod: {
                defaultValue: "HEAD",
                serializedName: "properties.healthProbeMethod",
                type: {
                    name: "String",
                },
            }, enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "String",
                },
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const BackendPool = {
    type: {
        name: "Composite",
        className: "BackendPool",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, backends: {
                serializedName: "properties.backends",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Backend",
                        },
                    },
                },
            }, loadBalancingSettings: {
                serializedName: "properties.loadBalancingSettings",
                type: {
                    name: "Composite",
                    className: "SubResource",
                },
            }, healthProbeSettings: {
                serializedName: "properties.healthProbeSettings",
                type: {
                    name: "Composite",
                    className: "SubResource",
                },
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const FrontendEndpoint = {
    type: {
        name: "Composite",
        className: "FrontendEndpoint",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String",
                },
            }, sessionAffinityEnabledState: {
                serializedName: "properties.sessionAffinityEnabledState",
                type: {
                    name: "String",
                },
            }, sessionAffinityTtlSeconds: {
                serializedName: "properties.sessionAffinityTtlSeconds",
                type: {
                    name: "Number",
                },
            }, webApplicationFirewallPolicyLink: {
                serializedName: "properties.webApplicationFirewallPolicyLink",
                type: {
                    name: "Composite",
                    className: "FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink",
                },
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, customHttpsProvisioningState: {
                serializedName: "properties.customHttpsProvisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, customHttpsProvisioningSubstate: {
                serializedName: "properties.customHttpsProvisioningSubstate",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, customHttpsConfiguration: {
                serializedName: "properties.customHttpsConfiguration",
                type: {
                    name: "Composite",
                    className: "CustomHttpsConfiguration",
                },
            } }),
    },
};
const LoadBalancingSettingsProperties = {
    type: {
        name: "Composite",
        className: "LoadBalancingSettingsProperties",
        modelProperties: Object.assign(Object.assign({}, LoadBalancingSettingsUpdateParameters.type.modelProperties), { resourceState: {
                serializedName: "resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const HealthProbeSettingsProperties = {
    type: {
        name: "Composite",
        className: "HealthProbeSettingsProperties",
        modelProperties: Object.assign(Object.assign({}, HealthProbeSettingsUpdateParameters.type.modelProperties), { resourceState: {
                serializedName: "resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const BackendPoolProperties = {
    type: {
        name: "Composite",
        className: "BackendPoolProperties",
        modelProperties: Object.assign(Object.assign({}, BackendPoolUpdateParameters.type.modelProperties), { resourceState: {
                serializedName: "resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const FrontendEndpointProperties = {
    type: {
        name: "Composite",
        className: "FrontendEndpointProperties",
        modelProperties: Object.assign(Object.assign({}, FrontendEndpointUpdateParameters.type.modelProperties), { resourceState: {
                serializedName: "resourceState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, customHttpsProvisioningState: {
                serializedName: "customHttpsProvisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, customHttpsProvisioningSubstate: {
                serializedName: "customHttpsProvisioningSubstate",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, customHttpsConfiguration: {
                serializedName: "customHttpsConfiguration",
                type: {
                    name: "Composite",
                    className: "CustomHttpsConfiguration",
                },
            } }),
    },
};
let discriminators = {
    RouteConfiguration: RouteConfiguration,
    "RouteConfiguration.#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration": ForwardingConfiguration,
    "RouteConfiguration.#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration": RedirectConfiguration,
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AzureAsyncOperationResult: AzureAsyncOperationResult,
    Backend: Backend,
    BackendPool: BackendPool,
    BackendPoolListResult: BackendPoolListResult,
    BackendPoolProperties: BackendPoolProperties,
    BackendPoolUpdateParameters: BackendPoolUpdateParameters,
    BackendPoolsSettings: BackendPoolsSettings,
    CacheConfiguration: CacheConfiguration,
    CheckNameAvailabilityInput: CheckNameAvailabilityInput,
    CheckNameAvailabilityOutput: CheckNameAvailabilityOutput,
    CustomHttpsConfiguration: CustomHttpsConfiguration,
    CustomRule: CustomRule,
    CustomRuleList: CustomRuleList,
    DefaultErrorResponse: DefaultErrorResponse,
    DefaultErrorResponseError: DefaultErrorResponseError,
    Endpoint: Endpoint,
    ErrorDetails: ErrorDetails,
    ErrorModel: ErrorModel,
    ErrorResponse: ErrorResponse,
    Experiment: Experiment,
    ExperimentList: ExperimentList,
    ExperimentUpdateModel: ExperimentUpdateModel,
    ForwardingConfiguration: ForwardingConfiguration,
    FrontDoor: FrontDoor,
    FrontDoorListResult: FrontDoorListResult,
    FrontDoorProperties: FrontDoorProperties,
    FrontDoorUpdateParameters: FrontDoorUpdateParameters,
    FrontendEndpoint: FrontendEndpoint,
    FrontendEndpointLink: FrontendEndpointLink,
    FrontendEndpointProperties: FrontendEndpointProperties,
    FrontendEndpointUpdateParameters: FrontendEndpointUpdateParameters,
    FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink: FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink,
    FrontendEndpointsListResult: FrontendEndpointsListResult,
    GroupByVariable: GroupByVariable,
    HeaderAction: HeaderAction,
    HealthProbeSettingsListResult: HealthProbeSettingsListResult,
    HealthProbeSettingsModel: HealthProbeSettingsModel,
    HealthProbeSettingsProperties: HealthProbeSettingsProperties,
    HealthProbeSettingsUpdateParameters: HealthProbeSettingsUpdateParameters,
    KeyVaultCertificateSourceParametersVault: KeyVaultCertificateSourceParametersVault,
    LatencyMetric: LatencyMetric,
    LatencyScorecard: LatencyScorecard,
    LoadBalancingSettingsListResult: LoadBalancingSettingsListResult,
    LoadBalancingSettingsModel: LoadBalancingSettingsModel,
    LoadBalancingSettingsProperties: LoadBalancingSettingsProperties,
    LoadBalancingSettingsUpdateParameters: LoadBalancingSettingsUpdateParameters,
    ManagedRuleDefinition: ManagedRuleDefinition,
    ManagedRuleExclusion: ManagedRuleExclusion,
    ManagedRuleGroupDefinition: ManagedRuleGroupDefinition,
    ManagedRuleGroupOverride: ManagedRuleGroupOverride,
    ManagedRuleOverride: ManagedRuleOverride,
    ManagedRuleSet: ManagedRuleSet,
    ManagedRuleSetDefinition: ManagedRuleSetDefinition,
    ManagedRuleSetDefinitionList: ManagedRuleSetDefinitionList,
    ManagedRuleSetList: ManagedRuleSetList,
    MatchCondition: MatchCondition,
    PolicySettings: PolicySettings,
    PreconfiguredEndpoint: PreconfiguredEndpoint,
    PreconfiguredEndpointList: PreconfiguredEndpointList,
    Profile: Profile,
    ProfileList: ProfileList,
    ProfileUpdateModel: ProfileUpdateModel,
    PurgeParameters: PurgeParameters,
    RedirectConfiguration: RedirectConfiguration,
    Resource: Resource,
    RouteConfiguration: RouteConfiguration,
    RoutingRule: RoutingRule,
    RoutingRuleLink: RoutingRuleLink,
    RoutingRuleListResult: RoutingRuleListResult,
    RoutingRuleProperties: RoutingRuleProperties,
    RoutingRuleUpdateParameters: RoutingRuleUpdateParameters,
    RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink: RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink,
    RulesEngine: RulesEngine,
    RulesEngineAction: RulesEngineAction,
    RulesEngineListResult: RulesEngineListResult,
    RulesEngineMatchCondition: RulesEngineMatchCondition,
    RulesEngineProperties: RulesEngineProperties,
    RulesEngineRule: RulesEngineRule,
    RulesEngineUpdateParameters: RulesEngineUpdateParameters,
    SecurityPolicyLink: SecurityPolicyLink,
    Sku: Sku,
    SubResource: SubResource,
    TagsObject: TagsObject,
    Timeseries: Timeseries,
    TimeseriesDataPoint: TimeseriesDataPoint,
    ValidateCustomDomainInput: ValidateCustomDomainInput,
    ValidateCustomDomainOutput: ValidateCustomDomainOutput,
    WebApplicationFirewallPolicy: WebApplicationFirewallPolicy,
    WebApplicationFirewallPolicyList: WebApplicationFirewallPolicyList,
    WebApplicationFirewallScrubbingRules: WebApplicationFirewallScrubbingRules,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9_\\-\\(\\)\\.]*[^\\.]$"),
            MaxLength: 80,
            MinLength: 1,
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String",
        },
    },
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2024-02-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String",
        },
    },
};
const policyName = {
    parameterPath: "policyName",
    mapper: {
        constraints: {
            MaxLength: 128,
        },
        serializedName: "policyName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String",
        },
    },
};
const parameters = {
    parameterPath: "parameters",
    mapper: WebApplicationFirewallPolicy,
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: TagsObject,
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const checkFrontDoorNameAvailabilityInput = {
    parameterPath: "checkFrontDoorNameAvailabilityInput",
    mapper: CheckNameAvailabilityInput,
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-06-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String",
        },
    },
};
const frontDoorName = {
    parameterPath: "frontDoorName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]+([-a-zA-Z0-9]?[a-zA-Z0-9])*$"),
            MaxLength: 64,
            MinLength: 5,
        },
        serializedName: "frontDoorName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const frontDoorParameters = {
    parameterPath: "frontDoorParameters",
    mapper: FrontDoor,
};
const customDomainProperties = {
    parameterPath: "customDomainProperties",
    mapper: ValidateCustomDomainInput,
};
const frontendEndpointName = {
    parameterPath: "frontendEndpointName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]+(-*[a-zA-Z0-9])*$"),
            MaxLength: 255,
            MinLength: 1,
        },
        serializedName: "frontendEndpointName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const customHttpsConfiguration = {
    parameterPath: "customHttpsConfiguration",
    mapper: CustomHttpsConfiguration,
};
const contentFilePaths = {
    parameterPath: "contentFilePaths",
    mapper: PurgeParameters,
};
const rulesEngineName = {
    parameterPath: "rulesEngineName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]+(-*[a-zA-Z0-9])*$"),
            MaxLength: 90,
            MinLength: 1,
        },
        serializedName: "rulesEngineName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const rulesEngineParameters = {
    parameterPath: "rulesEngineParameters",
    mapper: RulesEngine,
};
const apiVersion2 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2019-11-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String",
        },
    },
};
const profileName = {
    parameterPath: "profileName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9_\\-\\(\\)\\.]*[^\\.]$"),
        },
        serializedName: "profileName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: Profile,
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: ProfileUpdateModel,
};
const experimentName = {
    parameterPath: "experimentName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9_\\-\\(\\)\\.]*[^\\.]$"),
        },
        serializedName: "experimentName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: Experiment,
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: ExperimentUpdateModel,
};
const endDateTimeUTC = {
    parameterPath: ["options", "endDateTimeUTC"],
    mapper: {
        serializedName: "endDateTimeUTC",
        type: {
            name: "String",
        },
    },
};
const country = {
    parameterPath: ["options", "country"],
    mapper: {
        serializedName: "country",
        type: {
            name: "String",
        },
    },
};
const aggregationInterval = {
    parameterPath: "aggregationInterval",
    mapper: {
        serializedName: "aggregationInterval",
        required: true,
        type: {
            name: "String",
        },
    },
};
const startDateTimeUTC = {
    parameterPath: "startDateTimeUTC",
    mapper: {
        serializedName: "startDateTimeUTC",
        required: true,
        type: {
            name: "DateTime",
        },
    },
};
const endDateTimeUTC1 = {
    parameterPath: "endDateTimeUTC",
    mapper: {
        serializedName: "endDateTimeUTC",
        required: true,
        type: {
            name: "DateTime",
        },
    },
};
const aggregationInterval1 = {
    parameterPath: "aggregationInterval",
    mapper: {
        serializedName: "aggregationInterval",
        required: true,
        type: {
            name: "String",
        },
    },
};
const timeseriesType = {
    parameterPath: "timeseriesType",
    mapper: {
        serializedName: "timeseriesType",
        required: true,
        type: {
            name: "String",
        },
    },
};
const endpoint = {
    parameterPath: ["options", "endpoint"],
    mapper: {
        serializedName: "endpoint",
        type: {
            name: "String",
        },
    },
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        },
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Policies operations. */
class PoliciesImpl {
    /**
     * Initialize a new instance of the class Policies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the protection policies within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the protection policies within a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            },
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all of the protection policies within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$4);
    }
    /**
     * Lists all of the protection policies within a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Retrieve protection policy with specified name within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, policyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, policyName, options }, getOperationSpec$5);
    }
    /**
     * Create or update policy with specified rule set name within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param parameters Policy to be created.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, policyName, parameters, options },
                spec: createOrUpdateOperationSpec$4,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update policy with specified rule set name within a resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param parameters Policy to be created.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, policyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch a specific frontdoor webApplicationFirewall policy for tags update under the specified
     * subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param parameters FrontdoorWebApplicationFirewallPolicy parameters to be patched.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, policyName, parameters, options },
                spec: updateOperationSpec$2,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patch a specific frontdoor webApplicationFirewall policy for tags update under the specified
     * subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param parameters FrontdoorWebApplicationFirewallPolicy parameters to be patched.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, policyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes Policy
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, policyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, policyName, options },
                spec: deleteOperationSpec$4,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes Policy
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param policyName The name of the Web Application Firewall Policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, policyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, policyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$4);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoorWebApplicationFirewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/frontDoorWebApplicationFirewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyList,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicy,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        policyName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicy,
        },
        201: {
            bodyMapper: WebApplicationFirewallPolicy,
        },
        202: {
            bodyMapper: WebApplicationFirewallPolicy,
        },
        204: {
            bodyMapper: WebApplicationFirewallPolicy,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        policyName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicy,
        },
        201: {
            bodyMapper: WebApplicationFirewallPolicy,
        },
        202: {
            bodyMapper: WebApplicationFirewallPolicy,
        },
        204: {
            bodyMapper: WebApplicationFirewallPolicy,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        policyName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        policyName,
    ],
    serializer: serializer$b,
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyList,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedRuleSets operations. */
class ManagedRuleSetsImpl {
    /**
     * Initialize a new instance of the class ManagedRuleSets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all available managed rule sets.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all available managed rule sets.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallManagedRuleSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedRuleSetDefinitionList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedRuleSetDefinitionList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing FrontDoorNameAvailability operations. */
class FrontDoorNameAvailabilityImpl {
    /**
     * Initialize a new instance of the class FrontDoorNameAvailability class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Check the availability of a Front Door resource name.
     * @param checkFrontDoorNameAvailabilityInput Input to check.
     * @param options The options parameters.
     */
    check(checkFrontDoorNameAvailabilityInput, options) {
        return this.client.sendOperationRequest({ checkFrontDoorNameAvailabilityInput, options }, checkOperationSpec$1);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkOperationSpec$1 = {
    path: "/providers/Microsoft.Network/checkFrontDoorNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityOutput,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: checkFrontDoorNameAvailabilityInput,
    queryParameters: [apiVersion1],
    urlParameters: [$host],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing FrontDoorNameAvailabilityWithSubscription operations. */
class FrontDoorNameAvailabilityWithSubscriptionImpl {
    /**
     * Initialize a new instance of the class FrontDoorNameAvailabilityWithSubscription class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Check the availability of a Front Door subdomain.
     * @param checkFrontDoorNameAvailabilityInput Input to check.
     * @param options The options parameters.
     */
    check(checkFrontDoorNameAvailabilityInput, options) {
        return this.client.sendOperationRequest({ checkFrontDoorNameAvailabilityInput, options }, checkOperationSpec);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/checkFrontDoorNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityOutput,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: checkFrontDoorNameAvailabilityInput,
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FrontDoors operations. */
class FrontDoorsImpl {
    /**
     * Initialize a new instance of the class FrontDoors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the Front Doors within an Azure subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the Front Doors within a resource group under a subscription.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all of the Front Doors within an Azure subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * Lists all of the Front Doors within a resource group under a subscription.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Gets a Front Door with the specified Front Door name under the specified subscription and resource
     * group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    get(resourceGroupName, frontDoorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, frontDoorName, options }, getOperationSpec$4);
    }
    /**
     * Creates a new Front Door with a Front Door name under the specified subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontDoorParameters Front Door properties needed to create a new Front Door.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, frontDoorName, frontDoorParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, frontDoorName, frontDoorParameters, options },
                spec: createOrUpdateOperationSpec$3,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new Front Door with a Front Door name under the specified subscription and resource group.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontDoorParameters Front Door properties needed to create a new Front Door.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, frontDoorName, frontDoorParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, frontDoorName, frontDoorParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Front Door with the specified parameters.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, frontDoorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, frontDoorName, options },
                spec: deleteOperationSpec$3,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Front Door with the specified parameters.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, frontDoorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, frontDoorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Validates the custom domain mapping to ensure it maps to the correct Front Door endpoint in DNS.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param customDomainProperties Custom domain to be validated.
     * @param options The options parameters.
     */
    validateCustomDomain(resourceGroupName, frontDoorName, customDomainProperties, options) {
        return this.client.sendOperationRequest({ resourceGroupName, frontDoorName, customDomainProperties, options }, validateCustomDomainOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/frontDoors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FrontDoorListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$7,
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FrontDoorListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FrontDoor,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FrontDoor,
        },
        201: {
            bodyMapper: FrontDoor,
        },
        202: {
            bodyMapper: FrontDoor,
        },
        204: {
            bodyMapper: FrontDoor,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: frontDoorParameters,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7,
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const validateCustomDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/validateCustomDomain",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ValidateCustomDomainOutput,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: customDomainProperties,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7,
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FrontDoorListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FrontDoorListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FrontendEndpoints operations. */
class FrontendEndpointsImpl {
    /**
     * Initialize a new instance of the class FrontendEndpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the frontend endpoints within a Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    listByFrontDoor(resourceGroupName, frontDoorName, options) {
        const iter = this.listByFrontDoorPagingAll(resourceGroupName, frontDoorName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByFrontDoorPagingPage(resourceGroupName, frontDoorName, options, settings);
            },
        };
    }
    listByFrontDoorPagingPage(resourceGroupName, frontDoorName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByFrontDoorPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByFrontDoor(resourceGroupName, frontDoorName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByFrontDoorNext(resourceGroupName, frontDoorName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByFrontDoorPagingAll(resourceGroupName, frontDoorName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByFrontDoorPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByFrontDoorPagingPage(resourceGroupName, frontDoorName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the frontend endpoints within a Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    _listByFrontDoor(resourceGroupName, frontDoorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, frontDoorName, options }, listByFrontDoorOperationSpec$1);
    }
    /**
     * Gets a Frontend endpoint with the specified name within the specified Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontendEndpointName Name of the Frontend endpoint which is unique within the Front Door.
     * @param options The options parameters.
     */
    get(resourceGroupName, frontDoorName, frontendEndpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, frontDoorName, frontendEndpointName, options }, getOperationSpec$3);
    }
    /**
     * Enables a frontendEndpoint for HTTPS traffic
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontendEndpointName Name of the Frontend endpoint which is unique within the Front Door.
     * @param customHttpsConfiguration The configuration specifying how to enable HTTPS
     * @param options The options parameters.
     */
    beginEnableHttps(resourceGroupName, frontDoorName, frontendEndpointName, customHttpsConfiguration, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    frontDoorName,
                    frontendEndpointName,
                    customHttpsConfiguration,
                    options,
                },
                spec: enableHttpsOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Enables a frontendEndpoint for HTTPS traffic
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontendEndpointName Name of the Frontend endpoint which is unique within the Front Door.
     * @param customHttpsConfiguration The configuration specifying how to enable HTTPS
     * @param options The options parameters.
     */
    beginEnableHttpsAndWait(resourceGroupName, frontDoorName, frontendEndpointName, customHttpsConfiguration, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginEnableHttps(resourceGroupName, frontDoorName, frontendEndpointName, customHttpsConfiguration, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Disables a frontendEndpoint for HTTPS traffic
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontendEndpointName Name of the Frontend endpoint which is unique within the Front Door.
     * @param options The options parameters.
     */
    beginDisableHttps(resourceGroupName, frontDoorName, frontendEndpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, frontDoorName, frontendEndpointName, options },
                spec: disableHttpsOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Disables a frontendEndpoint for HTTPS traffic
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param frontendEndpointName Name of the Frontend endpoint which is unique within the Front Door.
     * @param options The options parameters.
     */
    beginDisableHttpsAndWait(resourceGroupName, frontDoorName, frontendEndpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDisableHttps(resourceGroupName, frontDoorName, frontendEndpointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByFrontDoorNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param nextLink The nextLink from the previous successful call to the ListByFrontDoor method.
     * @param options The options parameters.
     */
    _listByFrontDoorNext(resourceGroupName, frontDoorName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, frontDoorName, nextLink, options }, listByFrontDoorNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByFrontDoorOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/frontendEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FrontendEndpointsListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/frontendEndpoints/{frontendEndpointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FrontendEndpoint,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
        frontendEndpointName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const enableHttpsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/frontendEndpoints/{frontendEndpointName}/enableHttps",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: customHttpsConfiguration,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
        frontendEndpointName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6,
};
const disableHttpsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/frontendEndpoints/{frontendEndpointName}/disableHttps",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
        frontendEndpointName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const listByFrontDoorNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FrontendEndpointsListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        frontDoorName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Endpoints operations. */
class EndpointsImpl {
    /**
     * Initialize a new instance of the class Endpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Removes a content from Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param contentFilePaths The path to the content to be purged. Path can be a full URL, e.g.
     *                         '/pictures/city.png' which removes a single file, or a directory with a wildcard, e.g. '/pictures/*'
     *                         which removes all folders and files in the directory.
     * @param options The options parameters.
     */
    beginPurgeContent(resourceGroupName, frontDoorName, contentFilePaths, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, frontDoorName, contentFilePaths, options },
                spec: purgeContentOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Removes a content from Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param contentFilePaths The path to the content to be purged. Path can be a full URL, e.g.
     *                         '/pictures/city.png' which removes a single file, or a directory with a wildcard, e.g. '/pictures/*'
     *                         which removes all folders and files in the directory.
     * @param options The options parameters.
     */
    beginPurgeContentAndWait(resourceGroupName, frontDoorName, contentFilePaths, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPurgeContent(resourceGroupName, frontDoorName, contentFilePaths, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const purgeContentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/purge",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: contentFilePaths,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RulesEngines operations. */
class RulesEnginesImpl {
    /**
     * Initialize a new instance of the class RulesEngines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the Rules Engine Configurations within a Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    listByFrontDoor(resourceGroupName, frontDoorName, options) {
        const iter = this.listByFrontDoorPagingAll(resourceGroupName, frontDoorName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByFrontDoorPagingPage(resourceGroupName, frontDoorName, options, settings);
            },
        };
    }
    listByFrontDoorPagingPage(resourceGroupName, frontDoorName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByFrontDoorPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByFrontDoor(resourceGroupName, frontDoorName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByFrontDoorNext(resourceGroupName, frontDoorName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByFrontDoorPagingAll(resourceGroupName, frontDoorName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByFrontDoorPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByFrontDoorPagingPage(resourceGroupName, frontDoorName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the Rules Engine Configurations within a Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param options The options parameters.
     */
    _listByFrontDoor(resourceGroupName, frontDoorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, frontDoorName, options }, listByFrontDoorOperationSpec);
    }
    /**
     * Gets a Rules Engine Configuration with the specified name within the specified Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param rulesEngineName Name of the Rules Engine which is unique within the Front Door.
     * @param options The options parameters.
     */
    get(resourceGroupName, frontDoorName, rulesEngineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, frontDoorName, rulesEngineName, options }, getOperationSpec$2);
    }
    /**
     * Creates a new Rules Engine Configuration with the specified name within the specified Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param rulesEngineName Name of the Rules Engine which is unique within the Front Door.
     * @param rulesEngineParameters Rules Engine Configuration properties needed to create a new Rules
     *                              Engine Configuration.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, frontDoorName, rulesEngineName, rulesEngineParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    frontDoorName,
                    rulesEngineName,
                    rulesEngineParameters,
                    options,
                },
                spec: createOrUpdateOperationSpec$2,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new Rules Engine Configuration with the specified name within the specified Front Door.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param rulesEngineName Name of the Rules Engine which is unique within the Front Door.
     * @param rulesEngineParameters Rules Engine Configuration properties needed to create a new Rules
     *                              Engine Configuration.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, frontDoorName, rulesEngineName, rulesEngineParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, frontDoorName, rulesEngineName, rulesEngineParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Rules Engine Configuration with the specified parameters.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param rulesEngineName Name of the Rules Engine which is unique within the Front Door.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, frontDoorName, rulesEngineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, frontDoorName, rulesEngineName, options },
                spec: deleteOperationSpec$2,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Rules Engine Configuration with the specified parameters.
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param rulesEngineName Name of the Rules Engine which is unique within the Front Door.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, frontDoorName, rulesEngineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, frontDoorName, rulesEngineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByFrontDoorNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param frontDoorName Name of the Front Door which is globally unique.
     * @param nextLink The nextLink from the previous successful call to the ListByFrontDoor method.
     * @param options The options parameters.
     */
    _listByFrontDoorNext(resourceGroupName, frontDoorName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, frontDoorName, nextLink, options }, listByFrontDoorNextOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByFrontDoorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/rulesEngines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RulesEngineListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
    ],
    headerParameters: [accept],
    serializer: serializer$4,
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/rulesEngines/{rulesEngineName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RulesEngine,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
        rulesEngineName,
    ],
    headerParameters: [accept],
    serializer: serializer$4,
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/rulesEngines/{rulesEngineName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RulesEngine,
        },
        201: {
            bodyMapper: RulesEngine,
        },
        202: {
            bodyMapper: RulesEngine,
        },
        204: {
            bodyMapper: RulesEngine,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: rulesEngineParameters,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
        rulesEngineName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4,
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/rulesEngines/{rulesEngineName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        frontDoorName,
        rulesEngineName,
    ],
    headerParameters: [accept],
    serializer: serializer$4,
};
const listByFrontDoorNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RulesEngineListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        frontDoorName,
    ],
    headerParameters: [accept],
    serializer: serializer$4,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkExperimentProfiles operations. */
class NetworkExperimentProfilesImpl {
    /**
     * Initialize a new instance of the class NetworkExperimentProfiles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of Network Experiment Profiles under a subscription
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of Network Experiment Profiles within a resource group under a subscription
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of Network Experiment Profiles under a subscription
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * Gets a list of Network Experiment Profiles within a resource group under a subscription
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets an NetworkExperiment Profile by ProfileName
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, getOperationSpec$1);
    }
    /**
     * Creates an NetworkExperiment Profile
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param parameters An Network Experiment Profile
     * @param options The options parameters.
     */
    beginCreateOrUpdate(profileName, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { profileName, resourceGroupName, parameters, options },
                spec: createOrUpdateOperationSpec$1,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates an NetworkExperiment Profile
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param parameters An Network Experiment Profile
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(profileName, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(profileName, resourceGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an NetworkExperimentProfiles
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param parameters The Profile Update Model
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, profileName, parameters, options },
                spec: updateOperationSpec$1,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an NetworkExperimentProfiles
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param parameters The Profile Update Model
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an NetworkExperiment Profile by ProfileName
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, profileName, options },
                spec: deleteOperationSpec$1,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an NetworkExperiment Profile by ProfileName
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/NetworkExperimentProfiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion2],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3,
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Profile,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Profile,
        },
        201: {
            bodyMapper: Profile,
        },
        202: {
            bodyMapper: Profile,
        },
        204: {
            bodyMapper: Profile,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: parameters2,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3,
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Profile,
        },
        201: {
            bodyMapper: Profile,
        },
        202: {
            bodyMapper: Profile,
        },
        204: {
            bodyMapper: Profile,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: parameters3,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3,
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PreconfiguredEndpoints operations. */
class PreconfiguredEndpointsImpl {
    /**
     * Initialize a new instance of the class PreconfiguredEndpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of Preconfigured Endpoints
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    list(resourceGroupName, profileName, options) {
        const iter = this.listPagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, profileName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, profileName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of Preconfigured Endpoints
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    _list(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/PreconfiguredEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PreconfiguredEndpointList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PreconfiguredEndpointList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        profileName,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Experiments operations. */
class ExperimentsImpl {
    /**
     * Initialize a new instance of the class Experiments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of Experiments
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    listByProfile(resourceGroupName, profileName, options) {
        const iter = this.listByProfilePagingAll(resourceGroupName, profileName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByProfilePagingPage(resourceGroupName, profileName, options, settings);
            },
        };
    }
    listByProfilePagingPage(resourceGroupName, profileName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByProfile(resourceGroupName, profileName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByProfileNext(resourceGroupName, profileName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByProfilePagingAll(resourceGroupName, profileName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByProfilePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByProfilePagingPage(resourceGroupName, profileName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of Experiments
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param options The options parameters.
     */
    _listByProfile(resourceGroupName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, options }, listByProfileOperationSpec);
    }
    /**
     * Gets an Experiment by ExperimentName
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param options The options parameters.
     */
    get(resourceGroupName, profileName, experimentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, experimentName, options }, getOperationSpec);
    }
    /**
     * Creates or updates an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param parameters The Experiment resource
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, profileName, experimentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    profileName,
                    experimentName,
                    parameters,
                    options,
                },
                spec: createOrUpdateOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param parameters The Experiment resource
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, profileName, experimentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, profileName, experimentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param parameters The Experiment Update Model
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, profileName, experimentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    profileName,
                    experimentName,
                    parameters,
                    options,
                },
                spec: updateOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param parameters The Experiment Update Model
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, profileName, experimentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, profileName, experimentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, profileName, experimentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, profileName, experimentName, options },
                spec: deleteOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, profileName, experimentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, profileName, experimentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByProfileNext
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param nextLink The nextLink from the previous successful call to the ListByProfile method.
     * @param options The options parameters.
     */
    _listByProfileNext(resourceGroupName, profileName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, profileName, nextLink, options }, listByProfileNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByProfileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExperimentList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Experiment,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
        experimentName,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Experiment,
        },
        201: {
            bodyMapper: Experiment,
        },
        202: {
            bodyMapper: Experiment,
        },
        204: {
            bodyMapper: Experiment,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: parameters4,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
        experimentName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1,
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Experiment,
        },
        201: {
            bodyMapper: Experiment,
        },
        202: {
            bodyMapper: Experiment,
        },
        204: {
            bodyMapper: Experiment,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: parameters5,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
        experimentName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1,
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
        experimentName,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const listByProfileNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExperimentList,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        profileName,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Reports operations. */
class ReportsImpl {
    /**
     * Initialize a new instance of the class Reports class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a Latency Scorecard for a given Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param aggregationInterval The aggregation interval of the Latency Scorecard
     * @param options The options parameters.
     */
    getLatencyScorecards(resourceGroupName, profileName, experimentName, aggregationInterval, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            experimentName,
            aggregationInterval,
            options,
        }, getLatencyScorecardsOperationSpec);
    }
    /**
     * Gets a Timeseries for a given Experiment
     * @param resourceGroupName Name of the Resource group within the Azure subscription.
     * @param profileName The Profile identifier associated with the Tenant and Partner
     * @param experimentName The Experiment identifier associated with the Experiment
     * @param startDateTimeUTC The start DateTime of the Timeseries in UTC
     * @param endDateTimeUTC The end DateTime of the Timeseries in UTC
     * @param aggregationInterval The aggregation interval of the Timeseries
     * @param timeseriesType The type of Timeseries
     * @param options The options parameters.
     */
    getTimeseries(resourceGroupName, profileName, experimentName, startDateTimeUTC, endDateTimeUTC, aggregationInterval, timeseriesType, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            profileName,
            experimentName,
            startDateTimeUTC,
            endDateTimeUTC,
            aggregationInterval,
            timeseriesType,
            options,
        }, getTimeseriesOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getLatencyScorecardsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}/LatencyScorecard",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LatencyScorecard,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [
        apiVersion2,
        endDateTimeUTC,
        country,
        aggregationInterval,
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
        experimentName,
    ],
    headerParameters: [accept],
    serializer,
};
const getTimeseriesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}/Timeseries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Timeseries,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [
        apiVersion2,
        country,
        startDateTimeUTC,
        endDateTimeUTC1,
        aggregationInterval1,
        timeseriesType,
        endpoint,
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        profileName,
        experimentName,
    ],
    headerParameters: [accept],
    serializer,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class FrontDoorManagementClient extends coreClient__namespace.ServiceClient {
    constructor(credentials, subscriptionIdOrOptions, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        let subscriptionId;
        if (typeof subscriptionIdOrOptions === "string") {
            subscriptionId = subscriptionIdOrOptions;
        }
        else if (typeof subscriptionIdOrOptions === "object") {
            options = subscriptionIdOrOptions;
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials,
        };
        const packageDetails = `azsdk-js-arm-frontdoor/5.3.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix,
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName,
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge,
                },
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.policies = new PoliciesImpl(this);
        this.managedRuleSets = new ManagedRuleSetsImpl(this);
        this.frontDoorNameAvailability = new FrontDoorNameAvailabilityImpl(this);
        this.frontDoorNameAvailabilityWithSubscription =
            new FrontDoorNameAvailabilityWithSubscriptionImpl(this);
        this.frontDoors = new FrontDoorsImpl(this);
        this.frontendEndpoints = new FrontendEndpointsImpl(this);
        this.endpoints = new EndpointsImpl(this);
        this.rulesEngines = new RulesEnginesImpl(this);
        this.networkExperimentProfiles = new NetworkExperimentProfilesImpl(this);
        this.preconfiguredEndpoints = new PreconfiguredEndpointsImpl(this);
        this.experiments = new ExperimentsImpl(this);
        this.reports = new ReportsImpl(this);
    }
}

exports.FrontDoorManagementClient = FrontDoorManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
